{:functions ({:args [{:spelling "string", :type "CXString"}], :ret {:spelling "const char *"}, :function/args [:clang/CXString], :symbol "clang_getCString", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getCString, :raw-comment "/**\n * Retrieve the character data associated with the given string.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "string", :type "CXString"}], :ret {:spelling "void"}, :function/args [:clang/CXString], :symbol "clang_disposeString", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_disposeString, :raw-comment "/**\n * Free the given string.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "set", :type "CXStringSet *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clang/CXStringSet]], :symbol "clang_disposeStringSet", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_disposeStringSet, :raw-comment "/**\n * Free the given string set.\n */", :kind "CXCursor_FunctionDecl"} {:args [], :ret {:spelling "unsigned long long"}, :function/args [], :symbol "clang_getBuildSessionTimestamp", :function/ret :coffi.mem/long, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getBuildSessionTimestamp, :raw-comment "/**\n * Return the timestamp for use with Clang's\n * \\c -fbuild-session-timestamp= option.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "options", :type "unsigned int"}], :ret {:spelling "struct CXVirtualFileOverlayImpl *"}, :function/args [:coffi.mem/int], :symbol "clang_VirtualFileOverlay_create", :function/ret [:coffi.mem/pointer :clang/CXVirtualFileOverlayImpl], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_VirtualFileOverlay_create, :raw-comment "/**\n * Create a \\c CXVirtualFileOverlay object.\n * Must be disposed with \\c clang_VirtualFileOverlay_dispose().\n *\n * \\param options is reserved, always pass 0.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "", :type "struct CXVirtualFileOverlayImpl *"} {:spelling "virtualPath", :type "const char *"} {:spelling "realPath", :type "const char *"}], :ret {:spelling "enum CXErrorCode"}, :function/args [[:coffi.mem/pointer :clang/CXVirtualFileOverlayImpl] [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/char]], :symbol "clang_VirtualFileOverlay_addFileMapping", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_VirtualFileOverlay_addFileMapping, :raw-comment "/**\n * Map an absolute virtual file path to an absolute real one.\n * The virtual path must be canonicalized (not contain \".\"/\"..\").\n * \\returns 0 for success, non-zero to indicate an error.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "", :type "struct CXVirtualFileOverlayImpl *"} {:spelling "caseSensitive", :type "int"}], :ret {:spelling "enum CXErrorCode"}, :function/args [[:coffi.mem/pointer :clang/CXVirtualFileOverlayImpl] :coffi.mem/int], :symbol "clang_VirtualFileOverlay_setCaseSensitivity", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_VirtualFileOverlay_setCaseSensitivity, :raw-comment "/**\n * Set the case sensitivity for the \\c CXVirtualFileOverlay object.\n * The \\c CXVirtualFileOverlay object is case-sensitive by default, this\n * option can be used to override the default.\n * \\returns 0 for success, non-zero to indicate an error.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "", :type "struct CXVirtualFileOverlayImpl *"} {:spelling "options", :type "unsigned int"} {:spelling "out_buffer_ptr", :type "char **"} {:spelling "out_buffer_size", :type "unsigned int *"}], :ret {:spelling "enum CXErrorCode"}, :function/args [[:coffi.mem/pointer :clang/CXVirtualFileOverlayImpl] :coffi.mem/int [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]] [:coffi.mem/pointer :coffi.mem/int]], :symbol "clang_VirtualFileOverlay_writeToBuffer", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_VirtualFileOverlay_writeToBuffer, :raw-comment "/**\n * Write out the \\c CXVirtualFileOverlay object to a char buffer.\n *\n * \\param options is reserved, always pass 0.\n * \\param out_buffer_ptr pointer to receive the buffer pointer, which should be\n * disposed using \\c clang_free().\n * \\param out_buffer_size pointer to receive the buffer size.\n * \\returns 0 for success, non-zero to indicate an error.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "buffer", :type "void *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/pointer], :symbol "clang_free", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_free, :raw-comment "/**\n * free memory allocated by libclang, such as the buffer returned by\n * \\c CXVirtualFileOverlay() or \\c clang_ModuleMapDescriptor_writeToBuffer().\n *\n * \\param buffer memory pointer to free.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "", :type "struct CXVirtualFileOverlayImpl *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clang/CXVirtualFileOverlayImpl]], :symbol "clang_VirtualFileOverlay_dispose", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_VirtualFileOverlay_dispose, :raw-comment "/**\n * Dispose a \\c CXVirtualFileOverlay object.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "options", :type "unsigned int"}], :ret {:spelling "struct CXModuleMapDescriptorImpl *"}, :function/args [:coffi.mem/int], :symbol "clang_ModuleMapDescriptor_create", :function/ret [:coffi.mem/pointer :clang/CXModuleMapDescriptorImpl], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_ModuleMapDescriptor_create, :raw-comment "/**\n * Create a \\c CXModuleMapDescriptor object.\n * Must be disposed with \\c clang_ModuleMapDescriptor_dispose().\n *\n * \\param options is reserved, always pass 0.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "", :type "struct CXModuleMapDescriptorImpl *"} {:spelling "name", :type "const char *"}], :ret {:spelling "enum CXErrorCode"}, :function/args [[:coffi.mem/pointer :clang/CXModuleMapDescriptorImpl] [:coffi.mem/pointer :coffi.mem/char]], :symbol "clang_ModuleMapDescriptor_setFrameworkModuleName", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_ModuleMapDescriptor_setFrameworkModuleName, :raw-comment "/**\n * Sets the framework module name that the module.map describes.\n * \\returns 0 for success, non-zero to indicate an error.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "", :type "struct CXModuleMapDescriptorImpl *"} {:spelling "name", :type "const char *"}], :ret {:spelling "enum CXErrorCode"}, :function/args [[:coffi.mem/pointer :clang/CXModuleMapDescriptorImpl] [:coffi.mem/pointer :coffi.mem/char]], :symbol "clang_ModuleMapDescriptor_setUmbrellaHeader", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_ModuleMapDescriptor_setUmbrellaHeader, :raw-comment "/**\n * Sets the umbrella header name that the module.map describes.\n * \\returns 0 for success, non-zero to indicate an error.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "", :type "struct CXModuleMapDescriptorImpl *"} {:spelling "options", :type "unsigned int"} {:spelling "out_buffer_ptr", :type "char **"} {:spelling "out_buffer_size", :type "unsigned int *"}], :ret {:spelling "enum CXErrorCode"}, :function/args [[:coffi.mem/pointer :clang/CXModuleMapDescriptorImpl] :coffi.mem/int [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]] [:coffi.mem/pointer :coffi.mem/int]], :symbol "clang_ModuleMapDescriptor_writeToBuffer", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_ModuleMapDescriptor_writeToBuffer, :raw-comment "/**\n * Write out the \\c CXModuleMapDescriptor object to a char buffer.\n *\n * \\param options is reserved, always pass 0.\n * \\param out_buffer_ptr pointer to receive the buffer pointer, which should be\n * disposed using \\c clang_free().\n * \\param out_buffer_size pointer to receive the buffer size.\n * \\returns 0 for success, non-zero to indicate an error.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "", :type "struct CXModuleMapDescriptorImpl *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clang/CXModuleMapDescriptorImpl]], :symbol "clang_ModuleMapDescriptor_dispose", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_ModuleMapDescriptor_dispose, :raw-comment "/**\n * Dispose a \\c CXModuleMapDescriptor object.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "excludeDeclarationsFromPCH", :type "int"} {:spelling "displayDiagnostics", :type "int"}], :ret {:spelling "void *"}, :function/args [:coffi.mem/int :coffi.mem/int], :symbol "clang_createIndex", :function/ret :coffi.mem/pointer, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_createIndex, :raw-comment "/**\n * Provides a shared context for creating translation units.\n *\n * It provides two options:\n *\n * - excludeDeclarationsFromPCH: When non-zero, allows enumeration of \"local\"\n * declarations (when loading any new translation units). A \"local\" declaration\n * is one that belongs in the translation unit itself and not in a precompiled\n * header that was used by the translation unit. If zero, all declarations\n * will be enumerated.\n *\n * Here is an example:\n *\n * \\code\n *   // excludeDeclsFromPCH = 1, displayDiagnostics=1\n *   Idx = clang_createIndex(1, 1);\n *\n *   // IndexTest.pch was produced with the following command:\n *   // \"clang -x c IndexTest.h -emit-ast -o IndexTest.pch\"\n *   TU = clang_createTranslationUnit(Idx, \"IndexTest.pch\");\n *\n *   // This will load all the symbols from 'IndexTest.pch'\n *   clang_visitChildren(clang_getTranslationUnitCursor(TU),\n *                       TranslationUnitVisitor, 0);\n *   clang_disposeTranslationUnit(TU);\n *\n *   // This will load all the symbols from 'IndexTest.c', excluding symbols\n *   // from 'IndexTest.pch'.\n *   char *args[] = { \"-Xclang\", \"-include-pch=IndexTest.pch\" };\n *   TU = clang_createTranslationUnitFromSourceFile(Idx, \"IndexTest.c\", 2, args,\n *                                                  0, 0);\n *   clang_visitChildren(clang_getTranslationUnitCursor(TU),\n *                       TranslationUnitVisitor, 0);\n *   clang_disposeTranslationUnit(TU);\n * \\endcode\n *\n * This process of creating the 'pch', loading it separately, and using it (via\n * -include-pch) allows 'excludeDeclsFromPCH' to remove redundant callbacks\n * (which gives the indexer the same performance benefit as the compiler).\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "index", :type "void *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/pointer], :symbol "clang_disposeIndex", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_disposeIndex, :raw-comment "/**\n * Destroy the given index.\n *\n * The index must not be destroyed until all of the translation units created\n * within that index have been destroyed.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "", :type "void *"} {:spelling "options", :type "unsigned int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/pointer :coffi.mem/int], :symbol "clang_CXIndex_setGlobalOptions", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_CXIndex_setGlobalOptions, :raw-comment "/**\n * Sets general options associated with a CXIndex.\n *\n * For example:\n * \\code\n * CXIndex idx = ...;\n * clang_CXIndex_setGlobalOptions(idx,\n *     clang_CXIndex_getGlobalOptions(idx) |\n *     CXGlobalOpt_ThreadBackgroundPriorityForIndexing);\n * \\endcode\n *\n * \\param options A bitmask of options, a bitwise OR of CXGlobalOpt_XXX flags.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "", :type "void *"}], :ret {:spelling "unsigned int"}, :function/args [:coffi.mem/pointer], :symbol "clang_CXIndex_getGlobalOptions", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_CXIndex_getGlobalOptions, :raw-comment "/**\n * Gets the general options associated with a CXIndex.\n *\n * \\returns A bitmask of options, a bitwise OR of CXGlobalOpt_XXX flags that\n * are associated with the given CXIndex object.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "", :type "void *"} {:spelling "Path", :type "const char *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]], :symbol "clang_CXIndex_setInvocationEmissionPathOption", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_CXIndex_setInvocationEmissionPathOption, :raw-comment "/**\n * Sets the invocation emission path option in a CXIndex.\n *\n * The invocation emission path specifies a path which will contain log\n * files for certain libclang invocations. A null value (default) implies that\n * libclang invocations are not logged..\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "SFile", :type "void *"}], :ret {:spelling "CXString"}, :function/args [:coffi.mem/pointer], :symbol "clang_getFileName", :function/ret :clang/CXString, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getFileName, :raw-comment "/**\n * Retrieve the complete file and path name of the given file.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "SFile", :type "void *"}], :ret {:spelling "int"}, :function/args [:coffi.mem/pointer], :symbol "clang_getFileTime", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getFileTime, :raw-comment "/**\n * Retrieve the last modification time of the given file.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "file", :type "void *"} {:spelling "outID", :type "CXFileUniqueID *"}], :ret {:spelling "int"}, :function/args [:coffi.mem/pointer [:coffi.mem/pointer :clang/CXFileUniqueID]], :symbol "clang_getFileUniqueID", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getFileUniqueID, :raw-comment "/**\n * Retrieve the unique ID for the given \\c file.\n *\n * \\param file the file to get the ID for.\n * \\param outID stores the returned CXFileUniqueID.\n * \\returns If there was a failure getting the unique ID, returns non-zero,\n * otherwise returns 0.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "tu", :type "struct CXTranslationUnitImpl *"} {:spelling "file", :type "void *"}], :ret {:spelling "unsigned int"}, :function/args [[:coffi.mem/pointer :clang/CXTranslationUnitImpl] :coffi.mem/pointer], :symbol "clang_isFileMultipleIncludeGuarded", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_isFileMultipleIncludeGuarded, :raw-comment "/**\n * Determine whether the given header is guarded against\n * multiple inclusions, either with the conventional\n * \\#ifndef/\\#define/\\#endif macro guards or with \\#pragma once.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "tu", :type "struct CXTranslationUnitImpl *"} {:spelling "file_name", :type "const char *"}], :ret {:spelling "void *"}, :function/args [[:coffi.mem/pointer :clang/CXTranslationUnitImpl] [:coffi.mem/pointer :coffi.mem/char]], :symbol "clang_getFile", :function/ret :coffi.mem/pointer, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getFile, :raw-comment "/**\n * Retrieve a file handle within the given translation unit.\n *\n * \\param tu the translation unit\n *\n * \\param file_name the name of the file.\n *\n * \\returns the file handle for the named file in the translation unit \\p tu,\n * or a NULL file handle if the file was not a part of this translation unit.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "tu", :type "struct CXTranslationUnitImpl *"} {:spelling "file", :type "void *"} {:spelling "size", :type "int *"}], :ret {:spelling "const char *"}, :function/args [[:coffi.mem/pointer :clang/CXTranslationUnitImpl] :coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/int]], :symbol "clang_getFileContents", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getFileContents, :raw-comment "/**\n * Retrieve the buffer associated with the given file.\n *\n * \\param tu the translation unit\n *\n * \\param file the file for which to retrieve the buffer.\n *\n * \\param size [out] if non-NULL, will be set to the size of the buffer.\n *\n * \\returns a pointer to the buffer in memory that holds the contents of\n * \\p file, or a NULL pointer when the file is not loaded.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "file1", :type "void *"} {:spelling "file2", :type "void *"}], :ret {:spelling "int"}, :function/args [:coffi.mem/pointer :coffi.mem/pointer], :symbol "clang_File_isEqual", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_File_isEqual, :raw-comment "/**\n * Returns non-zero if the \\c file1 and \\c file2 point to the same file,\n * or they are both NULL.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "file", :type "void *"}], :ret {:spelling "CXString"}, :function/args [:coffi.mem/pointer], :symbol "clang_File_tryGetRealPathName", :function/ret :clang/CXString, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_File_tryGetRealPathName, :raw-comment "/**\n * Returns the real path name of \\c file.\n *\n * An empty string may be returned. Use \\c clang_getFileName() in that case.\n */", :kind "CXCursor_FunctionDecl"} {:args [], :ret {:spelling "CXSourceLocation"}, :function/args [], :symbol "clang_getNullLocation", :function/ret :clang/CXSourceLocation, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getNullLocation, :raw-comment "/**\n * Retrieve a NULL (invalid) source location.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "loc1", :type "CXSourceLocation"} {:spelling "loc2", :type "CXSourceLocation"}], :ret {:spelling "unsigned int"}, :function/args [:clang/CXSourceLocation :clang/CXSourceLocation], :symbol "clang_equalLocations", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_equalLocations, :raw-comment "/**\n * Determine whether two source locations, which must refer into\n * the same translation unit, refer to exactly the same point in the source\n * code.\n *\n * \\returns non-zero if the source locations refer to the same location, zero\n * if they refer to different locations.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "tu", :type "struct CXTranslationUnitImpl *"} {:spelling "file", :type "void *"} {:spelling "line", :type "unsigned int"} {:spelling "column", :type "unsigned int"}], :ret {:spelling "CXSourceLocation"}, :function/args [[:coffi.mem/pointer :clang/CXTranslationUnitImpl] :coffi.mem/pointer :coffi.mem/int :coffi.mem/int], :symbol "clang_getLocation", :function/ret :clang/CXSourceLocation, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getLocation, :raw-comment "/**\n * Retrieves the source location associated with a given file/line/column\n * in a particular translation unit.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "tu", :type "struct CXTranslationUnitImpl *"} {:spelling "file", :type "void *"} {:spelling "offset", :type "unsigned int"}], :ret {:spelling "CXSourceLocation"}, :function/args [[:coffi.mem/pointer :clang/CXTranslationUnitImpl] :coffi.mem/pointer :coffi.mem/int], :symbol "clang_getLocationForOffset", :function/ret :clang/CXSourceLocation, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getLocationForOffset, :raw-comment "/**\n * Retrieves the source location associated with a given character offset\n * in a particular translation unit.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "location", :type "CXSourceLocation"}], :ret {:spelling "int"}, :function/args [:clang/CXSourceLocation], :symbol "clang_Location_isInSystemHeader", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_Location_isInSystemHeader, :raw-comment "/**\n * Returns non-zero if the given source location is in a system header.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "location", :type "CXSourceLocation"}], :ret {:spelling "int"}, :function/args [:clang/CXSourceLocation], :symbol "clang_Location_isFromMainFile", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_Location_isFromMainFile, :raw-comment "/**\n * Returns non-zero if the given source location is in the main file of\n * the corresponding translation unit.\n */", :kind "CXCursor_FunctionDecl"} {:args [], :ret {:spelling "CXSourceRange"}, :function/args [], :symbol "clang_getNullRange", :function/ret :clang/CXSourceRange, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getNullRange, :raw-comment "/**\n * Retrieve a NULL (invalid) source range.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "begin", :type "CXSourceLocation"} {:spelling "end", :type "CXSourceLocation"}], :ret {:spelling "CXSourceRange"}, :function/args [:clang/CXSourceLocation :clang/CXSourceLocation], :symbol "clang_getRange", :function/ret :clang/CXSourceRange, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getRange, :raw-comment "/**\n * Retrieve a source range given the beginning and ending source\n * locations.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "range1", :type "CXSourceRange"} {:spelling "range2", :type "CXSourceRange"}], :ret {:spelling "unsigned int"}, :function/args [:clang/CXSourceRange :clang/CXSourceRange], :symbol "clang_equalRanges", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_equalRanges, :raw-comment "/**\n * Determine whether two ranges are equivalent.\n *\n * \\returns non-zero if the ranges are the same, zero if they differ.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "range", :type "CXSourceRange"}], :ret {:spelling "int"}, :function/args [:clang/CXSourceRange], :symbol "clang_Range_isNull", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_Range_isNull, :raw-comment "/**\n * Returns non-zero if \\p range is null.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "location", :type "CXSourceLocation"} {:spelling "file", :type "void **"} {:spelling "line", :type "unsigned int *"} {:spelling "column", :type "unsigned int *"} {:spelling "offset", :type "unsigned int *"}], :ret {:spelling "void"}, :function/args [:clang/CXSourceLocation [:coffi.mem/pointer :coffi.mem/pointer] [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :coffi.mem/int]], :symbol "clang_getExpansionLocation", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getExpansionLocation, :raw-comment "/**\n * Retrieve the file, line, column, and offset represented by\n * the given source location.\n *\n * If the location refers into a macro expansion, retrieves the\n * location of the macro expansion.\n *\n * \\param location the location within a source file that will be decomposed\n * into its parts.\n *\n * \\param file [out] if non-NULL, will be set to the file to which the given\n * source location points.\n *\n * \\param line [out] if non-NULL, will be set to the line to which the given\n * source location points.\n *\n * \\param column [out] if non-NULL, will be set to the column to which the given\n * source location points.\n *\n * \\param offset [out] if non-NULL, will be set to the offset into the\n * buffer to which the given source location points.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "location", :type "CXSourceLocation"} {:spelling "filename", :type "CXString *"} {:spelling "line", :type "unsigned int *"} {:spelling "column", :type "unsigned int *"}], :ret {:spelling "void"}, :function/args [:clang/CXSourceLocation [:coffi.mem/pointer :clang/CXString] [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :coffi.mem/int]], :symbol "clang_getPresumedLocation", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getPresumedLocation, :raw-comment "/**\n * Retrieve the file, line and column represented by the given source\n * location, as specified in a # line directive.\n *\n * Example: given the following source code in a file somefile.c\n *\n * \\code\n * #123 \"dummy.c\" 1\n *\n * static int func(void)\n * {\n *     return 0;\n * }\n * \\endcode\n *\n * the location information returned by this function would be\n *\n * File: dummy.c Line: 124 Column: 12\n *\n * whereas clang_getExpansionLocation would have returned\n *\n * File: somefile.c Line: 3 Column: 12\n *\n * \\param location the location within a source file that will be decomposed\n * into its parts.\n *\n * \\param filename [out] if non-NULL, will be set to the filename of the\n * source location. Note that filenames returned will be for \"virtual\" files,\n * which don't necessarily exist on the machine running clang - e.g. when\n * parsing preprocessed output obtained from a different environment. If\n * a non-NULL value is passed in, remember to dispose of the returned value\n * using \\c clang_disposeString() once you've finished with it. For an invalid\n * source location, an empty string is returned.\n *\n * \\param line [out] if non-NULL, will be set to the line number of the\n * source location. For an invalid source location, zero is returned.\n *\n * \\param column [out] if non-NULL, will be set to the column number of the\n * source location. For an invalid source location, zero is returned.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "location", :type "CXSourceLocation"} {:spelling "file", :type "void **"} {:spelling "line", :type "unsigned int *"} {:spelling "column", :type "unsigned int *"} {:spelling "offset", :type "unsigned int *"}], :ret {:spelling "void"}, :function/args [:clang/CXSourceLocation [:coffi.mem/pointer :coffi.mem/pointer] [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :coffi.mem/int]], :symbol "clang_getInstantiationLocation", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getInstantiationLocation, :raw-comment "/**\n * Legacy API to retrieve the file, line, column, and offset represented\n * by the given source location.\n *\n * This interface has been replaced by the newer interface\n * #clang_getExpansionLocation(). See that interface's documentation for\n * details.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "location", :type "CXSourceLocation"} {:spelling "file", :type "void **"} {:spelling "line", :type "unsigned int *"} {:spelling "column", :type "unsigned int *"} {:spelling "offset", :type "unsigned int *"}], :ret {:spelling "void"}, :function/args [:clang/CXSourceLocation [:coffi.mem/pointer :coffi.mem/pointer] [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :coffi.mem/int]], :symbol "clang_getSpellingLocation", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getSpellingLocation, :raw-comment "/**\n * Retrieve the file, line, column, and offset represented by\n * the given source location.\n *\n * If the location refers into a macro instantiation, return where the\n * location was originally spelled in the source file.\n *\n * \\param location the location within a source file that will be decomposed\n * into its parts.\n *\n * \\param file [out] if non-NULL, will be set to the file to which the given\n * source location points.\n *\n * \\param line [out] if non-NULL, will be set to the line to which the given\n * source location points.\n *\n * \\param column [out] if non-NULL, will be set to the column to which the given\n * source location points.\n *\n * \\param offset [out] if non-NULL, will be set to the offset into the\n * buffer to which the given source location points.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "location", :type "CXSourceLocation"} {:spelling "file", :type "void **"} {:spelling "line", :type "unsigned int *"} {:spelling "column", :type "unsigned int *"} {:spelling "offset", :type "unsigned int *"}], :ret {:spelling "void"}, :function/args [:clang/CXSourceLocation [:coffi.mem/pointer :coffi.mem/pointer] [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :coffi.mem/int]], :symbol "clang_getFileLocation", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getFileLocation, :raw-comment "/**\n * Retrieve the file, line, column, and offset represented by\n * the given source location.\n *\n * If the location refers into a macro expansion, return where the macro was\n * expanded or where the macro argument was written, if the location points at\n * a macro argument.\n *\n * \\param location the location within a source file that will be decomposed\n * into its parts.\n *\n * \\param file [out] if non-NULL, will be set to the file to which the given\n * source location points.\n *\n * \\param line [out] if non-NULL, will be set to the line to which the given\n * source location points.\n *\n * \\param column [out] if non-NULL, will be set to the column to which the given\n * source location points.\n *\n * \\param offset [out] if non-NULL, will be set to the offset into the\n * buffer to which the given source location points.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "range", :type "CXSourceRange"}], :ret {:spelling "CXSourceLocation"}, :function/args [:clang/CXSourceRange], :symbol "clang_getRangeStart", :function/ret :clang/CXSourceLocation, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getRangeStart, :raw-comment "/**\n * Retrieve a source location representing the first character within a\n * source range.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "range", :type "CXSourceRange"}], :ret {:spelling "CXSourceLocation"}, :function/args [:clang/CXSourceRange], :symbol "clang_getRangeEnd", :function/ret :clang/CXSourceLocation, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getRangeEnd, :raw-comment "/**\n * Retrieve a source location representing the last character within a\n * source range.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "tu", :type "struct CXTranslationUnitImpl *"} {:spelling "file", :type "void *"}], :ret {:spelling "CXSourceRangeList *"}, :function/args [[:coffi.mem/pointer :clang/CXTranslationUnitImpl] :coffi.mem/pointer], :symbol "clang_getSkippedRanges", :function/ret [:coffi.mem/pointer :clang/CXSourceRangeList], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getSkippedRanges, :raw-comment "/**\n * Retrieve all ranges that were skipped by the preprocessor.\n *\n * The preprocessor will skip lines when they are surrounded by an\n * if/ifdef/ifndef directive whose condition does not evaluate to true.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "tu", :type "struct CXTranslationUnitImpl *"}], :ret {:spelling "CXSourceRangeList *"}, :function/args [[:coffi.mem/pointer :clang/CXTranslationUnitImpl]], :symbol "clang_getAllSkippedRanges", :function/ret [:coffi.mem/pointer :clang/CXSourceRangeList], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getAllSkippedRanges, :raw-comment "/**\n * Retrieve all ranges from all files that were skipped by the\n * preprocessor.\n *\n * The preprocessor will skip lines when they are surrounded by an\n * if/ifdef/ifndef directive whose condition does not evaluate to true.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "ranges", :type "CXSourceRangeList *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clang/CXSourceRangeList]], :symbol "clang_disposeSourceRangeList", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_disposeSourceRangeList, :raw-comment "/**\n * Destroy the given \\c CXSourceRangeList.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "Diags", :type "void *"}], :ret {:spelling "unsigned int"}, :function/args [:coffi.mem/pointer], :symbol "clang_getNumDiagnosticsInSet", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getNumDiagnosticsInSet, :raw-comment "/**\n * Determine the number of diagnostics in a CXDiagnosticSet.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "Diags", :type "void *"} {:spelling "Index", :type "unsigned int"}], :ret {:spelling "void *"}, :function/args [:coffi.mem/pointer :coffi.mem/int], :symbol "clang_getDiagnosticInSet", :function/ret :coffi.mem/pointer, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getDiagnosticInSet, :raw-comment "/**\n * Retrieve a diagnostic associated with the given CXDiagnosticSet.\n *\n * \\param Diags the CXDiagnosticSet to query.\n * \\param Index the zero-based diagnostic number to retrieve.\n *\n * \\returns the requested diagnostic. This diagnostic must be freed\n * via a call to \\c clang_disposeDiagnostic().\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "file", :type "const char *"} {:spelling "error", :type "enum CXLoadDiag_Error *"} {:spelling "errorString", :type "CXString *"}], :ret {:spelling "void *"}, :function/args [[:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :clang/CXString]], :symbol "clang_loadDiagnostics", :function/ret :coffi.mem/pointer, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_loadDiagnostics, :raw-comment "/**\n * Deserialize a set of diagnostics from a Clang diagnostics bitcode\n * file.\n *\n * \\param file The name of the file to deserialize.\n * \\param error A pointer to a enum value recording if there was a problem\n *        deserializing the diagnostics.\n * \\param errorString A pointer to a CXString for recording the error string\n *        if the file was not successfully loaded.\n *\n * \\returns A loaded CXDiagnosticSet if successful, and NULL otherwise.  These\n * diagnostics should be released using clang_disposeDiagnosticSet().\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "Diags", :type "void *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/pointer], :symbol "clang_disposeDiagnosticSet", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_disposeDiagnosticSet, :raw-comment "/**\n * Release a CXDiagnosticSet and all of its contained diagnostics.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "D", :type "void *"}], :ret {:spelling "void *"}, :function/args [:coffi.mem/pointer], :symbol "clang_getChildDiagnostics", :function/ret :coffi.mem/pointer, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getChildDiagnostics, :raw-comment "/**\n * Retrieve the child diagnostics of a CXDiagnostic.\n *\n * This CXDiagnosticSet does not need to be released by\n * clang_disposeDiagnosticSet.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "Unit", :type "struct CXTranslationUnitImpl *"}], :ret {:spelling "unsigned int"}, :function/args [[:coffi.mem/pointer :clang/CXTranslationUnitImpl]], :symbol "clang_getNumDiagnostics", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getNumDiagnostics, :raw-comment "/**\n * Determine the number of diagnostics produced for the given\n * translation unit.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "Unit", :type "struct CXTranslationUnitImpl *"} {:spelling "Index", :type "unsigned int"}], :ret {:spelling "void *"}, :function/args [[:coffi.mem/pointer :clang/CXTranslationUnitImpl] :coffi.mem/int], :symbol "clang_getDiagnostic", :function/ret :coffi.mem/pointer, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getDiagnostic, :raw-comment "/**\n * Retrieve a diagnostic associated with the given translation unit.\n *\n * \\param Unit the translation unit to query.\n * \\param Index the zero-based diagnostic number to retrieve.\n *\n * \\returns the requested diagnostic. This diagnostic must be freed\n * via a call to \\c clang_disposeDiagnostic().\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "Unit", :type "struct CXTranslationUnitImpl *"}], :ret {:spelling "void *"}, :function/args [[:coffi.mem/pointer :clang/CXTranslationUnitImpl]], :symbol "clang_getDiagnosticSetFromTU", :function/ret :coffi.mem/pointer, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getDiagnosticSetFromTU, :raw-comment "/**\n * Retrieve the complete set of diagnostics associated with a\n *        translation unit.\n *\n * \\param Unit the translation unit to query.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "Diagnostic", :type "void *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/pointer], :symbol "clang_disposeDiagnostic", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_disposeDiagnostic, :raw-comment "/**\n * Destroy a diagnostic.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "Diagnostic", :type "void *"} {:spelling "Options", :type "unsigned int"}], :ret {:spelling "CXString"}, :function/args [:coffi.mem/pointer :coffi.mem/int], :symbol "clang_formatDiagnostic", :function/ret :clang/CXString, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_formatDiagnostic, :raw-comment "/**\n * Format the given diagnostic in a manner that is suitable for display.\n *\n * This routine will format the given diagnostic to a string, rendering\n * the diagnostic according to the various options given. The\n * \\c clang_defaultDiagnosticDisplayOptions() function returns the set of\n * options that most closely mimics the behavior of the clang compiler.\n *\n * \\param Diagnostic The diagnostic to print.\n *\n * \\param Options A set of options that control the diagnostic display,\n * created by combining \\c CXDiagnosticDisplayOptions values.\n *\n * \\returns A new string containing for formatted diagnostic.\n */", :kind "CXCursor_FunctionDecl"} {:args [], :ret {:spelling "unsigned int"}, :function/args [], :symbol "clang_defaultDiagnosticDisplayOptions", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_defaultDiagnosticDisplayOptions, :raw-comment "/**\n * Retrieve the set of display options most similar to the\n * default behavior of the clang compiler.\n *\n * \\returns A set of display options suitable for use with \\c\n * clang_formatDiagnostic().\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "", :type "void *"}], :ret {:spelling "enum CXDiagnosticSeverity"}, :function/args [:coffi.mem/pointer], :symbol "clang_getDiagnosticSeverity", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getDiagnosticSeverity, :raw-comment "/**\n * Determine the severity of the given diagnostic.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "", :type "void *"}], :ret {:spelling "CXSourceLocation"}, :function/args [:coffi.mem/pointer], :symbol "clang_getDiagnosticLocation", :function/ret :clang/CXSourceLocation, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getDiagnosticLocation, :raw-comment "/**\n * Retrieve the source location of the given diagnostic.\n *\n * This location is where Clang would print the caret ('^') when\n * displaying the diagnostic on the command line.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "", :type "void *"}], :ret {:spelling "CXString"}, :function/args [:coffi.mem/pointer], :symbol "clang_getDiagnosticSpelling", :function/ret :clang/CXString, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getDiagnosticSpelling, :raw-comment "/**\n * Retrieve the text of the given diagnostic.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "Diag", :type "void *"} {:spelling "Disable", :type "CXString *"}], :ret {:spelling "CXString"}, :function/args [:coffi.mem/pointer [:coffi.mem/pointer :clang/CXString]], :symbol "clang_getDiagnosticOption", :function/ret :clang/CXString, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getDiagnosticOption, :raw-comment "/**\n * Retrieve the name of the command-line option that enabled this\n * diagnostic.\n *\n * \\param Diag The diagnostic to be queried.\n *\n * \\param Disable If non-NULL, will be set to the option that disables this\n * diagnostic (if any).\n *\n * \\returns A string that contains the command-line option used to enable this\n * warning, such as \"-Wconversion\" or \"-pedantic\".\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "", :type "void *"}], :ret {:spelling "unsigned int"}, :function/args [:coffi.mem/pointer], :symbol "clang_getDiagnosticCategory", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getDiagnosticCategory, :raw-comment "/**\n * Retrieve the category number for this diagnostic.\n *\n * Diagnostics can be categorized into groups along with other, related\n * diagnostics (e.g., diagnostics under the same warning flag). This routine\n * retrieves the category number for the given diagnostic.\n *\n * \\returns The number of the category that contains this diagnostic, or zero\n * if this diagnostic is uncategorized.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "Category", :type "unsigned int"}], :ret {:spelling "CXString"}, :function/args [:coffi.mem/int], :symbol "clang_getDiagnosticCategoryName", :function/ret :clang/CXString, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getDiagnosticCategoryName, :raw-comment "/**\n * Retrieve the name of a particular diagnostic category.  This\n *  is now deprecated.  Use clang_getDiagnosticCategoryText()\n *  instead.\n *\n * \\param Category A diagnostic category number, as returned by\n * \\c clang_getDiagnosticCategory().\n *\n * \\returns The name of the given diagnostic category.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "", :type "void *"}], :ret {:spelling "CXString"}, :function/args [:coffi.mem/pointer], :symbol "clang_getDiagnosticCategoryText", :function/ret :clang/CXString, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getDiagnosticCategoryText, :raw-comment "/**\n * Retrieve the diagnostic category text for a given diagnostic.\n *\n * \\returns The text of the given diagnostic category.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "", :type "void *"}], :ret {:spelling "unsigned int"}, :function/args [:coffi.mem/pointer], :symbol "clang_getDiagnosticNumRanges", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getDiagnosticNumRanges, :raw-comment "/**\n * Determine the number of source ranges associated with the given\n * diagnostic.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "Diagnostic", :type "void *"} {:spelling "Range", :type "unsigned int"}], :ret {:spelling "CXSourceRange"}, :function/args [:coffi.mem/pointer :coffi.mem/int], :symbol "clang_getDiagnosticRange", :function/ret :clang/CXSourceRange, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getDiagnosticRange, :raw-comment "/**\n * Retrieve a source range associated with the diagnostic.\n *\n * A diagnostic's source ranges highlight important elements in the source\n * code. On the command line, Clang displays source ranges by\n * underlining them with '~' characters.\n *\n * \\param Diagnostic the diagnostic whose range is being extracted.\n *\n * \\param Range the zero-based index specifying which range to\n *\n * \\returns the requested source range.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "Diagnostic", :type "void *"}], :ret {:spelling "unsigned int"}, :function/args [:coffi.mem/pointer], :symbol "clang_getDiagnosticNumFixIts", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getDiagnosticNumFixIts, :raw-comment "/**\n * Determine the number of fix-it hints associated with the\n * given diagnostic.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "Diagnostic", :type "void *"} {:spelling "FixIt", :type "unsigned int"} {:spelling "ReplacementRange", :type "CXSourceRange *"}], :ret {:spelling "CXString"}, :function/args [:coffi.mem/pointer :coffi.mem/int [:coffi.mem/pointer :clang/CXSourceRange]], :symbol "clang_getDiagnosticFixIt", :function/ret :clang/CXString, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getDiagnosticFixIt, :raw-comment "/**\n * Retrieve the replacement information for a given fix-it.\n *\n * Fix-its are described in terms of a source range whose contents\n * should be replaced by a string. This approach generalizes over\n * three kinds of operations: removal of source code (the range covers\n * the code to be removed and the replacement string is empty),\n * replacement of source code (the range covers the code to be\n * replaced and the replacement string provides the new code), and\n * insertion (both the start and end of the range point at the\n * insertion location, and the replacement string provides the text to\n * insert).\n *\n * \\param Diagnostic The diagnostic whose fix-its are being queried.\n *\n * \\param FixIt The zero-based index of the fix-it.\n *\n * \\param ReplacementRange The source range whose contents will be\n * replaced with the returned replacement string. Note that source\n * ranges are half-open ranges [a, b), so the source code should be\n * replaced from a and up to (but not including) b.\n *\n * \\returns A string containing text that should be replace the source\n * code indicated by the \\c ReplacementRange.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "CTUnit", :type "struct CXTranslationUnitImpl *"}], :ret {:spelling "CXString"}, :function/args [[:coffi.mem/pointer :clang/CXTranslationUnitImpl]], :symbol "clang_getTranslationUnitSpelling", :function/ret :clang/CXString, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getTranslationUnitSpelling, :raw-comment "/**\n * Get the original translation unit source file name.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "CIdx", :type "void *"} {:spelling "source_filename", :type "const char *"} {:spelling "num_clang_command_line_args", :type "int"} {:spelling "clang_command_line_args", :type "const char *const *"} {:spelling "num_unsaved_files", :type "unsigned int"} {:spelling "unsaved_files", :type "struct CXUnsavedFile *"}], :ret {:spelling "struct CXTranslationUnitImpl *"}, :function/args [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]] :coffi.mem/int [:coffi.mem/pointer :clang/CXUnsavedFile]], :symbol "clang_createTranslationUnitFromSourceFile", :function/ret [:coffi.mem/pointer :clang/CXTranslationUnitImpl], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_createTranslationUnitFromSourceFile, :raw-comment "/**\n * Return the CXTranslationUnit for a given source file and the provided\n * command line arguments one would pass to the compiler.\n *\n * Note: The 'source_filename' argument is optional.  If the caller provides a\n * NULL pointer, the name of the source file is expected to reside in the\n * specified command line arguments.\n *\n * Note: When encountered in 'clang_command_line_args', the following options\n * are ignored:\n *\n *   '-c'\n *   '-emit-ast'\n *   '-fsyntax-only'\n *   '-o \\<output file>'  (both '-o' and '\\<output file>' are ignored)\n *\n * \\param CIdx The index object with which the translation unit will be\n * associated.\n *\n * \\param source_filename The name of the source file to load, or NULL if the\n * source file is included in \\p clang_command_line_args.\n *\n * \\param num_clang_command_line_args The number of command-line arguments in\n * \\p clang_command_line_args.\n *\n * \\param clang_command_line_args The command-line arguments that would be\n * passed to the \\c clang executable if it were being invoked out-of-process.\n * These command-line options will be parsed and will affect how the translation\n * unit is parsed. Note that the following options are ignored: '-c',\n * '-emit-ast', '-fsyntax-only' (which is the default), and '-o \\<output file>'.\n *\n * \\param num_unsaved_files the number of unsaved file entries in \\p\n * unsaved_files.\n *\n * \\param unsaved_files the files that have not yet been saved to disk\n * but may be required for code completion, including the contents of\n * those files.  The contents and name of these files (as specified by\n * CXUnsavedFile) are copied when necessary, so the client only needs to\n * guarantee their validity until the call to this function returns.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "CIdx", :type "void *"} {:spelling "ast_filename", :type "const char *"}], :ret {:spelling "struct CXTranslationUnitImpl *"}, :function/args [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]], :symbol "clang_createTranslationUnit", :function/ret [:coffi.mem/pointer :clang/CXTranslationUnitImpl], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_createTranslationUnit, :raw-comment "/**\n * Same as \\c clang_createTranslationUnit2, but returns\n * the \\c CXTranslationUnit instead of an error code.  In case of an error this\n * routine returns a \\c NULL \\c CXTranslationUnit, without further detailed\n * error codes.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "CIdx", :type "void *"} {:spelling "ast_filename", :type "const char *"} {:spelling "out_TU", :type "struct CXTranslationUnitImpl **"}], :ret {:spelling "enum CXErrorCode"}, :function/args [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer [:coffi.mem/pointer :clang/CXTranslationUnitImpl]]], :symbol "clang_createTranslationUnit2", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_createTranslationUnit2, :raw-comment "/**\n * Create a translation unit from an AST file (\\c -emit-ast).\n *\n * \\param[out] out_TU A non-NULL pointer to store the created\n * \\c CXTranslationUnit.\n *\n * \\returns Zero on success, otherwise returns an error code.\n */", :kind "CXCursor_FunctionDecl"} {:args [], :ret {:spelling "unsigned int"}, :function/args [], :symbol "clang_defaultEditingTranslationUnitOptions", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_defaultEditingTranslationUnitOptions, :raw-comment "/**\n * Returns the set of flags that is suitable for parsing a translation\n * unit that is being edited.\n *\n * The set of flags returned provide options for \\c clang_parseTranslationUnit()\n * to indicate that the translation unit is likely to be reparsed many times,\n * either explicitly (via \\c clang_reparseTranslationUnit()) or implicitly\n * (e.g., by code completion (\\c clang_codeCompletionAt())). The returned flag\n * set contains an unspecified set of optimizations (e.g., the precompiled\n * preamble) geared toward improving the performance of these routines. The\n * set of optimizations enabled may change from one version to the next.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "CIdx", :type "void *"} {:spelling "source_filename", :type "const char *"} {:spelling "command_line_args", :type "const char *const *"} {:spelling "num_command_line_args", :type "int"} {:spelling "unsaved_files", :type "struct CXUnsavedFile *"} {:spelling "num_unsaved_files", :type "unsigned int"} {:spelling "options", :type "unsigned int"}], :ret {:spelling "struct CXTranslationUnitImpl *"}, :function/args [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]] :coffi.mem/int [:coffi.mem/pointer :clang/CXUnsavedFile] :coffi.mem/int :coffi.mem/int], :symbol "clang_parseTranslationUnit", :function/ret [:coffi.mem/pointer :clang/CXTranslationUnitImpl], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_parseTranslationUnit, :raw-comment "/**\n * Same as \\c clang_parseTranslationUnit2, but returns\n * the \\c CXTranslationUnit instead of an error code.  In case of an error this\n * routine returns a \\c NULL \\c CXTranslationUnit, without further detailed\n * error codes.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "CIdx", :type "void *"} {:spelling "source_filename", :type "const char *"} {:spelling "command_line_args", :type "const char *const *"} {:spelling "num_command_line_args", :type "int"} {:spelling "unsaved_files", :type "struct CXUnsavedFile *"} {:spelling "num_unsaved_files", :type "unsigned int"} {:spelling "options", :type "unsigned int"} {:spelling "out_TU", :type "struct CXTranslationUnitImpl **"}], :ret {:spelling "enum CXErrorCode"}, :function/args [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]] :coffi.mem/int [:coffi.mem/pointer :clang/CXUnsavedFile] :coffi.mem/int :coffi.mem/int [:coffi.mem/pointer [:coffi.mem/pointer :clang/CXTranslationUnitImpl]]], :symbol "clang_parseTranslationUnit2", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_parseTranslationUnit2, :raw-comment "/**\n * Parse the given source file and the translation unit corresponding\n * to that file.\n *\n * This routine is the main entry point for the Clang C API, providing the\n * ability to parse a source file into a translation unit that can then be\n * queried by other functions in the API. This routine accepts a set of\n * command-line arguments so that the compilation can be configured in the same\n * way that the compiler is configured on the command line.\n *\n * \\param CIdx The index object with which the translation unit will be\n * associated.\n *\n * \\param source_filename The name of the source file to load, or NULL if the\n * source file is included in \\c command_line_args.\n *\n * \\param command_line_args The command-line arguments that would be\n * passed to the \\c clang executable if it were being invoked out-of-process.\n * These command-line options will be parsed and will affect how the translation\n * unit is parsed. Note that the following options are ignored: '-c',\n * '-emit-ast', '-fsyntax-only' (which is the default), and '-o \\<output file>'.\n *\n * \\param num_command_line_args The number of command-line arguments in\n * \\c command_line_args.\n *\n * \\param unsaved_files the files that have not yet been saved to disk\n * but may be required for parsing, including the contents of\n * those files.  The contents and name of these files (as specified by\n * CXUnsavedFile) are copied when necessary, so the client only needs to\n * guarantee their validity until the call to this function returns.\n *\n * \\param num_unsaved_files the number of unsaved file entries in \\p\n * unsaved_files.\n *\n * \\param options A bitmask of options that affects how the translation unit\n * is managed but not its compilation. This should be a bitwise OR of the\n * CXTranslationUnit_XXX flags.\n *\n * \\param[out] out_TU A non-NULL pointer to store the created\n * \\c CXTranslationUnit, describing the parsed code and containing any\n * diagnostics produced by the compiler.\n *\n * \\returns Zero on success, otherwise returns an error code.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "CIdx", :type "void *"} {:spelling "source_filename", :type "const char *"} {:spelling "command_line_args", :type "const char *const *"} {:spelling "num_command_line_args", :type "int"} {:spelling "unsaved_files", :type "struct CXUnsavedFile *"} {:spelling "num_unsaved_files", :type "unsigned int"} {:spelling "options", :type "unsigned int"} {:spelling "out_TU", :type "struct CXTranslationUnitImpl **"}], :ret {:spelling "enum CXErrorCode"}, :function/args [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]] :coffi.mem/int [:coffi.mem/pointer :clang/CXUnsavedFile] :coffi.mem/int :coffi.mem/int [:coffi.mem/pointer [:coffi.mem/pointer :clang/CXTranslationUnitImpl]]], :symbol "clang_parseTranslationUnit2FullArgv", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_parseTranslationUnit2FullArgv, :raw-comment "/**\n * Same as clang_parseTranslationUnit2 but requires a full command line\n * for \\c command_line_args including argv[0]. This is useful if the standard\n * library paths are relative to the binary.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "TU", :type "struct CXTranslationUnitImpl *"}], :ret {:spelling "unsigned int"}, :function/args [[:coffi.mem/pointer :clang/CXTranslationUnitImpl]], :symbol "clang_defaultSaveOptions", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_defaultSaveOptions, :raw-comment "/**\n * Returns the set of flags that is suitable for saving a translation\n * unit.\n *\n * The set of flags returned provide options for\n * \\c clang_saveTranslationUnit() by default. The returned flag\n * set contains an unspecified set of options that save translation units with\n * the most commonly-requested data.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "TU", :type "struct CXTranslationUnitImpl *"} {:spelling "FileName", :type "const char *"} {:spelling "options", :type "unsigned int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clang/CXTranslationUnitImpl] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int], :symbol "clang_saveTranslationUnit", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_saveTranslationUnit, :raw-comment "/**\n * Saves a translation unit into a serialized representation of\n * that translation unit on disk.\n *\n * Any translation unit that was parsed without error can be saved\n * into a file. The translation unit can then be deserialized into a\n * new \\c CXTranslationUnit with \\c clang_createTranslationUnit() or,\n * if it is an incomplete translation unit that corresponds to a\n * header, used as a precompiled header when parsing other translation\n * units.\n *\n * \\param TU The translation unit to save.\n *\n * \\param FileName The file to which the translation unit will be saved.\n *\n * \\param options A bitmask of options that affects how the translation unit\n * is saved. This should be a bitwise OR of the\n * CXSaveTranslationUnit_XXX flags.\n *\n * \\returns A value that will match one of the enumerators of the CXSaveError\n * enumeration. Zero (CXSaveError_None) indicates that the translation unit was\n * saved successfully, while a non-zero value indicates that a problem occurred.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "", :type "struct CXTranslationUnitImpl *"}], :ret {:spelling "unsigned int"}, :function/args [[:coffi.mem/pointer :clang/CXTranslationUnitImpl]], :symbol "clang_suspendTranslationUnit", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_suspendTranslationUnit, :raw-comment "/**\n * Suspend a translation unit in order to free memory associated with it.\n *\n * A suspended translation unit uses significantly less memory but on the other\n * side does not support any other calls than \\c clang_reparseTranslationUnit\n * to resume it or \\c clang_disposeTranslationUnit to dispose it completely.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "", :type "struct CXTranslationUnitImpl *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clang/CXTranslationUnitImpl]], :symbol "clang_disposeTranslationUnit", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_disposeTranslationUnit, :raw-comment "/**\n * Destroy the specified CXTranslationUnit object.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "TU", :type "struct CXTranslationUnitImpl *"}], :ret {:spelling "unsigned int"}, :function/args [[:coffi.mem/pointer :clang/CXTranslationUnitImpl]], :symbol "clang_defaultReparseOptions", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_defaultReparseOptions, :raw-comment "/**\n * Returns the set of flags that is suitable for reparsing a translation\n * unit.\n *\n * The set of flags returned provide options for\n * \\c clang_reparseTranslationUnit() by default. The returned flag\n * set contains an unspecified set of optimizations geared toward common uses\n * of reparsing. The set of optimizations enabled may change from one version\n * to the next.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "TU", :type "struct CXTranslationUnitImpl *"} {:spelling "num_unsaved_files", :type "unsigned int"} {:spelling "unsaved_files", :type "struct CXUnsavedFile *"} {:spelling "options", :type "unsigned int"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clang/CXTranslationUnitImpl] :coffi.mem/int [:coffi.mem/pointer :clang/CXUnsavedFile] :coffi.mem/int], :symbol "clang_reparseTranslationUnit", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_reparseTranslationUnit, :raw-comment "/**\n * Reparse the source files that produced this translation unit.\n *\n * This routine can be used to re-parse the source files that originally\n * created the given translation unit, for example because those source files\n * have changed (either on disk or as passed via \\p unsaved_files). The\n * source code will be reparsed with the same command-line options as it\n * was originally parsed.\n *\n * Reparsing a translation unit invalidates all cursors and source locations\n * that refer into that translation unit. This makes reparsing a translation\n * unit semantically equivalent to destroying the translation unit and then\n * creating a new translation unit with the same command-line arguments.\n * However, it may be more efficient to reparse a translation\n * unit using this routine.\n *\n * \\param TU The translation unit whose contents will be re-parsed. The\n * translation unit must originally have been built with\n * \\c clang_createTranslationUnitFromSourceFile().\n *\n * \\param num_unsaved_files The number of unsaved file entries in \\p\n * unsaved_files.\n *\n * \\param unsaved_files The files that have not yet been saved to disk\n * but may be required for parsing, including the contents of\n * those files.  The contents and name of these files (as specified by\n * CXUnsavedFile) are copied when necessary, so the client only needs to\n * guarantee their validity until the call to this function returns.\n *\n * \\param options A bitset of options composed of the flags in CXReparse_Flags.\n * The function \\c clang_defaultReparseOptions() produces a default set of\n * options recommended for most uses, based on the translation unit.\n *\n * \\returns 0 if the sources could be reparsed.  A non-zero error code will be\n * returned if reparsing was impossible, such that the translation unit is\n * invalid. In such cases, the only valid call for \\c TU is\n * \\c clang_disposeTranslationUnit(TU).  The error codes returned by this\n * routine are described by the \\c CXErrorCode enum.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "kind", :type "enum CXTUResourceUsageKind"}], :ret {:spelling "const char *"}, :function/args [:coffi.mem/int], :symbol "clang_getTUResourceUsageName", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getTUResourceUsageName, :raw-comment "/**\n * Returns the human-readable null-terminated C string that represents\n *  the name of the memory category.  This string should never be freed.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "TU", :type "struct CXTranslationUnitImpl *"}], :ret {:spelling "struct CXTUResourceUsage"}, :function/args [[:coffi.mem/pointer :clang/CXTranslationUnitImpl]], :symbol "clang_getCXTUResourceUsage", :function/ret :clang/CXTUResourceUsage, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getCXTUResourceUsage, :raw-comment "/**\n * Return the memory usage of a translation unit.  This object\n *  should be released with clang_disposeCXTUResourceUsage().\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "usage", :type "struct CXTUResourceUsage"}], :ret {:spelling "void"}, :function/args [:clang/CXTUResourceUsage], :symbol "clang_disposeCXTUResourceUsage", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_disposeCXTUResourceUsage, :raw-comment nil, :kind "CXCursor_FunctionDecl"} {:args [{:spelling "CTUnit", :type "struct CXTranslationUnitImpl *"}], :ret {:spelling "struct CXTargetInfoImpl *"}, :function/args [[:coffi.mem/pointer :clang/CXTranslationUnitImpl]], :symbol "clang_getTranslationUnitTargetInfo", :function/ret [:coffi.mem/pointer :clang/CXTargetInfoImpl], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getTranslationUnitTargetInfo, :raw-comment "/**\n * Get target information for this translation unit.\n *\n * The CXTargetInfo object cannot outlive the CXTranslationUnit object.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "Info", :type "struct CXTargetInfoImpl *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clang/CXTargetInfoImpl]], :symbol "clang_TargetInfo_dispose", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_TargetInfo_dispose, :raw-comment "/**\n * Destroy the CXTargetInfo object.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "Info", :type "struct CXTargetInfoImpl *"}], :ret {:spelling "CXString"}, :function/args [[:coffi.mem/pointer :clang/CXTargetInfoImpl]], :symbol "clang_TargetInfo_getTriple", :function/ret :clang/CXString, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_TargetInfo_getTriple, :raw-comment "/**\n * Get the normalized target triple as a string.\n *\n * Returns the empty string in case of any error.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "Info", :type "struct CXTargetInfoImpl *"}], :ret {:spelling "int"}, :function/args [[:coffi.mem/pointer :clang/CXTargetInfoImpl]], :symbol "clang_TargetInfo_getPointerWidth", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_TargetInfo_getPointerWidth, :raw-comment "/**\n * Get the pointer width of the target in bits.\n *\n * Returns -1 in case of error.\n */", :kind "CXCursor_FunctionDecl"} {:args [], :ret {:spelling "CXCursor"}, :function/args [], :symbol "clang_getNullCursor", :function/ret :clang/CXCursor, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getNullCursor, :raw-comment "/**\n * Retrieve the NULL cursor, which represents no entity.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "", :type "struct CXTranslationUnitImpl *"}], :ret {:spelling "CXCursor"}, :function/args [[:coffi.mem/pointer :clang/CXTranslationUnitImpl]], :symbol "clang_getTranslationUnitCursor", :function/ret :clang/CXCursor, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getTranslationUnitCursor, :raw-comment "/**\n * Retrieve the cursor that represents the given translation unit.\n *\n * The translation unit cursor can be used to start traversing the\n * various declarations within the given translation unit.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "", :type "CXCursor"} {:spelling "", :type "CXCursor"}], :ret {:spelling "unsigned int"}, :function/args [:clang/CXCursor :clang/CXCursor], :symbol "clang_equalCursors", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_equalCursors, :raw-comment "/**\n * Determine whether two cursors are equivalent.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "cursor", :type "CXCursor"}], :ret {:spelling "int"}, :function/args [:clang/CXCursor], :symbol "clang_Cursor_isNull", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_Cursor_isNull, :raw-comment "/**\n * Returns non-zero if \\p cursor is null.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "", :type "CXCursor"}], :ret {:spelling "unsigned int"}, :function/args [:clang/CXCursor], :symbol "clang_hashCursor", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_hashCursor, :raw-comment "/**\n * Compute a hash value for the given cursor.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "", :type "CXCursor"}], :ret {:spelling "enum CXCursorKind"}, :function/args [:clang/CXCursor], :symbol "clang_getCursorKind", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getCursorKind, :raw-comment "/**\n * Retrieve the kind of the given cursor.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "", :type "enum CXCursorKind"}], :ret {:spelling "unsigned int"}, :function/args [:coffi.mem/int], :symbol "clang_isDeclaration", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_isDeclaration, :raw-comment "/**\n * Determine whether the given cursor kind represents a declaration.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "", :type "CXCursor"}], :ret {:spelling "unsigned int"}, :function/args [:clang/CXCursor], :symbol "clang_isInvalidDeclaration", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_isInvalidDeclaration, :raw-comment "/**\n * Determine whether the given declaration is invalid.\n *\n * A declaration is invalid if it could not be parsed successfully.\n *\n * \\returns non-zero if the cursor represents a declaration and it is\n * invalid, otherwise NULL.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "", :type "enum CXCursorKind"}], :ret {:spelling "unsigned int"}, :function/args [:coffi.mem/int], :symbol "clang_isReference", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_isReference, :raw-comment "/**\n * Determine whether the given cursor kind represents a simple\n * reference.\n *\n * Note that other kinds of cursors (such as expressions) can also refer to\n * other cursors. Use clang_getCursorReferenced() to determine whether a\n * particular cursor refers to another entity.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "", :type "enum CXCursorKind"}], :ret {:spelling "unsigned int"}, :function/args [:coffi.mem/int], :symbol "clang_isExpression", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_isExpression, :raw-comment "/**\n * Determine whether the given cursor kind represents an expression.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "", :type "enum CXCursorKind"}], :ret {:spelling "unsigned int"}, :function/args [:coffi.mem/int], :symbol "clang_isStatement", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_isStatement, :raw-comment "/**\n * Determine whether the given cursor kind represents a statement.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "", :type "enum CXCursorKind"}], :ret {:spelling "unsigned int"}, :function/args [:coffi.mem/int], :symbol "clang_isAttribute", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_isAttribute, :raw-comment "/**\n * Determine whether the given cursor kind represents an attribute.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "C", :type "CXCursor"}], :ret {:spelling "unsigned int"}, :function/args [:clang/CXCursor], :symbol "clang_Cursor_hasAttrs", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_Cursor_hasAttrs, :raw-comment "/**\n * Determine whether the given cursor has any attributes.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "", :type "enum CXCursorKind"}], :ret {:spelling "unsigned int"}, :function/args [:coffi.mem/int], :symbol "clang_isInvalid", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_isInvalid, :raw-comment "/**\n * Determine whether the given cursor kind represents an invalid\n * cursor.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "", :type "enum CXCursorKind"}], :ret {:spelling "unsigned int"}, :function/args [:coffi.mem/int], :symbol "clang_isTranslationUnit", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_isTranslationUnit, :raw-comment "/**\n * Determine whether the given cursor kind represents a translation\n * unit.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "", :type "enum CXCursorKind"}], :ret {:spelling "unsigned int"}, :function/args [:coffi.mem/int], :symbol "clang_isPreprocessing", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_isPreprocessing, :raw-comment "/***\n * Determine whether the given cursor represents a preprocessing\n * element, such as a preprocessor directive or macro instantiation.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "", :type "enum CXCursorKind"}], :ret {:spelling "unsigned int"}, :function/args [:coffi.mem/int], :symbol "clang_isUnexposed", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_isUnexposed, :raw-comment "/***\n * Determine whether the given cursor represents a currently\n *  unexposed piece of the AST (e.g., CXCursor_UnexposedStmt).\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "cursor", :type "CXCursor"}], :ret {:spelling "enum CXLinkageKind"}, :function/args [:clang/CXCursor], :symbol "clang_getCursorLinkage", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getCursorLinkage, :raw-comment "/**\n * Determine the linkage of the entity referred to by a given cursor.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "cursor", :type "CXCursor"}], :ret {:spelling "enum CXVisibilityKind"}, :function/args [:clang/CXCursor], :symbol "clang_getCursorVisibility", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getCursorVisibility, :raw-comment "/**\n * Describe the visibility of the entity referred to by a cursor.\n *\n * This returns the default visibility if not explicitly specified by\n * a visibility attribute. The default visibility may be changed by\n * commandline arguments.\n *\n * \\param cursor The cursor to query.\n *\n * \\returns The visibility of the cursor.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "cursor", :type "CXCursor"}], :ret {:spelling "enum CXAvailabilityKind"}, :function/args [:clang/CXCursor], :symbol "clang_getCursorAvailability", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getCursorAvailability, :raw-comment "/**\n * Determine the availability of the entity that this cursor refers to,\n * taking the current target platform into account.\n *\n * \\param cursor The cursor to query.\n *\n * \\returns The availability of the cursor.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "cursor", :type "CXCursor"} {:spelling "always_deprecated", :type "int *"} {:spelling "deprecated_message", :type "CXString *"} {:spelling "always_unavailable", :type "int *"} {:spelling "unavailable_message", :type "CXString *"} {:spelling "availability", :type "struct CXPlatformAvailability *"} {:spelling "availability_size", :type "int"}], :ret {:spelling "int"}, :function/args [:clang/CXCursor [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :clang/CXString] [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :clang/CXString] [:coffi.mem/pointer :clang/CXPlatformAvailability] :coffi.mem/int], :symbol "clang_getCursorPlatformAvailability", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getCursorPlatformAvailability, :raw-comment "/**\n * Determine the availability of the entity that this cursor refers to\n * on any platforms for which availability information is known.\n *\n * \\param cursor The cursor to query.\n *\n * \\param always_deprecated If non-NULL, will be set to indicate whether the\n * entity is deprecated on all platforms.\n *\n * \\param deprecated_message If non-NULL, will be set to the message text\n * provided along with the unconditional deprecation of this entity. The client\n * is responsible for deallocating this string.\n *\n * \\param always_unavailable If non-NULL, will be set to indicate whether the\n * entity is unavailable on all platforms.\n *\n * \\param unavailable_message If non-NULL, will be set to the message text\n * provided along with the unconditional unavailability of this entity. The\n * client is responsible for deallocating this string.\n *\n * \\param availability If non-NULL, an array of CXPlatformAvailability instances\n * that will be populated with platform availability information, up to either\n * the number of platforms for which availability information is available (as\n * returned by this function) or \\c availability_size, whichever is smaller.\n *\n * \\param availability_size The number of elements available in the\n * \\c availability array.\n *\n * \\returns The number of platforms (N) for which availability information is\n * available (which is unrelated to \\c availability_size).\n *\n * Note that the client is responsible for calling\n * \\c clang_disposeCXPlatformAvailability to free each of the\n * platform-availability structures returned. There are\n * \\c min(N, availability_size) such structures.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "availability", :type "struct CXPlatformAvailability *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clang/CXPlatformAvailability]], :symbol "clang_disposeCXPlatformAvailability", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_disposeCXPlatformAvailability, :raw-comment "/**\n * Free the memory associated with a \\c CXPlatformAvailability structure.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "cursor", :type "CXCursor"}], :ret {:spelling "CXCursor"}, :function/args [:clang/CXCursor], :symbol "clang_Cursor_getVarDeclInitializer", :function/ret :clang/CXCursor, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_Cursor_getVarDeclInitializer, :raw-comment "/**\n * If cursor refers to a variable declaration and it has initializer returns\n * cursor referring to the initializer otherwise return null cursor.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "cursor", :type "CXCursor"}], :ret {:spelling "int"}, :function/args [:clang/CXCursor], :symbol "clang_Cursor_hasVarDeclGlobalStorage", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_Cursor_hasVarDeclGlobalStorage, :raw-comment "/**\n * If cursor refers to a variable declaration that has global storage returns 1.\n * If cursor refers to a variable declaration that doesn't have global storage\n * returns 0. Otherwise returns -1.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "cursor", :type "CXCursor"}], :ret {:spelling "int"}, :function/args [:clang/CXCursor], :symbol "clang_Cursor_hasVarDeclExternalStorage", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_Cursor_hasVarDeclExternalStorage, :raw-comment "/**\n * If cursor refers to a variable declaration that has external storage\n * returns 1. If cursor refers to a variable declaration that doesn't have\n * external storage returns 0. Otherwise returns -1.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "cursor", :type "CXCursor"}], :ret {:spelling "enum CXLanguageKind"}, :function/args [:clang/CXCursor], :symbol "clang_getCursorLanguage", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getCursorLanguage, :raw-comment "/**\n * Determine the \"language\" of the entity referred to by a given cursor.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "cursor", :type "CXCursor"}], :ret {:spelling "enum CXTLSKind"}, :function/args [:clang/CXCursor], :symbol "clang_getCursorTLSKind", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getCursorTLSKind, :raw-comment "/**\n * Determine the \"thread-local storage (TLS) kind\" of the declaration\n * referred to by a cursor.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "", :type "CXCursor"}], :ret {:spelling "struct CXTranslationUnitImpl *"}, :function/args [:clang/CXCursor], :symbol "clang_Cursor_getTranslationUnit", :function/ret [:coffi.mem/pointer :clang/CXTranslationUnitImpl], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_Cursor_getTranslationUnit, :raw-comment "/**\n * Returns the translation unit that a cursor originated from.\n */", :kind "CXCursor_FunctionDecl"} {:args [], :ret {:spelling "struct CXCursorSetImpl *"}, :function/args [], :symbol "clang_createCXCursorSet", :function/ret [:coffi.mem/pointer :clang/CXCursorSetImpl], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_createCXCursorSet, :raw-comment "/**\n * Creates an empty CXCursorSet.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "cset", :type "struct CXCursorSetImpl *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clang/CXCursorSetImpl]], :symbol "clang_disposeCXCursorSet", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_disposeCXCursorSet, :raw-comment "/**\n * Disposes a CXCursorSet and releases its associated memory.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "cset", :type "struct CXCursorSetImpl *"} {:spelling "cursor", :type "CXCursor"}], :ret {:spelling "unsigned int"}, :function/args [[:coffi.mem/pointer :clang/CXCursorSetImpl] :clang/CXCursor], :symbol "clang_CXCursorSet_contains", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_CXCursorSet_contains, :raw-comment "/**\n * Queries a CXCursorSet to see if it contains a specific CXCursor.\n *\n * \\returns non-zero if the set contains the specified cursor.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "cset", :type "struct CXCursorSetImpl *"} {:spelling "cursor", :type "CXCursor"}], :ret {:spelling "unsigned int"}, :function/args [[:coffi.mem/pointer :clang/CXCursorSetImpl] :clang/CXCursor], :symbol "clang_CXCursorSet_insert", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_CXCursorSet_insert, :raw-comment "/**\n * Inserts a CXCursor into a CXCursorSet.\n *\n * \\returns zero if the CXCursor was already in the set, and non-zero otherwise.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "cursor", :type "CXCursor"}], :ret {:spelling "CXCursor"}, :function/args [:clang/CXCursor], :symbol "clang_getCursorSemanticParent", :function/ret :clang/CXCursor, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getCursorSemanticParent, :raw-comment "/**\n * Determine the semantic parent of the given cursor.\n *\n * The semantic parent of a cursor is the cursor that semantically contains\n * the given \\p cursor. For many declarations, the lexical and semantic parents\n * are equivalent (the lexical parent is returned by\n * \\c clang_getCursorLexicalParent()). They diverge when declarations or\n * definitions are provided out-of-line. For example:\n *\n * \\code\n * class C {\n *  void f();\n * };\n *\n * void C::f() { }\n * \\endcode\n *\n * In the out-of-line definition of \\c C::f, the semantic parent is\n * the class \\c C, of which this function is a member. The lexical parent is\n * the place where the declaration actually occurs in the source code; in this\n * case, the definition occurs in the translation unit. In general, the\n * lexical parent for a given entity can change without affecting the semantics\n * of the program, and the lexical parent of different declarations of the\n * same entity may be different. Changing the semantic parent of a declaration,\n * on the other hand, can have a major impact on semantics, and redeclarations\n * of a particular entity should all have the same semantic context.\n *\n * In the example above, both declarations of \\c C::f have \\c C as their\n * semantic context, while the lexical context of the first \\c C::f is \\c C\n * and the lexical context of the second \\c C::f is the translation unit.\n *\n * For global declarations, the semantic parent is the translation unit.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "cursor", :type "CXCursor"}], :ret {:spelling "CXCursor"}, :function/args [:clang/CXCursor], :symbol "clang_getCursorLexicalParent", :function/ret :clang/CXCursor, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getCursorLexicalParent, :raw-comment "/**\n * Determine the lexical parent of the given cursor.\n *\n * The lexical parent of a cursor is the cursor in which the given \\p cursor\n * was actually written. For many declarations, the lexical and semantic parents\n * are equivalent (the semantic parent is returned by\n * \\c clang_getCursorSemanticParent()). They diverge when declarations or\n * definitions are provided out-of-line. For example:\n *\n * \\code\n * class C {\n *  void f();\n * };\n *\n * void C::f() { }\n * \\endcode\n *\n * In the out-of-line definition of \\c C::f, the semantic parent is\n * the class \\c C, of which this function is a member. The lexical parent is\n * the place where the declaration actually occurs in the source code; in this\n * case, the definition occurs in the translation unit. In general, the\n * lexical parent for a given entity can change without affecting the semantics\n * of the program, and the lexical parent of different declarations of the\n * same entity may be different. Changing the semantic parent of a declaration,\n * on the other hand, can have a major impact on semantics, and redeclarations\n * of a particular entity should all have the same semantic context.\n *\n * In the example above, both declarations of \\c C::f have \\c C as their\n * semantic context, while the lexical context of the first \\c C::f is \\c C\n * and the lexical context of the second \\c C::f is the translation unit.\n *\n * For declarations written in the global scope, the lexical parent is\n * the translation unit.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "cursor", :type "CXCursor"} {:spelling "overridden", :type "CXCursor **"} {:spelling "num_overridden", :type "unsigned int *"}], :ret {:spelling "void"}, :function/args [:clang/CXCursor [:coffi.mem/pointer [:coffi.mem/pointer :clang/CXCursor]] [:coffi.mem/pointer :coffi.mem/int]], :symbol "clang_getOverriddenCursors", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getOverriddenCursors, :raw-comment "/**\n * Determine the set of methods that are overridden by the given\n * method.\n *\n * In both Objective-C and C++, a method (aka virtual member function,\n * in C++) can override a virtual method in a base class. For\n * Objective-C, a method is said to override any method in the class's\n * base class, its protocols, or its categories' protocols, that has the same\n * selector and is of the same kind (class or instance).\n * If no such method exists, the search continues to the class's superclass,\n * its protocols, and its categories, and so on. A method from an Objective-C\n * implementation is considered to override the same methods as its\n * corresponding method in the interface.\n *\n * For C++, a virtual member function overrides any virtual member\n * function with the same signature that occurs in its base\n * classes. With multiple inheritance, a virtual member function can\n * override several virtual member functions coming from different\n * base classes.\n *\n * In all cases, this function determines the immediate overridden\n * method, rather than all of the overridden methods. For example, if\n * a method is originally declared in a class A, then overridden in B\n * (which in inherits from A) and also in C (which inherited from B),\n * then the only overridden method returned from this function when\n * invoked on C's method will be B's method. The client may then\n * invoke this function again, given the previously-found overridden\n * methods, to map out the complete method-override set.\n *\n * \\param cursor A cursor representing an Objective-C or C++\n * method. This routine will compute the set of methods that this\n * method overrides.\n *\n * \\param overridden A pointer whose pointee will be replaced with a\n * pointer to an array of cursors, representing the set of overridden\n * methods. If there are no overridden methods, the pointee will be\n * set to NULL. The pointee must be freed via a call to\n * \\c clang_disposeOverriddenCursors().\n *\n * \\param num_overridden A pointer to the number of overridden\n * functions, will be set to the number of overridden functions in the\n * array pointed to by \\p overridden.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "overridden", :type "CXCursor *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clang/CXCursor]], :symbol "clang_disposeOverriddenCursors", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_disposeOverriddenCursors, :raw-comment "/**\n * Free the set of overridden cursors returned by \\c\n * clang_getOverriddenCursors().\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "cursor", :type "CXCursor"}], :ret {:spelling "void *"}, :function/args [:clang/CXCursor], :symbol "clang_getIncludedFile", :function/ret :coffi.mem/pointer, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getIncludedFile, :raw-comment "/**\n * Retrieve the file that is included by the given inclusion directive\n * cursor.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "", :type "struct CXTranslationUnitImpl *"} {:spelling "", :type "CXSourceLocation"}], :ret {:spelling "CXCursor"}, :function/args [[:coffi.mem/pointer :clang/CXTranslationUnitImpl] :clang/CXSourceLocation], :symbol "clang_getCursor", :function/ret :clang/CXCursor, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getCursor, :raw-comment "/**\n * Map a source location to the cursor that describes the entity at that\n * location in the source code.\n *\n * clang_getCursor() maps an arbitrary source location within a translation\n * unit down to the most specific cursor that describes the entity at that\n * location. For example, given an expression \\c x + y, invoking\n * clang_getCursor() with a source location pointing to \"x\" will return the\n * cursor for \"x\"; similarly for \"y\". If the cursor points anywhere between\n * \"x\" or \"y\" (e.g., on the + or the whitespace around it), clang_getCursor()\n * will return a cursor referring to the \"+\" expression.\n *\n * \\returns a cursor representing the entity at the given source location, or\n * a NULL cursor if no such entity can be found.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "", :type "CXCursor"}], :ret {:spelling "CXSourceLocation"}, :function/args [:clang/CXCursor], :symbol "clang_getCursorLocation", :function/ret :clang/CXSourceLocation, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getCursorLocation, :raw-comment "/**\n * Retrieve the physical location of the source constructor referenced\n * by the given cursor.\n *\n * The location of a declaration is typically the location of the name of that\n * declaration, where the name of that declaration would occur if it is\n * unnamed, or some keyword that introduces that particular declaration.\n * The location of a reference is where that reference occurs within the\n * source code.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "", :type "CXCursor"}], :ret {:spelling "CXSourceRange"}, :function/args [:clang/CXCursor], :symbol "clang_getCursorExtent", :function/ret :clang/CXSourceRange, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getCursorExtent, :raw-comment "/**\n * Retrieve the physical extent of the source construct referenced by\n * the given cursor.\n *\n * The extent of a cursor starts with the file/line/column pointing at the\n * first character within the source construct that the cursor refers to and\n * ends with the last character within that source construct. For a\n * declaration, the extent covers the declaration itself. For a reference,\n * the extent covers the location of the reference (e.g., where the referenced\n * entity was actually used).\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "C", :type "CXCursor"}], :ret {:spelling "CXType"}, :function/args [:clang/CXCursor], :symbol "clang_getCursorType", :function/ret :clang/CXType, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getCursorType, :raw-comment "/**\n * Retrieve the type of a CXCursor (if any).\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "CT", :type "CXType"}], :ret {:spelling "CXString"}, :function/args [:clang/CXType], :symbol "clang_getTypeSpelling", :function/ret :clang/CXString, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getTypeSpelling, :raw-comment "/**\n * Pretty-print the underlying type using the rules of the\n * language of the translation unit from which it came.\n *\n * If the type is invalid, an empty string is returned.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "C", :type "CXCursor"}], :ret {:spelling "CXType"}, :function/args [:clang/CXCursor], :symbol "clang_getTypedefDeclUnderlyingType", :function/ret :clang/CXType, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getTypedefDeclUnderlyingType, :raw-comment "/**\n * Retrieve the underlying type of a typedef declaration.\n *\n * If the cursor does not reference a typedef declaration, an invalid type is\n * returned.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "C", :type "CXCursor"}], :ret {:spelling "CXType"}, :function/args [:clang/CXCursor], :symbol "clang_getEnumDeclIntegerType", :function/ret :clang/CXType, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getEnumDeclIntegerType, :raw-comment "/**\n * Retrieve the integer type of an enum declaration.\n *\n * If the cursor does not reference an enum declaration, an invalid type is\n * returned.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "C", :type "CXCursor"}], :ret {:spelling "long long"}, :function/args [:clang/CXCursor], :symbol "clang_getEnumConstantDeclValue", :function/ret :coffi.mem/long, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getEnumConstantDeclValue, :raw-comment "/**\n * Retrieve the integer value of an enum constant declaration as a signed\n *  long long.\n *\n * If the cursor does not reference an enum constant declaration, LLONG_MIN is\n * returned. Since this is also potentially a valid constant value, the kind of\n * the cursor must be verified before calling this function.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "C", :type "CXCursor"}], :ret {:spelling "unsigned long long"}, :function/args [:clang/CXCursor], :symbol "clang_getEnumConstantDeclUnsignedValue", :function/ret :coffi.mem/long, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getEnumConstantDeclUnsignedValue, :raw-comment "/**\n * Retrieve the integer value of an enum constant declaration as an unsigned\n *  long long.\n *\n * If the cursor does not reference an enum constant declaration, ULLONG_MAX is\n * returned. Since this is also potentially a valid constant value, the kind of\n * the cursor must be verified before calling this function.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "C", :type "CXCursor"}], :ret {:spelling "int"}, :function/args [:clang/CXCursor], :symbol "clang_getFieldDeclBitWidth", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getFieldDeclBitWidth, :raw-comment "/**\n * Retrieve the bit width of a bit field declaration as an integer.\n *\n * If a cursor that is not a bit field declaration is passed in, -1 is returned.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "C", :type "CXCursor"}], :ret {:spelling "int"}, :function/args [:clang/CXCursor], :symbol "clang_Cursor_getNumArguments", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_Cursor_getNumArguments, :raw-comment "/**\n * Retrieve the number of non-variadic arguments associated with a given\n * cursor.\n *\n * The number of arguments can be determined for calls as well as for\n * declarations of functions or methods. For other cursors -1 is returned.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "C", :type "CXCursor"} {:spelling "i", :type "unsigned int"}], :ret {:spelling "CXCursor"}, :function/args [:clang/CXCursor :coffi.mem/int], :symbol "clang_Cursor_getArgument", :function/ret :clang/CXCursor, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_Cursor_getArgument, :raw-comment "/**\n * Retrieve the argument cursor of a function or method.\n *\n * The argument cursor can be determined for calls as well as for declarations\n * of functions or methods. For other cursors and for invalid indices, an\n * invalid cursor is returned.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "C", :type "CXCursor"}], :ret {:spelling "int"}, :function/args [:clang/CXCursor], :symbol "clang_Cursor_getNumTemplateArguments", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_Cursor_getNumTemplateArguments, :raw-comment "/**\n *Returns the number of template args of a function decl representing a\n * template specialization.\n *\n * If the argument cursor cannot be converted into a template function\n * declaration, -1 is returned.\n *\n * For example, for the following declaration and specialization:\n *   template <typename T, int kInt, bool kBool>\n *   void foo() { ... }\n *\n *   template <>\n *   void foo<float, -7, true>();\n *\n * The value 3 would be returned from this call.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "C", :type "CXCursor"} {:spelling "I", :type "unsigned int"}], :ret {:spelling "enum CXTemplateArgumentKind"}, :function/args [:clang/CXCursor :coffi.mem/int], :symbol "clang_Cursor_getTemplateArgumentKind", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_Cursor_getTemplateArgumentKind, :raw-comment "/**\n * Retrieve the kind of the I'th template argument of the CXCursor C.\n *\n * If the argument CXCursor does not represent a FunctionDecl, an invalid\n * template argument kind is returned.\n *\n * For example, for the following declaration and specialization:\n *   template <typename T, int kInt, bool kBool>\n *   void foo() { ... }\n *\n *   template <>\n *   void foo<float, -7, true>();\n *\n * For I = 0, 1, and 2, Type, Integral, and Integral will be returned,\n * respectively.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "C", :type "CXCursor"} {:spelling "I", :type "unsigned int"}], :ret {:spelling "CXType"}, :function/args [:clang/CXCursor :coffi.mem/int], :symbol "clang_Cursor_getTemplateArgumentType", :function/ret :clang/CXType, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_Cursor_getTemplateArgumentType, :raw-comment "/**\n * Retrieve a CXType representing the type of a TemplateArgument of a\n *  function decl representing a template specialization.\n *\n * If the argument CXCursor does not represent a FunctionDecl whose I'th\n * template argument has a kind of CXTemplateArgKind_Integral, an invalid type\n * is returned.\n *\n * For example, for the following declaration and specialization:\n *   template <typename T, int kInt, bool kBool>\n *   void foo() { ... }\n *\n *   template <>\n *   void foo<float, -7, true>();\n *\n * If called with I = 0, \"float\", will be returned.\n * Invalid types will be returned for I == 1 or 2.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "C", :type "CXCursor"} {:spelling "I", :type "unsigned int"}], :ret {:spelling "long long"}, :function/args [:clang/CXCursor :coffi.mem/int], :symbol "clang_Cursor_getTemplateArgumentValue", :function/ret :coffi.mem/long, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_Cursor_getTemplateArgumentValue, :raw-comment "/**\n * Retrieve the value of an Integral TemplateArgument (of a function\n *  decl representing a template specialization) as a signed long long.\n *\n * It is undefined to call this function on a CXCursor that does not represent a\n * FunctionDecl or whose I'th template argument is not an integral value.\n *\n * For example, for the following declaration and specialization:\n *   template <typename T, int kInt, bool kBool>\n *   void foo() { ... }\n *\n *   template <>\n *   void foo<float, -7, true>();\n *\n * If called with I = 1 or 2, -7 or true will be returned, respectively.\n * For I == 0, this function's behavior is undefined.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "C", :type "CXCursor"} {:spelling "I", :type "unsigned int"}], :ret {:spelling "unsigned long long"}, :function/args [:clang/CXCursor :coffi.mem/int], :symbol "clang_Cursor_getTemplateArgumentUnsignedValue", :function/ret :coffi.mem/long, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_Cursor_getTemplateArgumentUnsignedValue, :raw-comment "/**\n * Retrieve the value of an Integral TemplateArgument (of a function\n *  decl representing a template specialization) as an unsigned long long.\n *\n * It is undefined to call this function on a CXCursor that does not represent a\n * FunctionDecl or whose I'th template argument is not an integral value.\n *\n * For example, for the following declaration and specialization:\n *   template <typename T, int kInt, bool kBool>\n *   void foo() { ... }\n *\n *   template <>\n *   void foo<float, 2147483649, true>();\n *\n * If called with I = 1 or 2, 2147483649 or true will be returned, respectively.\n * For I == 0, this function's behavior is undefined.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "A", :type "CXType"} {:spelling "B", :type "CXType"}], :ret {:spelling "unsigned int"}, :function/args [:clang/CXType :clang/CXType], :symbol "clang_equalTypes", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_equalTypes, :raw-comment "/**\n * Determine whether two CXTypes represent the same type.\n *\n * \\returns non-zero if the CXTypes represent the same type and\n *          zero otherwise.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "T", :type "CXType"}], :ret {:spelling "CXType"}, :function/args [:clang/CXType], :symbol "clang_getCanonicalType", :function/ret :clang/CXType, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getCanonicalType, :raw-comment "/**\n * Return the canonical type for a CXType.\n *\n * Clang's type system explicitly models typedefs and all the ways\n * a specific type can be represented.  The canonical type is the underlying\n * type with all the \"sugar\" removed.  For example, if 'T' is a typedef\n * for 'int', the canonical type for 'T' would be 'int'.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "T", :type "CXType"}], :ret {:spelling "unsigned int"}, :function/args [:clang/CXType], :symbol "clang_isConstQualifiedType", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_isConstQualifiedType, :raw-comment "/**\n * Determine whether a CXType has the \"const\" qualifier set,\n * without looking through typedefs that may have added \"const\" at a\n * different level.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "C", :type "CXCursor"}], :ret {:spelling "unsigned int"}, :function/args [:clang/CXCursor], :symbol "clang_Cursor_isMacroFunctionLike", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_Cursor_isMacroFunctionLike, :raw-comment "/**\n * Determine whether a  CXCursor that is a macro, is\n * function like.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "C", :type "CXCursor"}], :ret {:spelling "unsigned int"}, :function/args [:clang/CXCursor], :symbol "clang_Cursor_isMacroBuiltin", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_Cursor_isMacroBuiltin, :raw-comment "/**\n * Determine whether a  CXCursor that is a macro, is a\n * builtin one.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "C", :type "CXCursor"}], :ret {:spelling "unsigned int"}, :function/args [:clang/CXCursor], :symbol "clang_Cursor_isFunctionInlined", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_Cursor_isFunctionInlined, :raw-comment "/**\n * Determine whether a  CXCursor that is a function declaration, is an\n * inline declaration.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "T", :type "CXType"}], :ret {:spelling "unsigned int"}, :function/args [:clang/CXType], :symbol "clang_isVolatileQualifiedType", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_isVolatileQualifiedType, :raw-comment "/**\n * Determine whether a CXType has the \"volatile\" qualifier set,\n * without looking through typedefs that may have added \"volatile\" at\n * a different level.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "T", :type "CXType"}], :ret {:spelling "unsigned int"}, :function/args [:clang/CXType], :symbol "clang_isRestrictQualifiedType", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_isRestrictQualifiedType, :raw-comment "/**\n * Determine whether a CXType has the \"restrict\" qualifier set,\n * without looking through typedefs that may have added \"restrict\" at a\n * different level.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "T", :type "CXType"}], :ret {:spelling "unsigned int"}, :function/args [:clang/CXType], :symbol "clang_getAddressSpace", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getAddressSpace, :raw-comment "/**\n * Returns the address space of the given type.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "CT", :type "CXType"}], :ret {:spelling "CXString"}, :function/args [:clang/CXType], :symbol "clang_getTypedefName", :function/ret :clang/CXString, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getTypedefName, :raw-comment "/**\n * Returns the typedef name of the given type.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "T", :type "CXType"}], :ret {:spelling "CXType"}, :function/args [:clang/CXType], :symbol "clang_getPointeeType", :function/ret :clang/CXType, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getPointeeType, :raw-comment "/**\n * For pointer types, returns the type of the pointee.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "T", :type "CXType"}], :ret {:spelling "CXCursor"}, :function/args [:clang/CXType], :symbol "clang_getTypeDeclaration", :function/ret :clang/CXCursor, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getTypeDeclaration, :raw-comment "/**\n * Return the cursor for the declaration of the given type.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "C", :type "CXCursor"}], :ret {:spelling "CXString"}, :function/args [:clang/CXCursor], :symbol "clang_getDeclObjCTypeEncoding", :function/ret :clang/CXString, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getDeclObjCTypeEncoding, :raw-comment "/**\n * Returns the Objective-C type encoding for the specified declaration.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "type", :type "CXType"}], :ret {:spelling "CXString"}, :function/args [:clang/CXType], :symbol "clang_Type_getObjCEncoding", :function/ret :clang/CXString, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_Type_getObjCEncoding, :raw-comment "/**\n * Returns the Objective-C type encoding for the specified CXType.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "K", :type "enum CXTypeKind"}], :ret {:spelling "CXString"}, :function/args [:coffi.mem/int], :symbol "clang_getTypeKindSpelling", :function/ret :clang/CXString, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getTypeKindSpelling, :raw-comment "/**\n * Retrieve the spelling of a given CXTypeKind.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "T", :type "CXType"}], :ret {:spelling "enum CXCallingConv"}, :function/args [:clang/CXType], :symbol "clang_getFunctionTypeCallingConv", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getFunctionTypeCallingConv, :raw-comment "/**\n * Retrieve the calling convention associated with a function type.\n *\n * If a non-function type is passed in, CXCallingConv_Invalid is returned.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "T", :type "CXType"}], :ret {:spelling "CXType"}, :function/args [:clang/CXType], :symbol "clang_getResultType", :function/ret :clang/CXType, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getResultType, :raw-comment "/**\n * Retrieve the return type associated with a function type.\n *\n * If a non-function type is passed in, an invalid type is returned.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "T", :type "CXType"}], :ret {:spelling "int"}, :function/args [:clang/CXType], :symbol "clang_getExceptionSpecificationType", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getExceptionSpecificationType, :raw-comment "/**\n * Retrieve the exception specification type associated with a function type.\n * This is a value of type CXCursor_ExceptionSpecificationKind.\n *\n * If a non-function type is passed in, an error code of -1 is returned.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "T", :type "CXType"}], :ret {:spelling "int"}, :function/args [:clang/CXType], :symbol "clang_getNumArgTypes", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getNumArgTypes, :raw-comment "/**\n * Retrieve the number of non-variadic parameters associated with a\n * function type.\n *\n * If a non-function type is passed in, -1 is returned.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "T", :type "CXType"} {:spelling "i", :type "unsigned int"}], :ret {:spelling "CXType"}, :function/args [:clang/CXType :coffi.mem/int], :symbol "clang_getArgType", :function/ret :clang/CXType, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getArgType, :raw-comment "/**\n * Retrieve the type of a parameter of a function type.\n *\n * If a non-function type is passed in or the function does not have enough\n * parameters, an invalid type is returned.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "T", :type "CXType"}], :ret {:spelling "CXType"}, :function/args [:clang/CXType], :symbol "clang_Type_getObjCObjectBaseType", :function/ret :clang/CXType, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_Type_getObjCObjectBaseType, :raw-comment "/**\n * Retrieves the base type of the ObjCObjectType.\n *\n * If the type is not an ObjC object, an invalid type is returned.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "T", :type "CXType"}], :ret {:spelling "unsigned int"}, :function/args [:clang/CXType], :symbol "clang_Type_getNumObjCProtocolRefs", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_Type_getNumObjCProtocolRefs, :raw-comment "/**\n * Retrieve the number of protocol references associated with an ObjC object/id.\n *\n * If the type is not an ObjC object, 0 is returned.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "T", :type "CXType"} {:spelling "i", :type "unsigned int"}], :ret {:spelling "CXCursor"}, :function/args [:clang/CXType :coffi.mem/int], :symbol "clang_Type_getObjCProtocolDecl", :function/ret :clang/CXCursor, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_Type_getObjCProtocolDecl, :raw-comment "/**\n * Retrieve the decl for a protocol reference for an ObjC object/id.\n *\n * If the type is not an ObjC object or there are not enough protocol\n * references, an invalid cursor is returned.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "T", :type "CXType"}], :ret {:spelling "unsigned int"}, :function/args [:clang/CXType], :symbol "clang_Type_getNumObjCTypeArgs", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_Type_getNumObjCTypeArgs, :raw-comment "/**\n * Retrieve the number of type arguments associated with an ObjC object.\n *\n * If the type is not an ObjC object, 0 is returned.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "T", :type "CXType"} {:spelling "i", :type "unsigned int"}], :ret {:spelling "CXType"}, :function/args [:clang/CXType :coffi.mem/int], :symbol "clang_Type_getObjCTypeArg", :function/ret :clang/CXType, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_Type_getObjCTypeArg, :raw-comment "/**\n * Retrieve a type argument associated with an ObjC object.\n *\n * If the type is not an ObjC or the index is not valid,\n * an invalid type is returned.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "T", :type "CXType"}], :ret {:spelling "unsigned int"}, :function/args [:clang/CXType], :symbol "clang_isFunctionTypeVariadic", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_isFunctionTypeVariadic, :raw-comment "/**\n * Return 1 if the CXType is a variadic function type, and 0 otherwise.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "C", :type "CXCursor"}], :ret {:spelling "CXType"}, :function/args [:clang/CXCursor], :symbol "clang_getCursorResultType", :function/ret :clang/CXType, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getCursorResultType, :raw-comment "/**\n * Retrieve the return type associated with a given cursor.\n *\n * This only returns a valid type if the cursor refers to a function or method.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "C", :type "CXCursor"}], :ret {:spelling "int"}, :function/args [:clang/CXCursor], :symbol "clang_getCursorExceptionSpecificationType", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getCursorExceptionSpecificationType, :raw-comment "/**\n * Retrieve the exception specification type associated with a given cursor.\n * This is a value of type CXCursor_ExceptionSpecificationKind.\n *\n * This only returns a valid result if the cursor refers to a function or\n * method.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "T", :type "CXType"}], :ret {:spelling "unsigned int"}, :function/args [:clang/CXType], :symbol "clang_isPODType", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_isPODType, :raw-comment "/**\n * Return 1 if the CXType is a POD (plain old data) type, and 0\n *  otherwise.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "T", :type "CXType"}], :ret {:spelling "CXType"}, :function/args [:clang/CXType], :symbol "clang_getElementType", :function/ret :clang/CXType, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getElementType, :raw-comment "/**\n * Return the element type of an array, complex, or vector type.\n *\n * If a type is passed in that is not an array, complex, or vector type,\n * an invalid type is returned.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "T", :type "CXType"}], :ret {:spelling "long long"}, :function/args [:clang/CXType], :symbol "clang_getNumElements", :function/ret :coffi.mem/long, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getNumElements, :raw-comment "/**\n * Return the number of elements of an array or vector type.\n *\n * If a type is passed in that is not an array or vector type,\n * -1 is returned.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "T", :type "CXType"}], :ret {:spelling "CXType"}, :function/args [:clang/CXType], :symbol "clang_getArrayElementType", :function/ret :clang/CXType, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getArrayElementType, :raw-comment "/**\n * Return the element type of an array type.\n *\n * If a non-array type is passed in, an invalid type is returned.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "T", :type "CXType"}], :ret {:spelling "long long"}, :function/args [:clang/CXType], :symbol "clang_getArraySize", :function/ret :coffi.mem/long, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getArraySize, :raw-comment "/**\n * Return the array size of a constant array.\n *\n * If a non-array type is passed in, -1 is returned.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "T", :type "CXType"}], :ret {:spelling "CXType"}, :function/args [:clang/CXType], :symbol "clang_Type_getNamedType", :function/ret :clang/CXType, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_Type_getNamedType, :raw-comment "/**\n * Retrieve the type named by the qualified-id.\n *\n * If a non-elaborated type is passed in, an invalid type is returned.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "T", :type "CXType"}], :ret {:spelling "unsigned int"}, :function/args [:clang/CXType], :symbol "clang_Type_isTransparentTagTypedef", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_Type_isTransparentTagTypedef, :raw-comment "/**\n * Determine if a typedef is 'transparent' tag.\n *\n * A typedef is considered 'transparent' if it shares a name and spelling\n * location with its underlying tag type, as is the case with the NS_ENUM macro.\n *\n * \\returns non-zero if transparent and zero otherwise.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "T", :type "CXType"}], :ret {:spelling "enum CXTypeNullabilityKind"}, :function/args [:clang/CXType], :symbol "clang_Type_getNullability", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_Type_getNullability, :raw-comment "/**\n * Retrieve the nullability kind of a pointer type.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "T", :type "CXType"}], :ret {:spelling "long long"}, :function/args [:clang/CXType], :symbol "clang_Type_getAlignOf", :function/ret :coffi.mem/long, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_Type_getAlignOf, :raw-comment "/**\n * Return the alignment of a type in bytes as per C++[expr.alignof]\n *   standard.\n *\n * If the type declaration is invalid, CXTypeLayoutError_Invalid is returned.\n * If the type declaration is an incomplete type, CXTypeLayoutError_Incomplete\n *   is returned.\n * If the type declaration is a dependent type, CXTypeLayoutError_Dependent is\n *   returned.\n * If the type declaration is not a constant size type,\n *   CXTypeLayoutError_NotConstantSize is returned.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "T", :type "CXType"}], :ret {:spelling "CXType"}, :function/args [:clang/CXType], :symbol "clang_Type_getClassType", :function/ret :clang/CXType, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_Type_getClassType, :raw-comment "/**\n * Return the class type of an member pointer type.\n *\n * If a non-member-pointer type is passed in, an invalid type is returned.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "T", :type "CXType"}], :ret {:spelling "long long"}, :function/args [:clang/CXType], :symbol "clang_Type_getSizeOf", :function/ret :coffi.mem/long, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_Type_getSizeOf, :raw-comment "/**\n * Return the size of a type in bytes as per C++[expr.sizeof] standard.\n *\n * If the type declaration is invalid, CXTypeLayoutError_Invalid is returned.\n * If the type declaration is an incomplete type, CXTypeLayoutError_Incomplete\n *   is returned.\n * If the type declaration is a dependent type, CXTypeLayoutError_Dependent is\n *   returned.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "T", :type "CXType"} {:spelling "S", :type "const char *"}], :ret {:spelling "long long"}, :function/args [:clang/CXType [:coffi.mem/pointer :coffi.mem/char]], :symbol "clang_Type_getOffsetOf", :function/ret :coffi.mem/long, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_Type_getOffsetOf, :raw-comment "/**\n * Return the offset of a field named S in a record of type T in bits\n *   as it would be returned by __offsetof__ as per C++11[18.2p4]\n *\n * If the cursor is not a record field declaration, CXTypeLayoutError_Invalid\n *   is returned.\n * If the field's type declaration is an incomplete type,\n *   CXTypeLayoutError_Incomplete is returned.\n * If the field's type declaration is a dependent type,\n *   CXTypeLayoutError_Dependent is returned.\n * If the field's name S is not found,\n *   CXTypeLayoutError_InvalidFieldName is returned.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "T", :type "CXType"}], :ret {:spelling "CXType"}, :function/args [:clang/CXType], :symbol "clang_Type_getModifiedType", :function/ret :clang/CXType, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_Type_getModifiedType, :raw-comment "/**\n * Return the type that was modified by this attributed type.\n *\n * If the type is not an attributed type, an invalid type is returned.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "CT", :type "CXType"}], :ret {:spelling "CXType"}, :function/args [:clang/CXType], :symbol "clang_Type_getValueType", :function/ret :clang/CXType, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_Type_getValueType, :raw-comment "/**\n * Gets the type contained by this atomic type.\n *\n * If a non-atomic type is passed in, an invalid type is returned.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "C", :type "CXCursor"}], :ret {:spelling "long long"}, :function/args [:clang/CXCursor], :symbol "clang_Cursor_getOffsetOfField", :function/ret :coffi.mem/long, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_Cursor_getOffsetOfField, :raw-comment "/**\n * Return the offset of the field represented by the Cursor.\n *\n * If the cursor is not a field declaration, -1 is returned.\n * If the cursor semantic parent is not a record field declaration,\n *   CXTypeLayoutError_Invalid is returned.\n * If the field's type declaration is an incomplete type,\n *   CXTypeLayoutError_Incomplete is returned.\n * If the field's type declaration is a dependent type,\n *   CXTypeLayoutError_Dependent is returned.\n * If the field's name S is not found,\n *   CXTypeLayoutError_InvalidFieldName is returned.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "C", :type "CXCursor"}], :ret {:spelling "unsigned int"}, :function/args [:clang/CXCursor], :symbol "clang_Cursor_isAnonymous", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_Cursor_isAnonymous, :raw-comment "/**\n * Determine whether the given cursor represents an anonymous\n * tag or namespace\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "C", :type "CXCursor"}], :ret {:spelling "unsigned int"}, :function/args [:clang/CXCursor], :symbol "clang_Cursor_isAnonymousRecordDecl", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_Cursor_isAnonymousRecordDecl, :raw-comment "/**\n * Determine whether the given cursor represents an anonymous record\n * declaration.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "C", :type "CXCursor"}], :ret {:spelling "unsigned int"}, :function/args [:clang/CXCursor], :symbol "clang_Cursor_isInlineNamespace", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_Cursor_isInlineNamespace, :raw-comment "/**\n * Determine whether the given cursor represents an inline namespace\n * declaration.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "T", :type "CXType"}], :ret {:spelling "int"}, :function/args [:clang/CXType], :symbol "clang_Type_getNumTemplateArguments", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_Type_getNumTemplateArguments, :raw-comment "/**\n * Returns the number of template arguments for given template\n * specialization, or -1 if type \\c T is not a template specialization.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "T", :type "CXType"} {:spelling "i", :type "unsigned int"}], :ret {:spelling "CXType"}, :function/args [:clang/CXType :coffi.mem/int], :symbol "clang_Type_getTemplateArgumentAsType", :function/ret :clang/CXType, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_Type_getTemplateArgumentAsType, :raw-comment "/**\n * Returns the type template argument of a template class specialization\n * at given index.\n *\n * This function only returns template type arguments and does not handle\n * template template arguments or variadic packs.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "T", :type "CXType"}], :ret {:spelling "enum CXRefQualifierKind"}, :function/args [:clang/CXType], :symbol "clang_Type_getCXXRefQualifier", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_Type_getCXXRefQualifier, :raw-comment "/**\n * Retrieve the ref-qualifier kind of a function or method.\n *\n * The ref-qualifier is returned for C++ functions or methods. For other types\n * or non-C++ declarations, CXRefQualifier_None is returned.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "C", :type "CXCursor"}], :ret {:spelling "unsigned int"}, :function/args [:clang/CXCursor], :symbol "clang_Cursor_isBitField", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_Cursor_isBitField, :raw-comment "/**\n * Returns non-zero if the cursor specifies a Record member that is a\n *   bitfield.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "", :type "CXCursor"}], :ret {:spelling "unsigned int"}, :function/args [:clang/CXCursor], :symbol "clang_isVirtualBase", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_isVirtualBase, :raw-comment "/**\n * Returns 1 if the base class specified by the cursor with kind\n *   CX_CXXBaseSpecifier is virtual.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "", :type "CXCursor"}], :ret {:spelling "enum CX_CXXAccessSpecifier"}, :function/args [:clang/CXCursor], :symbol "clang_getCXXAccessSpecifier", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getCXXAccessSpecifier, :raw-comment "/**\n * Returns the access control level for the referenced object.\n *\n * If the cursor refers to a C++ declaration, its access control level within\n * its parent scope is returned. Otherwise, if the cursor refers to a base\n * specifier or access specifier, the specifier itself is returned.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "", :type "CXCursor"}], :ret {:spelling "enum CX_StorageClass"}, :function/args [:clang/CXCursor], :symbol "clang_Cursor_getStorageClass", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_Cursor_getStorageClass, :raw-comment "/**\n * Returns the storage class for a function or variable declaration.\n *\n * If the passed in Cursor is not a function or variable declaration,\n * CX_SC_Invalid is returned else the storage class.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "cursor", :type "CXCursor"}], :ret {:spelling "unsigned int"}, :function/args [:clang/CXCursor], :symbol "clang_getNumOverloadedDecls", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getNumOverloadedDecls, :raw-comment "/**\n * Determine the number of overloaded declarations referenced by a\n * \\c CXCursor_OverloadedDeclRef cursor.\n *\n * \\param cursor The cursor whose overloaded declarations are being queried.\n *\n * \\returns The number of overloaded declarations referenced by \\c cursor. If it\n * is not a \\c CXCursor_OverloadedDeclRef cursor, returns 0.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "cursor", :type "CXCursor"} {:spelling "index", :type "unsigned int"}], :ret {:spelling "CXCursor"}, :function/args [:clang/CXCursor :coffi.mem/int], :symbol "clang_getOverloadedDecl", :function/ret :clang/CXCursor, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getOverloadedDecl, :raw-comment "/**\n * Retrieve a cursor for one of the overloaded declarations referenced\n * by a \\c CXCursor_OverloadedDeclRef cursor.\n *\n * \\param cursor The cursor whose overloaded declarations are being queried.\n *\n * \\param index The zero-based index into the set of overloaded declarations in\n * the cursor.\n *\n * \\returns A cursor representing the declaration referenced by the given\n * \\c cursor at the specified \\c index. If the cursor does not have an\n * associated set of overloaded declarations, or if the index is out of bounds,\n * returns \\c clang_getNullCursor();\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "", :type "CXCursor"}], :ret {:spelling "CXType"}, :function/args [:clang/CXCursor], :symbol "clang_getIBOutletCollectionType", :function/ret :clang/CXType, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getIBOutletCollectionType, :raw-comment "/**\n * For cursors representing an iboutletcollection attribute,\n *  this function returns the collection element type.\n *\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "parent", :type "CXCursor"} {:spelling "visitor", :type "enum CXChildVisitResult (*)(CXCursor, CXCursor, void *)"} {:spelling "client_data", :type "void *"}], :ret {:spelling "unsigned int"}, :function/args [:clang/CXCursor [:coffi.ffi/fn [:clang/CXCursor :clang/CXCursor :coffi.mem/pointer] :coffi.mem/int] :coffi.mem/pointer], :symbol "clang_visitChildren", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_visitChildren, :raw-comment "/**\n * Visit the children of a particular cursor.\n *\n * This function visits all the direct children of the given cursor,\n * invoking the given \\p visitor function with the cursors of each\n * visited child. The traversal may be recursive, if the visitor returns\n * \\c CXChildVisit_Recurse. The traversal may also be ended prematurely, if\n * the visitor returns \\c CXChildVisit_Break.\n *\n * \\param parent the cursor whose child may be visited. All kinds of\n * cursors can be visited, including invalid cursors (which, by\n * definition, have no children).\n *\n * \\param visitor the visitor function that will be invoked for each\n * child of \\p parent.\n *\n * \\param client_data pointer data supplied by the client, which will\n * be passed to the visitor each time it is invoked.\n *\n * \\returns a non-zero value if the traversal was terminated\n * prematurely by the visitor returning \\c CXChildVisit_Break.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "parent", :type "CXCursor"} {:spelling "block", :type "enum CXChildVisitResult (^)(CXCursor, CXCursor)"}], :ret {:spelling "unsigned int"}, :function/args [:clang/CXCursor [:coffi.mem/pointer]], :symbol "clang_visitChildrenWithBlock", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_visitChildrenWithBlock, :raw-comment "/**\n * Visits the children of a cursor using the specified block.  Behaves\n * identically to clang_visitChildren() in all other respects.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "", :type "CXCursor"}], :ret {:spelling "CXString"}, :function/args [:clang/CXCursor], :symbol "clang_getCursorUSR", :function/ret :clang/CXString, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getCursorUSR, :raw-comment "/**\n * Retrieve a Unified Symbol Resolution (USR) for the entity referenced\n * by the given cursor.\n *\n * A Unified Symbol Resolution (USR) is a string that identifies a particular\n * entity (function, class, variable, etc.) within a program. USRs can be\n * compared across translation units to determine, e.g., when references in\n * one translation refer to an entity defined in another translation unit.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "class_name", :type "const char *"}], :ret {:spelling "CXString"}, :function/args [[:coffi.mem/pointer :coffi.mem/char]], :symbol "clang_constructUSR_ObjCClass", :function/ret :clang/CXString, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_constructUSR_ObjCClass, :raw-comment "/**\n * Construct a USR for a specified Objective-C class.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "class_name", :type "const char *"} {:spelling "category_name", :type "const char *"}], :ret {:spelling "CXString"}, :function/args [[:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/char]], :symbol "clang_constructUSR_ObjCCategory", :function/ret :clang/CXString, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_constructUSR_ObjCCategory, :raw-comment "/**\n * Construct a USR for a specified Objective-C category.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "protocol_name", :type "const char *"}], :ret {:spelling "CXString"}, :function/args [[:coffi.mem/pointer :coffi.mem/char]], :symbol "clang_constructUSR_ObjCProtocol", :function/ret :clang/CXString, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_constructUSR_ObjCProtocol, :raw-comment "/**\n * Construct a USR for a specified Objective-C protocol.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "name", :type "const char *"} {:spelling "classUSR", :type "CXString"}], :ret {:spelling "CXString"}, :function/args [[:coffi.mem/pointer :coffi.mem/char] :clang/CXString], :symbol "clang_constructUSR_ObjCIvar", :function/ret :clang/CXString, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_constructUSR_ObjCIvar, :raw-comment "/**\n * Construct a USR for a specified Objective-C instance variable and\n *   the USR for its containing class.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "name", :type "const char *"} {:spelling "isInstanceMethod", :type "unsigned int"} {:spelling "classUSR", :type "CXString"}], :ret {:spelling "CXString"}, :function/args [[:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int :clang/CXString], :symbol "clang_constructUSR_ObjCMethod", :function/ret :clang/CXString, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_constructUSR_ObjCMethod, :raw-comment "/**\n * Construct a USR for a specified Objective-C method and\n *   the USR for its containing class.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "property", :type "const char *"} {:spelling "classUSR", :type "CXString"}], :ret {:spelling "CXString"}, :function/args [[:coffi.mem/pointer :coffi.mem/char] :clang/CXString], :symbol "clang_constructUSR_ObjCProperty", :function/ret :clang/CXString, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_constructUSR_ObjCProperty, :raw-comment "/**\n * Construct a USR for a specified Objective-C property and the USR\n *  for its containing class.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "", :type "CXCursor"}], :ret {:spelling "CXString"}, :function/args [:clang/CXCursor], :symbol "clang_getCursorSpelling", :function/ret :clang/CXString, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getCursorSpelling, :raw-comment "/**\n * Retrieve a name for the entity referenced by this cursor.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "", :type "CXCursor"} {:spelling "pieceIndex", :type "unsigned int"} {:spelling "options", :type "unsigned int"}], :ret {:spelling "CXSourceRange"}, :function/args [:clang/CXCursor :coffi.mem/int :coffi.mem/int], :symbol "clang_Cursor_getSpellingNameRange", :function/ret :clang/CXSourceRange, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_Cursor_getSpellingNameRange, :raw-comment "/**\n * Retrieve a range for a piece that forms the cursors spelling name.\n * Most of the times there is only one range for the complete spelling but for\n * Objective-C methods and Objective-C message expressions, there are multiple\n * pieces for each selector identifier.\n *\n * \\param pieceIndex the index of the spelling name piece. If this is greater\n * than the actual number of pieces, it will return a NULL (invalid) range.\n *\n * \\param options Reserved.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "Policy", :type "void *"} {:spelling "Property", :type "enum CXPrintingPolicyProperty"}], :ret {:spelling "unsigned int"}, :function/args [:coffi.mem/pointer :coffi.mem/int], :symbol "clang_PrintingPolicy_getProperty", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_PrintingPolicy_getProperty, :raw-comment "/**\n * Get a property value for the given printing policy.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "Policy", :type "void *"} {:spelling "Property", :type "enum CXPrintingPolicyProperty"} {:spelling "Value", :type "unsigned int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/pointer :coffi.mem/int :coffi.mem/int], :symbol "clang_PrintingPolicy_setProperty", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_PrintingPolicy_setProperty, :raw-comment "/**\n * Set a property value for the given printing policy.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "", :type "CXCursor"}], :ret {:spelling "void *"}, :function/args [:clang/CXCursor], :symbol "clang_getCursorPrintingPolicy", :function/ret :coffi.mem/pointer, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getCursorPrintingPolicy, :raw-comment "/**\n * Retrieve the default policy for the cursor.\n *\n * The policy should be released after use with \\c\n * clang_PrintingPolicy_dispose.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "Policy", :type "void *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/pointer], :symbol "clang_PrintingPolicy_dispose", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_PrintingPolicy_dispose, :raw-comment "/**\n * Release a printing policy.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "Cursor", :type "CXCursor"} {:spelling "Policy", :type "void *"}], :ret {:spelling "CXString"}, :function/args [:clang/CXCursor :coffi.mem/pointer], :symbol "clang_getCursorPrettyPrinted", :function/ret :clang/CXString, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getCursorPrettyPrinted, :raw-comment "/**\n * Pretty print declarations.\n *\n * \\param Cursor The cursor representing a declaration.\n *\n * \\param Policy The policy to control the entities being printed. If\n * NULL, a default policy is used.\n *\n * \\returns The pretty printed declaration or the empty string for\n * other cursors.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "", :type "CXCursor"}], :ret {:spelling "CXString"}, :function/args [:clang/CXCursor], :symbol "clang_getCursorDisplayName", :function/ret :clang/CXString, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getCursorDisplayName, :raw-comment "/**\n * Retrieve the display name for the entity referenced by this cursor.\n *\n * The display name contains extra information that helps identify the cursor,\n * such as the parameters of a function or template or the arguments of a\n * class template specialization.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "", :type "CXCursor"}], :ret {:spelling "CXCursor"}, :function/args [:clang/CXCursor], :symbol "clang_getCursorReferenced", :function/ret :clang/CXCursor, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getCursorReferenced, :raw-comment "/** For a cursor that is a reference, retrieve a cursor representing the\n * entity that it references.\n *\n * Reference cursors refer to other entities in the AST. For example, an\n * Objective-C superclass reference cursor refers to an Objective-C class.\n * This function produces the cursor for the Objective-C class from the\n * cursor for the superclass reference. If the input cursor is a declaration or\n * definition, it returns that declaration or definition unchanged.\n * Otherwise, returns the NULL cursor.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "", :type "CXCursor"}], :ret {:spelling "CXCursor"}, :function/args [:clang/CXCursor], :symbol "clang_getCursorDefinition", :function/ret :clang/CXCursor, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getCursorDefinition, :raw-comment "/**\n *  For a cursor that is either a reference to or a declaration\n *  of some entity, retrieve a cursor that describes the definition of\n *  that entity.\n *\n *  Some entities can be declared multiple times within a translation\n *  unit, but only one of those declarations can also be a\n *  definition. For example, given:\n *\n *  \\code\n *  int f(int, int);\n *  int g(int x, int y) { return f(x, y); }\n *  int f(int a, int b) { return a + b; }\n *  int f(int, int);\n *  \\endcode\n *\n *  there are three declarations of the function \"f\", but only the\n *  second one is a definition. The clang_getCursorDefinition()\n *  function will take any cursor pointing to a declaration of \"f\"\n *  (the first or fourth lines of the example) or a cursor referenced\n *  that uses \"f\" (the call to \"f' inside \"g\") and will return a\n *  declaration cursor pointing to the definition (the second \"f\"\n *  declaration).\n *\n *  If given a cursor for which there is no corresponding definition,\n *  e.g., because there is no definition of that entity within this\n *  translation unit, returns a NULL cursor.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "", :type "CXCursor"}], :ret {:spelling "unsigned int"}, :function/args [:clang/CXCursor], :symbol "clang_isCursorDefinition", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_isCursorDefinition, :raw-comment "/**\n * Determine whether the declaration pointed to by this cursor\n * is also a definition of that entity.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "", :type "CXCursor"}], :ret {:spelling "CXCursor"}, :function/args [:clang/CXCursor], :symbol "clang_getCanonicalCursor", :function/ret :clang/CXCursor, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getCanonicalCursor, :raw-comment "/**\n * Retrieve the canonical cursor corresponding to the given cursor.\n *\n * In the C family of languages, many kinds of entities can be declared several\n * times within a single translation unit. For example, a structure type can\n * be forward-declared (possibly multiple times) and later defined:\n *\n * \\code\n * struct X;\n * struct X;\n * struct X {\n *   int member;\n * };\n * \\endcode\n *\n * The declarations and the definition of \\c X are represented by three\n * different cursors, all of which are declarations of the same underlying\n * entity. One of these cursor is considered the \"canonical\" cursor, which\n * is effectively the representative for the underlying entity. One can\n * determine if two cursors are declarations of the same underlying entity by\n * comparing their canonical cursors.\n *\n * \\returns The canonical cursor for the entity referred to by the given cursor.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "", :type "CXCursor"}], :ret {:spelling "int"}, :function/args [:clang/CXCursor], :symbol "clang_Cursor_getObjCSelectorIndex", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_Cursor_getObjCSelectorIndex, :raw-comment "/**\n * If the cursor points to a selector identifier in an Objective-C\n * method or message expression, this returns the selector index.\n *\n * After getting a cursor with #clang_getCursor, this can be called to\n * determine if the location points to a selector identifier.\n *\n * \\returns The selector index if the cursor is an Objective-C method or message\n * expression and the cursor is pointing to a selector identifier, or -1\n * otherwise.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "C", :type "CXCursor"}], :ret {:spelling "int"}, :function/args [:clang/CXCursor], :symbol "clang_Cursor_isDynamicCall", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_Cursor_isDynamicCall, :raw-comment "/**\n * Given a cursor pointing to a C++ method call or an Objective-C\n * message, returns non-zero if the method/message is \"dynamic\", meaning:\n *\n * For a C++ method: the call is virtual.\n * For an Objective-C message: the receiver is an object instance, not 'super'\n * or a specific class.\n *\n * If the method/message is \"static\" or the cursor does not point to a\n * method/message, it will return zero.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "C", :type "CXCursor"}], :ret {:spelling "CXType"}, :function/args [:clang/CXCursor], :symbol "clang_Cursor_getReceiverType", :function/ret :clang/CXType, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_Cursor_getReceiverType, :raw-comment "/**\n * Given a cursor pointing to an Objective-C message or property\n * reference, or C++ method call, returns the CXType of the receiver.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "C", :type "CXCursor"} {:spelling "reserved", :type "unsigned int"}], :ret {:spelling "unsigned int"}, :function/args [:clang/CXCursor :coffi.mem/int], :symbol "clang_Cursor_getObjCPropertyAttributes", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_Cursor_getObjCPropertyAttributes, :raw-comment "/**\n * Given a cursor that represents a property declaration, return the\n * associated property attributes. The bits are formed from\n * \\c CXObjCPropertyAttrKind.\n *\n * \\param reserved Reserved for future use, pass 0.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "C", :type "CXCursor"}], :ret {:spelling "CXString"}, :function/args [:clang/CXCursor], :symbol "clang_Cursor_getObjCPropertyGetterName", :function/ret :clang/CXString, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_Cursor_getObjCPropertyGetterName, :raw-comment "/**\n * Given a cursor that represents a property declaration, return the\n * name of the method that implements the getter.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "C", :type "CXCursor"}], :ret {:spelling "CXString"}, :function/args [:clang/CXCursor], :symbol "clang_Cursor_getObjCPropertySetterName", :function/ret :clang/CXString, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_Cursor_getObjCPropertySetterName, :raw-comment "/**\n * Given a cursor that represents a property declaration, return the\n * name of the method that implements the setter, if any.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "C", :type "CXCursor"}], :ret {:spelling "unsigned int"}, :function/args [:clang/CXCursor], :symbol "clang_Cursor_getObjCDeclQualifiers", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_Cursor_getObjCDeclQualifiers, :raw-comment "/**\n * Given a cursor that represents an Objective-C method or parameter\n * declaration, return the associated Objective-C qualifiers for the return\n * type or the parameter respectively. The bits are formed from\n * CXObjCDeclQualifierKind.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "C", :type "CXCursor"}], :ret {:spelling "unsigned int"}, :function/args [:clang/CXCursor], :symbol "clang_Cursor_isObjCOptional", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_Cursor_isObjCOptional, :raw-comment "/**\n * Given a cursor that represents an Objective-C method or property\n * declaration, return non-zero if the declaration was affected by \"\\@optional\".\n * Returns zero if the cursor is not such a declaration or it is \"\\@required\".\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "C", :type "CXCursor"}], :ret {:spelling "unsigned int"}, :function/args [:clang/CXCursor], :symbol "clang_Cursor_isVariadic", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_Cursor_isVariadic, :raw-comment "/**\n * Returns non-zero if the given cursor is a variadic function or method.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "C", :type "CXCursor"} {:spelling "language", :type "CXString *"} {:spelling "definedIn", :type "CXString *"} {:spelling "isGenerated", :type "unsigned int *"}], :ret {:spelling "unsigned int"}, :function/args [:clang/CXCursor [:coffi.mem/pointer :clang/CXString] [:coffi.mem/pointer :clang/CXString] [:coffi.mem/pointer :coffi.mem/int]], :symbol "clang_Cursor_isExternalSymbol", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_Cursor_isExternalSymbol, :raw-comment "/**\n * Returns non-zero if the given cursor points to a symbol marked with\n * external_source_symbol attribute.\n *\n * \\param language If non-NULL, and the attribute is present, will be set to\n * the 'language' string from the attribute.\n *\n * \\param definedIn If non-NULL, and the attribute is present, will be set to\n * the 'definedIn' string from the attribute.\n *\n * \\param isGenerated If non-NULL, and the attribute is present, will be set to\n * non-zero if the 'generated_declaration' is set in the attribute.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "C", :type "CXCursor"}], :ret {:spelling "CXSourceRange"}, :function/args [:clang/CXCursor], :symbol "clang_Cursor_getCommentRange", :function/ret :clang/CXSourceRange, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_Cursor_getCommentRange, :raw-comment "/**\n * Given a cursor that represents a declaration, return the associated\n * comment's source range.  The range may include multiple consecutive comments\n * with whitespace in between.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "C", :type "CXCursor"}], :ret {:spelling "CXString"}, :function/args [:clang/CXCursor], :symbol "clang_Cursor_getRawCommentText", :function/ret :clang/CXString, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_Cursor_getRawCommentText, :raw-comment "/**\n * Given a cursor that represents a declaration, return the associated\n * comment text, including comment markers.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "C", :type "CXCursor"}], :ret {:spelling "CXString"}, :function/args [:clang/CXCursor], :symbol "clang_Cursor_getBriefCommentText", :function/ret :clang/CXString, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_Cursor_getBriefCommentText, :raw-comment "/**\n * Given a cursor that represents a documentable entity (e.g.,\n * declaration), return the associated \\paragraph; otherwise return the\n * first paragraph.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "", :type "CXCursor"}], :ret {:spelling "CXString"}, :function/args [:clang/CXCursor], :symbol "clang_Cursor_getMangling", :function/ret :clang/CXString, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_Cursor_getMangling, :raw-comment "/**\n * Retrieve the CXString representing the mangled name of the cursor.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "", :type "CXCursor"}], :ret {:spelling "CXStringSet *"}, :function/args [:clang/CXCursor], :symbol "clang_Cursor_getCXXManglings", :function/ret [:coffi.mem/pointer :clang/CXStringSet], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_Cursor_getCXXManglings, :raw-comment "/**\n * Retrieve the CXStrings representing the mangled symbols of the C++\n * constructor or destructor at the cursor.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "", :type "CXCursor"}], :ret {:spelling "CXStringSet *"}, :function/args [:clang/CXCursor], :symbol "clang_Cursor_getObjCManglings", :function/ret [:coffi.mem/pointer :clang/CXStringSet], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_Cursor_getObjCManglings, :raw-comment "/**\n * Retrieve the CXStrings representing the mangled symbols of the ObjC\n * class interface or implementation at the cursor.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "C", :type "CXCursor"}], :ret {:spelling "void *"}, :function/args [:clang/CXCursor], :symbol "clang_Cursor_getModule", :function/ret :coffi.mem/pointer, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_Cursor_getModule, :raw-comment "/**\n * Given a CXCursor_ModuleImportDecl cursor, return the associated module.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "", :type "struct CXTranslationUnitImpl *"} {:spelling "", :type "void *"}], :ret {:spelling "void *"}, :function/args [[:coffi.mem/pointer :clang/CXTranslationUnitImpl] :coffi.mem/pointer], :symbol "clang_getModuleForFile", :function/ret :coffi.mem/pointer, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getModuleForFile, :raw-comment "/**\n * Given a CXFile header file, return the module that contains it, if one\n * exists.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "Module", :type "void *"}], :ret {:spelling "void *"}, :function/args [:coffi.mem/pointer], :symbol "clang_Module_getASTFile", :function/ret :coffi.mem/pointer, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_Module_getASTFile, :raw-comment "/**\n * \\param Module a module object.\n *\n * \\returns the module file where the provided module object came from.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "Module", :type "void *"}], :ret {:spelling "void *"}, :function/args [:coffi.mem/pointer], :symbol "clang_Module_getParent", :function/ret :coffi.mem/pointer, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_Module_getParent, :raw-comment "/**\n * \\param Module a module object.\n *\n * \\returns the parent of a sub-module or NULL if the given module is top-level,\n * e.g. for 'std.vector' it will return the 'std' module.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "Module", :type "void *"}], :ret {:spelling "CXString"}, :function/args [:coffi.mem/pointer], :symbol "clang_Module_getName", :function/ret :clang/CXString, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_Module_getName, :raw-comment "/**\n * \\param Module a module object.\n *\n * \\returns the name of the module, e.g. for the 'std.vector' sub-module it\n * will return \"vector\".\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "Module", :type "void *"}], :ret {:spelling "CXString"}, :function/args [:coffi.mem/pointer], :symbol "clang_Module_getFullName", :function/ret :clang/CXString, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_Module_getFullName, :raw-comment "/**\n * \\param Module a module object.\n *\n * \\returns the full name of the module, e.g. \"std.vector\".\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "Module", :type "void *"}], :ret {:spelling "int"}, :function/args [:coffi.mem/pointer], :symbol "clang_Module_isSystem", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_Module_isSystem, :raw-comment "/**\n * \\param Module a module object.\n *\n * \\returns non-zero if the module is a system one.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "", :type "struct CXTranslationUnitImpl *"} {:spelling "Module", :type "void *"}], :ret {:spelling "unsigned int"}, :function/args [[:coffi.mem/pointer :clang/CXTranslationUnitImpl] :coffi.mem/pointer], :symbol "clang_Module_getNumTopLevelHeaders", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_Module_getNumTopLevelHeaders, :raw-comment "/**\n * \\param Module a module object.\n *\n * \\returns the number of top level headers associated with this module.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "", :type "struct CXTranslationUnitImpl *"} {:spelling "Module", :type "void *"} {:spelling "Index", :type "unsigned int"}], :ret {:spelling "void *"}, :function/args [[:coffi.mem/pointer :clang/CXTranslationUnitImpl] :coffi.mem/pointer :coffi.mem/int], :symbol "clang_Module_getTopLevelHeader", :function/ret :coffi.mem/pointer, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_Module_getTopLevelHeader, :raw-comment "/**\n * \\param Module a module object.\n *\n * \\param Index top level header index (zero-based).\n *\n * \\returns the specified top level header associated with the module.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "C", :type "CXCursor"}], :ret {:spelling "unsigned int"}, :function/args [:clang/CXCursor], :symbol "clang_CXXConstructor_isConvertingConstructor", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_CXXConstructor_isConvertingConstructor, :raw-comment "/**\n * Determine if a C++ constructor is a converting constructor.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "C", :type "CXCursor"}], :ret {:spelling "unsigned int"}, :function/args [:clang/CXCursor], :symbol "clang_CXXConstructor_isCopyConstructor", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_CXXConstructor_isCopyConstructor, :raw-comment "/**\n * Determine if a C++ constructor is a copy constructor.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "C", :type "CXCursor"}], :ret {:spelling "unsigned int"}, :function/args [:clang/CXCursor], :symbol "clang_CXXConstructor_isDefaultConstructor", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_CXXConstructor_isDefaultConstructor, :raw-comment "/**\n * Determine if a C++ constructor is the default constructor.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "C", :type "CXCursor"}], :ret {:spelling "unsigned int"}, :function/args [:clang/CXCursor], :symbol "clang_CXXConstructor_isMoveConstructor", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_CXXConstructor_isMoveConstructor, :raw-comment "/**\n * Determine if a C++ constructor is a move constructor.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "C", :type "CXCursor"}], :ret {:spelling "unsigned int"}, :function/args [:clang/CXCursor], :symbol "clang_CXXField_isMutable", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_CXXField_isMutable, :raw-comment "/**\n * Determine if a C++ field is declared 'mutable'.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "C", :type "CXCursor"}], :ret {:spelling "unsigned int"}, :function/args [:clang/CXCursor], :symbol "clang_CXXMethod_isDefaulted", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_CXXMethod_isDefaulted, :raw-comment "/**\n * Determine if a C++ method is declared '= default'.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "C", :type "CXCursor"}], :ret {:spelling "unsigned int"}, :function/args [:clang/CXCursor], :symbol "clang_CXXMethod_isPureVirtual", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_CXXMethod_isPureVirtual, :raw-comment "/**\n * Determine if a C++ member function or member function template is\n * pure virtual.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "C", :type "CXCursor"}], :ret {:spelling "unsigned int"}, :function/args [:clang/CXCursor], :symbol "clang_CXXMethod_isStatic", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_CXXMethod_isStatic, :raw-comment "/**\n * Determine if a C++ member function or member function template is\n * declared 'static'.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "C", :type "CXCursor"}], :ret {:spelling "unsigned int"}, :function/args [:clang/CXCursor], :symbol "clang_CXXMethod_isVirtual", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_CXXMethod_isVirtual, :raw-comment "/**\n * Determine if a C++ member function or member function template is\n * explicitly declared 'virtual' or if it overrides a virtual method from\n * one of the base classes.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "C", :type "CXCursor"}], :ret {:spelling "unsigned int"}, :function/args [:clang/CXCursor], :symbol "clang_CXXRecord_isAbstract", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_CXXRecord_isAbstract, :raw-comment "/**\n * Determine if a C++ record is abstract, i.e. whether a class or struct\n * has a pure virtual member function.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "C", :type "CXCursor"}], :ret {:spelling "unsigned int"}, :function/args [:clang/CXCursor], :symbol "clang_EnumDecl_isScoped", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_EnumDecl_isScoped, :raw-comment "/**\n * Determine if an enum declaration refers to a scoped enum.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "C", :type "CXCursor"}], :ret {:spelling "unsigned int"}, :function/args [:clang/CXCursor], :symbol "clang_CXXMethod_isConst", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_CXXMethod_isConst, :raw-comment "/**\n * Determine if a C++ member function or member function template is\n * declared 'const'.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "C", :type "CXCursor"}], :ret {:spelling "enum CXCursorKind"}, :function/args [:clang/CXCursor], :symbol "clang_getTemplateCursorKind", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getTemplateCursorKind, :raw-comment "/**\n * Given a cursor that represents a template, determine\n * the cursor kind of the specializations would be generated by instantiating\n * the template.\n *\n * This routine can be used to determine what flavor of function template,\n * class template, or class template partial specialization is stored in the\n * cursor. For example, it can describe whether a class template cursor is\n * declared with \"struct\", \"class\" or \"union\".\n *\n * \\param C The cursor to query. This cursor should represent a template\n * declaration.\n *\n * \\returns The cursor kind of the specializations that would be generated\n * by instantiating the template \\p C. If \\p C is not a template, returns\n * \\c CXCursor_NoDeclFound.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "C", :type "CXCursor"}], :ret {:spelling "CXCursor"}, :function/args [:clang/CXCursor], :symbol "clang_getSpecializedCursorTemplate", :function/ret :clang/CXCursor, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getSpecializedCursorTemplate, :raw-comment "/**\n * Given a cursor that may represent a specialization or instantiation\n * of a template, retrieve the cursor that represents the template that it\n * specializes or from which it was instantiated.\n *\n * This routine determines the template involved both for explicit\n * specializations of templates and for implicit instantiations of the template,\n * both of which are referred to as \"specializations\". For a class template\n * specialization (e.g., \\c std::vector<bool>), this routine will return\n * either the primary template (\\c std::vector) or, if the specialization was\n * instantiated from a class template partial specialization, the class template\n * partial specialization. For a class template partial specialization and a\n * function template specialization (including instantiations), this\n * this routine will return the specialized template.\n *\n * For members of a class template (e.g., member functions, member classes, or\n * static data members), returns the specialized or instantiated member.\n * Although not strictly \"templates\" in the C++ language, members of class\n * templates have the same notions of specializations and instantiations that\n * templates do, so this routine treats them similarly.\n *\n * \\param C A cursor that may be a specialization of a template or a member\n * of a template.\n *\n * \\returns If the given cursor is a specialization or instantiation of a\n * template or a member thereof, the template or member that it specializes or\n * from which it was instantiated. Otherwise, returns a NULL cursor.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "C", :type "CXCursor"} {:spelling "NameFlags", :type "unsigned int"} {:spelling "PieceIndex", :type "unsigned int"}], :ret {:spelling "CXSourceRange"}, :function/args [:clang/CXCursor :coffi.mem/int :coffi.mem/int], :symbol "clang_getCursorReferenceNameRange", :function/ret :clang/CXSourceRange, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getCursorReferenceNameRange, :raw-comment "/**\n * Given a cursor that references something else, return the source range\n * covering that reference.\n *\n * \\param C A cursor pointing to a member reference, a declaration reference, or\n * an operator call.\n * \\param NameFlags A bitset with three independent flags:\n * CXNameRange_WantQualifier, CXNameRange_WantTemplateArgs, and\n * CXNameRange_WantSinglePiece.\n * \\param PieceIndex For contiguous names or when passing the flag\n * CXNameRange_WantSinglePiece, only one piece with index 0 is\n * available. When the CXNameRange_WantSinglePiece flag is not passed for a\n * non-contiguous names, this index can be used to retrieve the individual\n * pieces of the name. See also CXNameRange_WantSinglePiece.\n *\n * \\returns The piece of the name pointed to by the given cursor. If there is no\n * name, or if the PieceIndex is out-of-range, a null-cursor will be returned.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "TU", :type "struct CXTranslationUnitImpl *"} {:spelling "Location", :type "CXSourceLocation"}], :ret {:spelling "CXToken *"}, :function/args [[:coffi.mem/pointer :clang/CXTranslationUnitImpl] :clang/CXSourceLocation], :symbol "clang_getToken", :function/ret [:coffi.mem/pointer :clang/CXToken], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getToken, :raw-comment "/**\n * Get the raw lexical token starting with the given location.\n *\n * \\param TU the translation unit whose text is being tokenized.\n *\n * \\param Location the source location with which the token starts.\n *\n * \\returns The token starting with the given location or NULL if no such token\n * exist. The returned pointer must be freed with clang_disposeTokens before the\n * translation unit is destroyed.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "", :type "CXToken"}], :ret {:spelling "enum CXTokenKind"}, :function/args [:clang/CXToken], :symbol "clang_getTokenKind", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getTokenKind, :raw-comment "/**\n * Determine the kind of the given token.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "", :type "struct CXTranslationUnitImpl *"} {:spelling "", :type "CXToken"}], :ret {:spelling "CXString"}, :function/args [[:coffi.mem/pointer :clang/CXTranslationUnitImpl] :clang/CXToken], :symbol "clang_getTokenSpelling", :function/ret :clang/CXString, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getTokenSpelling, :raw-comment "/**\n * Determine the spelling of the given token.\n *\n * The spelling of a token is the textual representation of that token, e.g.,\n * the text of an identifier or keyword.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "", :type "struct CXTranslationUnitImpl *"} {:spelling "", :type "CXToken"}], :ret {:spelling "CXSourceLocation"}, :function/args [[:coffi.mem/pointer :clang/CXTranslationUnitImpl] :clang/CXToken], :symbol "clang_getTokenLocation", :function/ret :clang/CXSourceLocation, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getTokenLocation, :raw-comment "/**\n * Retrieve the source location of the given token.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "", :type "struct CXTranslationUnitImpl *"} {:spelling "", :type "CXToken"}], :ret {:spelling "CXSourceRange"}, :function/args [[:coffi.mem/pointer :clang/CXTranslationUnitImpl] :clang/CXToken], :symbol "clang_getTokenExtent", :function/ret :clang/CXSourceRange, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getTokenExtent, :raw-comment "/**\n * Retrieve a source range that covers the given token.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "TU", :type "struct CXTranslationUnitImpl *"} {:spelling "Range", :type "CXSourceRange"} {:spelling "Tokens", :type "CXToken **"} {:spelling "NumTokens", :type "unsigned int *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clang/CXTranslationUnitImpl] :clang/CXSourceRange [:coffi.mem/pointer [:coffi.mem/pointer :clang/CXToken]] [:coffi.mem/pointer :coffi.mem/int]], :symbol "clang_tokenize", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_tokenize, :raw-comment "/**\n * Tokenize the source code described by the given range into raw\n * lexical tokens.\n *\n * \\param TU the translation unit whose text is being tokenized.\n *\n * \\param Range the source range in which text should be tokenized. All of the\n * tokens produced by tokenization will fall within this source range,\n *\n * \\param Tokens this pointer will be set to point to the array of tokens\n * that occur within the given source range. The returned pointer must be\n * freed with clang_disposeTokens() before the translation unit is destroyed.\n *\n * \\param NumTokens will be set to the number of tokens in the \\c *Tokens\n * array.\n *\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "TU", :type "struct CXTranslationUnitImpl *"} {:spelling "Tokens", :type "CXToken *"} {:spelling "NumTokens", :type "unsigned int"} {:spelling "Cursors", :type "CXCursor *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clang/CXTranslationUnitImpl] [:coffi.mem/pointer :clang/CXToken] :coffi.mem/int [:coffi.mem/pointer :clang/CXCursor]], :symbol "clang_annotateTokens", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_annotateTokens, :raw-comment "/**\n * Annotate the given set of tokens by providing cursors for each token\n * that can be mapped to a specific entity within the abstract syntax tree.\n *\n * This token-annotation routine is equivalent to invoking\n * clang_getCursor() for the source locations of each of the\n * tokens. The cursors provided are filtered, so that only those\n * cursors that have a direct correspondence to the token are\n * accepted. For example, given a function call \\c f(x),\n * clang_getCursor() would provide the following cursors:\n *\n *   * when the cursor is over the 'f', a DeclRefExpr cursor referring to 'f'.\n *   * when the cursor is over the '(' or the ')', a CallExpr referring to 'f'.\n *   * when the cursor is over the 'x', a DeclRefExpr cursor referring to 'x'.\n *\n * Only the first and last of these cursors will occur within the\n * annotate, since the tokens \"f\" and \"x' directly refer to a function\n * and a variable, respectively, but the parentheses are just a small\n * part of the full syntax of the function call expression, which is\n * not provided as an annotation.\n *\n * \\param TU the translation unit that owns the given tokens.\n *\n * \\param Tokens the set of tokens to annotate.\n *\n * \\param NumTokens the number of tokens in \\p Tokens.\n *\n * \\param Cursors an array of \\p NumTokens cursors, whose contents will be\n * replaced with the cursors corresponding to each token.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "TU", :type "struct CXTranslationUnitImpl *"} {:spelling "Tokens", :type "CXToken *"} {:spelling "NumTokens", :type "unsigned int"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clang/CXTranslationUnitImpl] [:coffi.mem/pointer :clang/CXToken] :coffi.mem/int], :symbol "clang_disposeTokens", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_disposeTokens, :raw-comment "/**\n * Free the given set of tokens.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "Kind", :type "enum CXCursorKind"}], :ret {:spelling "CXString"}, :function/args [:coffi.mem/int], :symbol "clang_getCursorKindSpelling", :function/ret :clang/CXString, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getCursorKindSpelling, :raw-comment "/**\n * \\defgroup CINDEX_DEBUG Debugging facilities\n *\n * These routines are used for testing and debugging, only, and should not\n * be relied upon.\n *\n * @{\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "", :type "CXCursor"} {:spelling "startBuf", :type "const char **"} {:spelling "endBuf", :type "const char **"} {:spelling "startLine", :type "unsigned int *"} {:spelling "startColumn", :type "unsigned int *"} {:spelling "endLine", :type "unsigned int *"} {:spelling "endColumn", :type "unsigned int *"}], :ret {:spelling "void"}, :function/args [:clang/CXCursor [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]] [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]] [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :coffi.mem/int]], :symbol "clang_getDefinitionSpellingAndExtent", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getDefinitionSpellingAndExtent, :raw-comment nil, :kind "CXCursor_FunctionDecl"} {:args [], :ret {:spelling "void"}, :function/args [], :symbol "clang_enableStackTraces", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_enableStackTraces, :raw-comment nil, :kind "CXCursor_FunctionDecl"} {:args [{:spelling "fn", :type "void (*)(void *)"} {:spelling "user_data", :type "void *"} {:spelling "stack_size", :type "unsigned int"}], :ret {:spelling "void"}, :function/args [[:coffi.ffi/fn [:coffi.mem/pointer] :coffi.mem/void] :coffi.mem/pointer :coffi.mem/int], :symbol "clang_executeOnThread", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_executeOnThread, :raw-comment nil, :kind "CXCursor_FunctionDecl"} {:args [{:spelling "completion_string", :type "void *"} {:spelling "chunk_number", :type "unsigned int"}], :ret {:spelling "enum CXCompletionChunkKind"}, :function/args [:coffi.mem/pointer :coffi.mem/int], :symbol "clang_getCompletionChunkKind", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getCompletionChunkKind, :raw-comment "/**\n * Determine the kind of a particular chunk within a completion string.\n *\n * \\param completion_string the completion string to query.\n *\n * \\param chunk_number the 0-based index of the chunk in the completion string.\n *\n * \\returns the kind of the chunk at the index \\c chunk_number.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "completion_string", :type "void *"} {:spelling "chunk_number", :type "unsigned int"}], :ret {:spelling "CXString"}, :function/args [:coffi.mem/pointer :coffi.mem/int], :symbol "clang_getCompletionChunkText", :function/ret :clang/CXString, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getCompletionChunkText, :raw-comment "/**\n * Retrieve the text associated with a particular chunk within a\n * completion string.\n *\n * \\param completion_string the completion string to query.\n *\n * \\param chunk_number the 0-based index of the chunk in the completion string.\n *\n * \\returns the text associated with the chunk at index \\c chunk_number.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "completion_string", :type "void *"} {:spelling "chunk_number", :type "unsigned int"}], :ret {:spelling "void *"}, :function/args [:coffi.mem/pointer :coffi.mem/int], :symbol "clang_getCompletionChunkCompletionString", :function/ret :coffi.mem/pointer, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getCompletionChunkCompletionString, :raw-comment "/**\n * Retrieve the completion string associated with a particular chunk\n * within a completion string.\n *\n * \\param completion_string the completion string to query.\n *\n * \\param chunk_number the 0-based index of the chunk in the completion string.\n *\n * \\returns the completion string associated with the chunk at index\n * \\c chunk_number.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "completion_string", :type "void *"}], :ret {:spelling "unsigned int"}, :function/args [:coffi.mem/pointer], :symbol "clang_getNumCompletionChunks", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getNumCompletionChunks, :raw-comment "/**\n * Retrieve the number of chunks in the given code-completion string.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "completion_string", :type "void *"}], :ret {:spelling "unsigned int"}, :function/args [:coffi.mem/pointer], :symbol "clang_getCompletionPriority", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getCompletionPriority, :raw-comment "/**\n * Determine the priority of this code completion.\n *\n * The priority of a code completion indicates how likely it is that this\n * particular completion is the completion that the user will select. The\n * priority is selected by various internal heuristics.\n *\n * \\param completion_string The completion string to query.\n *\n * \\returns The priority of this completion string. Smaller values indicate\n * higher-priority (more likely) completions.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "completion_string", :type "void *"}], :ret {:spelling "enum CXAvailabilityKind"}, :function/args [:coffi.mem/pointer], :symbol "clang_getCompletionAvailability", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getCompletionAvailability, :raw-comment "/**\n * Determine the availability of the entity that this code-completion\n * string refers to.\n *\n * \\param completion_string The completion string to query.\n *\n * \\returns The availability of the completion string.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "completion_string", :type "void *"}], :ret {:spelling "unsigned int"}, :function/args [:coffi.mem/pointer], :symbol "clang_getCompletionNumAnnotations", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getCompletionNumAnnotations, :raw-comment "/**\n * Retrieve the number of annotations associated with the given\n * completion string.\n *\n * \\param completion_string the completion string to query.\n *\n * \\returns the number of annotations associated with the given completion\n * string.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "completion_string", :type "void *"} {:spelling "annotation_number", :type "unsigned int"}], :ret {:spelling "CXString"}, :function/args [:coffi.mem/pointer :coffi.mem/int], :symbol "clang_getCompletionAnnotation", :function/ret :clang/CXString, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getCompletionAnnotation, :raw-comment "/**\n * Retrieve the annotation associated with the given completion string.\n *\n * \\param completion_string the completion string to query.\n *\n * \\param annotation_number the 0-based index of the annotation of the\n * completion string.\n *\n * \\returns annotation string associated with the completion at index\n * \\c annotation_number, or a NULL string if that annotation is not available.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "completion_string", :type "void *"} {:spelling "kind", :type "enum CXCursorKind *"}], :ret {:spelling "CXString"}, :function/args [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/int]], :symbol "clang_getCompletionParent", :function/ret :clang/CXString, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getCompletionParent, :raw-comment "/**\n * Retrieve the parent context of the given completion string.\n *\n * The parent context of a completion string is the semantic parent of\n * the declaration (if any) that the code completion represents. For example,\n * a code completion for an Objective-C method would have the method's class\n * or protocol as its context.\n *\n * \\param completion_string The code completion string whose parent is\n * being queried.\n *\n * \\param kind DEPRECATED: always set to CXCursor_NotImplemented if non-NULL.\n *\n * \\returns The name of the completion parent, e.g., \"NSObject\" if\n * the completion string represents a method in the NSObject class.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "completion_string", :type "void *"}], :ret {:spelling "CXString"}, :function/args [:coffi.mem/pointer], :symbol "clang_getCompletionBriefComment", :function/ret :clang/CXString, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getCompletionBriefComment, :raw-comment "/**\n * Retrieve the brief documentation comment attached to the declaration\n * that corresponds to the given completion string.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "cursor", :type "CXCursor"}], :ret {:spelling "void *"}, :function/args [:clang/CXCursor], :symbol "clang_getCursorCompletionString", :function/ret :coffi.mem/pointer, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getCursorCompletionString, :raw-comment "/**\n * Retrieve a completion string for an arbitrary declaration or macro\n * definition cursor.\n *\n * \\param cursor The cursor to query.\n *\n * \\returns A non-context-sensitive completion string for declaration and macro\n * definition cursors, or NULL for other kinds of cursors.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "results", :type "CXCodeCompleteResults *"} {:spelling "completion_index", :type "unsigned int"}], :ret {:spelling "unsigned int"}, :function/args [[:coffi.mem/pointer :clang/CXCodeCompleteResults] :coffi.mem/int], :symbol "clang_getCompletionNumFixIts", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getCompletionNumFixIts, :raw-comment "/**\n * Retrieve the number of fix-its for the given completion index.\n *\n * Calling this makes sense only if CXCodeComplete_IncludeCompletionsWithFixIts\n * option was set.\n *\n * \\param results The structure keeping all completion results\n *\n * \\param completion_index The index of the completion\n *\n * \\return The number of fix-its which must be applied before the completion at\n * completion_index can be applied\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "results", :type "CXCodeCompleteResults *"} {:spelling "completion_index", :type "unsigned int"} {:spelling "fixit_index", :type "unsigned int"} {:spelling "replacement_range", :type "CXSourceRange *"}], :ret {:spelling "CXString"}, :function/args [[:coffi.mem/pointer :clang/CXCodeCompleteResults] :coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :clang/CXSourceRange]], :symbol "clang_getCompletionFixIt", :function/ret :clang/CXString, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getCompletionFixIt, :raw-comment "/**\n * Fix-its that *must* be applied before inserting the text for the\n * corresponding completion.\n *\n * By default, clang_codeCompleteAt() only returns completions with empty\n * fix-its. Extra completions with non-empty fix-its should be explicitly\n * requested by setting CXCodeComplete_IncludeCompletionsWithFixIts.\n *\n * For the clients to be able to compute position of the cursor after applying\n * fix-its, the following conditions are guaranteed to hold for\n * replacement_range of the stored fix-its:\n *  - Ranges in the fix-its are guaranteed to never contain the completion\n *  point (or identifier under completion point, if any) inside them, except\n *  at the start or at the end of the range.\n *  - If a fix-it range starts or ends with completion point (or starts or\n *  ends after the identifier under completion point), it will contain at\n *  least one character. It allows to unambiguously recompute completion\n *  point after applying the fix-it.\n *\n * The intuition is that provided fix-its change code around the identifier we\n * complete, but are not allowed to touch the identifier itself or the\n * completion point. One example of completions with corrections are the ones\n * replacing '.' with '->' and vice versa:\n *\n * std::unique_ptr<std::vector<int>> vec_ptr;\n * In 'vec_ptr.^', one of the completions is 'push_back', it requires\n * replacing '.' with '->'.\n * In 'vec_ptr->^', one of the completions is 'release', it requires\n * replacing '->' with '.'.\n *\n * \\param results The structure keeping all completion results\n *\n * \\param completion_index The index of the completion\n *\n * \\param fixit_index The index of the fix-it for the completion at\n * completion_index\n *\n * \\param replacement_range The fix-it range that must be replaced before the\n * completion at completion_index can be applied\n *\n * \\returns The fix-it string that must replace the code at replacement_range\n * before the completion at completion_index can be applied\n */", :kind "CXCursor_FunctionDecl"} {:args [], :ret {:spelling "unsigned int"}, :function/args [], :symbol "clang_defaultCodeCompleteOptions", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_defaultCodeCompleteOptions, :raw-comment "/**\n * Returns a default set of code-completion options that can be\n * passed to\\c clang_codeCompleteAt().\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "TU", :type "struct CXTranslationUnitImpl *"} {:spelling "complete_filename", :type "const char *"} {:spelling "complete_line", :type "unsigned int"} {:spelling "complete_column", :type "unsigned int"} {:spelling "unsaved_files", :type "struct CXUnsavedFile *"} {:spelling "num_unsaved_files", :type "unsigned int"} {:spelling "options", :type "unsigned int"}], :ret {:spelling "CXCodeCompleteResults *"}, :function/args [[:coffi.mem/pointer :clang/CXTranslationUnitImpl] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :clang/CXUnsavedFile] :coffi.mem/int :coffi.mem/int], :symbol "clang_codeCompleteAt", :function/ret [:coffi.mem/pointer :clang/CXCodeCompleteResults], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_codeCompleteAt, :raw-comment "/**\n * Perform code completion at a given location in a translation unit.\n *\n * This function performs code completion at a particular file, line, and\n * column within source code, providing results that suggest potential\n * code snippets based on the context of the completion. The basic model\n * for code completion is that Clang will parse a complete source file,\n * performing syntax checking up to the location where code-completion has\n * been requested. At that point, a special code-completion token is passed\n * to the parser, which recognizes this token and determines, based on the\n * current location in the C/Objective-C/C++ grammar and the state of\n * semantic analysis, what completions to provide. These completions are\n * returned via a new \\c CXCodeCompleteResults structure.\n *\n * Code completion itself is meant to be triggered by the client when the\n * user types punctuation characters or whitespace, at which point the\n * code-completion location will coincide with the cursor. For example, if \\c p\n * is a pointer, code-completion might be triggered after the \"-\" and then\n * after the \">\" in \\c p->. When the code-completion location is after the \">\",\n * the completion results will provide, e.g., the members of the struct that\n * \"p\" points to. The client is responsible for placing the cursor at the\n * beginning of the token currently being typed, then filtering the results\n * based on the contents of the token. For example, when code-completing for\n * the expression \\c p->get, the client should provide the location just after\n * the \">\" (e.g., pointing at the \"g\") to this code-completion hook. Then, the\n * client can filter the results based on the current token text (\"get\"), only\n * showing those results that start with \"get\". The intent of this interface\n * is to separate the relatively high-latency acquisition of code-completion\n * results from the filtering of results on a per-character basis, which must\n * have a lower latency.\n *\n * \\param TU The translation unit in which code-completion should\n * occur. The source files for this translation unit need not be\n * completely up-to-date (and the contents of those source files may\n * be overridden via \\p unsaved_files). Cursors referring into the\n * translation unit may be invalidated by this invocation.\n *\n * \\param complete_filename The name of the source file where code\n * completion should be performed. This filename may be any file\n * included in the translation unit.\n *\n * \\param complete_line The line at which code-completion should occur.\n *\n * \\param complete_column The column at which code-completion should occur.\n * Note that the column should point just after the syntactic construct that\n * initiated code completion, and not in the middle of a lexical token.\n *\n * \\param unsaved_files the Files that have not yet been saved to disk\n * but may be required for parsing or code completion, including the\n * contents of those files.  The contents and name of these files (as\n * specified by CXUnsavedFile) are copied when necessary, so the\n * client only needs to guarantee their validity until the call to\n * this function returns.\n *\n * \\param num_unsaved_files The number of unsaved file entries in \\p\n * unsaved_files.\n *\n * \\param options Extra options that control the behavior of code\n * completion, expressed as a bitwise OR of the enumerators of the\n * CXCodeComplete_Flags enumeration. The\n * \\c clang_defaultCodeCompleteOptions() function returns a default set\n * of code-completion options.\n *\n * \\returns If successful, a new \\c CXCodeCompleteResults structure\n * containing code-completion results, which should eventually be\n * freed with \\c clang_disposeCodeCompleteResults(). If code\n * completion fails, returns NULL.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "Results", :type "CXCompletionResult *"} {:spelling "NumResults", :type "unsigned int"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clang/CXCompletionResult] :coffi.mem/int], :symbol "clang_sortCodeCompletionResults", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_sortCodeCompletionResults, :raw-comment "/**\n * Sort the code-completion results in case-insensitive alphabetical\n * order.\n *\n * \\param Results The set of results to sort.\n * \\param NumResults The number of results in \\p Results.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "Results", :type "CXCodeCompleteResults *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clang/CXCodeCompleteResults]], :symbol "clang_disposeCodeCompleteResults", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_disposeCodeCompleteResults, :raw-comment "/**\n * Free the given set of code-completion results.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "Results", :type "CXCodeCompleteResults *"}], :ret {:spelling "unsigned int"}, :function/args [[:coffi.mem/pointer :clang/CXCodeCompleteResults]], :symbol "clang_codeCompleteGetNumDiagnostics", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_codeCompleteGetNumDiagnostics, :raw-comment "/**\n * Determine the number of diagnostics produced prior to the\n * location where code completion was performed.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "Results", :type "CXCodeCompleteResults *"} {:spelling "Index", :type "unsigned int"}], :ret {:spelling "void *"}, :function/args [[:coffi.mem/pointer :clang/CXCodeCompleteResults] :coffi.mem/int], :symbol "clang_codeCompleteGetDiagnostic", :function/ret :coffi.mem/pointer, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_codeCompleteGetDiagnostic, :raw-comment "/**\n * Retrieve a diagnostic associated with the given code completion.\n *\n * \\param Results the code completion results to query.\n * \\param Index the zero-based diagnostic number to retrieve.\n *\n * \\returns the requested diagnostic. This diagnostic must be freed\n * via a call to \\c clang_disposeDiagnostic().\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "Results", :type "CXCodeCompleteResults *"}], :ret {:spelling "unsigned long long"}, :function/args [[:coffi.mem/pointer :clang/CXCodeCompleteResults]], :symbol "clang_codeCompleteGetContexts", :function/ret :coffi.mem/long, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_codeCompleteGetContexts, :raw-comment "/**\n * Determines what completions are appropriate for the context\n * the given code completion.\n *\n * \\param Results the code completion results to query\n *\n * \\returns the kinds of completions that are appropriate for use\n * along with the given code completion results.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "Results", :type "CXCodeCompleteResults *"} {:spelling "IsIncomplete", :type "unsigned int *"}], :ret {:spelling "enum CXCursorKind"}, :function/args [[:coffi.mem/pointer :clang/CXCodeCompleteResults] [:coffi.mem/pointer :coffi.mem/int]], :symbol "clang_codeCompleteGetContainerKind", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_codeCompleteGetContainerKind, :raw-comment "/**\n * Returns the cursor kind for the container for the current code\n * completion context. The container is only guaranteed to be set for\n * contexts where a container exists (i.e. member accesses or Objective-C\n * message sends); if there is not a container, this function will return\n * CXCursor_InvalidCode.\n *\n * \\param Results the code completion results to query\n *\n * \\param IsIncomplete on return, this value will be false if Clang has complete\n * information about the container. If Clang does not have complete\n * information, this value will be true.\n *\n * \\returns the container kind, or CXCursor_InvalidCode if there is not a\n * container\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "Results", :type "CXCodeCompleteResults *"}], :ret {:spelling "CXString"}, :function/args [[:coffi.mem/pointer :clang/CXCodeCompleteResults]], :symbol "clang_codeCompleteGetContainerUSR", :function/ret :clang/CXString, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_codeCompleteGetContainerUSR, :raw-comment "/**\n * Returns the USR for the container for the current code completion\n * context. If there is not a container for the current context, this\n * function will return the empty string.\n *\n * \\param Results the code completion results to query\n *\n * \\returns the USR for the container\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "Results", :type "CXCodeCompleteResults *"}], :ret {:spelling "CXString"}, :function/args [[:coffi.mem/pointer :clang/CXCodeCompleteResults]], :symbol "clang_codeCompleteGetObjCSelector", :function/ret :clang/CXString, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_codeCompleteGetObjCSelector, :raw-comment "/**\n * Returns the currently-entered selector for an Objective-C message\n * send, formatted like \"initWithFoo:bar:\". Only guaranteed to return a\n * non-empty string for CXCompletionContext_ObjCInstanceMessage and\n * CXCompletionContext_ObjCClassMessage.\n *\n * \\param Results the code completion results to query\n *\n * \\returns the selector (or partial selector) that has been entered thus far\n * for an Objective-C message send.\n */", :kind "CXCursor_FunctionDecl"} {:args [], :ret {:spelling "CXString"}, :function/args [], :symbol "clang_getClangVersion", :function/ret :clang/CXString, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getClangVersion, :raw-comment "/**\n * Return a version string, suitable for showing to a user, but not\n *        intended to be parsed (the format is not guaranteed to be stable).\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "isEnabled", :type "unsigned int"}], :ret {:spelling "void"}, :function/args [:coffi.mem/int], :symbol "clang_toggleCrashRecovery", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_toggleCrashRecovery, :raw-comment "/**\n * Enable/disable crash recovery.\n *\n * \\param isEnabled Flag to indicate if crash recovery is enabled.  A non-zero\n *        value enables crash recovery, while 0 disables it.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "tu", :type "struct CXTranslationUnitImpl *"} {:spelling "visitor", :type "void (*)(void *, CXSourceLocation *, unsigned int, void *)"} {:spelling "client_data", :type "void *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clang/CXTranslationUnitImpl] [:coffi.ffi/fn [:coffi.mem/pointer [:coffi.mem/pointer :clang/CXSourceLocation] :coffi.mem/int :coffi.mem/pointer] :coffi.mem/void] :coffi.mem/pointer], :symbol "clang_getInclusions", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getInclusions, :raw-comment "/**\n * Visit the set of preprocessor inclusions in a translation unit.\n *   The visitor function is called with the provided data for every included\n *   file.  This does not include headers included by the PCH file (unless one\n *   is inspecting the inclusions in the PCH file itself).\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "C", :type "CXCursor"}], :ret {:spelling "void *"}, :function/args [:clang/CXCursor], :symbol "clang_Cursor_Evaluate", :function/ret :coffi.mem/pointer, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_Cursor_Evaluate, :raw-comment "/**\n * If cursor is a statement declaration tries to evaluate the\n * statement and if its variable, tries to evaluate its initializer,\n * into its corresponding type.\n * If it's an expression, tries to evaluate the expression.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "E", :type "void *"}], :ret {:spelling "CXEvalResultKind"}, :function/args [:coffi.mem/pointer], :symbol "clang_EvalResult_getKind", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_EvalResult_getKind, :raw-comment "/**\n * Returns the kind of the evaluated result.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "E", :type "void *"}], :ret {:spelling "int"}, :function/args [:coffi.mem/pointer], :symbol "clang_EvalResult_getAsInt", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_EvalResult_getAsInt, :raw-comment "/**\n * Returns the evaluation result as integer if the\n * kind is Int.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "E", :type "void *"}], :ret {:spelling "long long"}, :function/args [:coffi.mem/pointer], :symbol "clang_EvalResult_getAsLongLong", :function/ret :coffi.mem/long, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_EvalResult_getAsLongLong, :raw-comment "/**\n * Returns the evaluation result as a long long integer if the\n * kind is Int. This prevents overflows that may happen if the result is\n * returned with clang_EvalResult_getAsInt.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "E", :type "void *"}], :ret {:spelling "unsigned int"}, :function/args [:coffi.mem/pointer], :symbol "clang_EvalResult_isUnsignedInt", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_EvalResult_isUnsignedInt, :raw-comment "/**\n * Returns a non-zero value if the kind is Int and the evaluation\n * result resulted in an unsigned integer.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "E", :type "void *"}], :ret {:spelling "unsigned long long"}, :function/args [:coffi.mem/pointer], :symbol "clang_EvalResult_getAsUnsigned", :function/ret :coffi.mem/long, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_EvalResult_getAsUnsigned, :raw-comment "/**\n * Returns the evaluation result as an unsigned integer if\n * the kind is Int and clang_EvalResult_isUnsignedInt is non-zero.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "E", :type "void *"}], :ret {:spelling "double"}, :function/args [:coffi.mem/pointer], :symbol "clang_EvalResult_getAsDouble", :function/ret :coffi.mem/double, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_EvalResult_getAsDouble, :raw-comment "/**\n * Returns the evaluation result as double if the\n * kind is double.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "E", :type "void *"}], :ret {:spelling "const char *"}, :function/args [:coffi.mem/pointer], :symbol "clang_EvalResult_getAsStr", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_EvalResult_getAsStr, :raw-comment "/**\n * Returns the evaluation result as a constant string if the\n * kind is other than Int or float. User must not free this pointer,\n * instead call clang_EvalResult_dispose on the CXEvalResult returned\n * by clang_Cursor_Evaluate.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "E", :type "void *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/pointer], :symbol "clang_EvalResult_dispose", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_EvalResult_dispose, :raw-comment "/**\n * Disposes the created Eval memory.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "path", :type "const char *"}], :ret {:spelling "void *"}, :function/args [[:coffi.mem/pointer :coffi.mem/char]], :symbol "clang_getRemappings", :function/ret :coffi.mem/pointer, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getRemappings, :raw-comment "/**\n * Retrieve a remapping.\n *\n * \\param path the path that contains metadata about remappings.\n *\n * \\returns the requested remapping. This remapping must be freed\n * via a call to \\c clang_remap_dispose(). Can return NULL if an error occurred.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "filePaths", :type "const char **"} {:spelling "numFiles", :type "unsigned int"}], :ret {:spelling "void *"}, :function/args [[:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]] :coffi.mem/int], :symbol "clang_getRemappingsFromFileList", :function/ret :coffi.mem/pointer, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_getRemappingsFromFileList, :raw-comment "/**\n * Retrieve a remapping.\n *\n * \\param filePaths pointer to an array of file paths containing remapping info.\n *\n * \\param numFiles number of file paths.\n *\n * \\returns the requested remapping. This remapping must be freed\n * via a call to \\c clang_remap_dispose(). Can return NULL if an error occurred.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "", :type "void *"}], :ret {:spelling "unsigned int"}, :function/args [:coffi.mem/pointer], :symbol "clang_remap_getNumFiles", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_remap_getNumFiles, :raw-comment "/**\n * Determine the number of remappings.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "", :type "void *"} {:spelling "index", :type "unsigned int"} {:spelling "original", :type "CXString *"} {:spelling "transformed", :type "CXString *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/pointer :coffi.mem/int [:coffi.mem/pointer :clang/CXString] [:coffi.mem/pointer :clang/CXString]], :symbol "clang_remap_getFilenames", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_remap_getFilenames, :raw-comment "/**\n * Get the original and the associated filename from the remapping.\n *\n * \\param original If non-NULL, will be set to the original filename.\n *\n * \\param transformed If non-NULL, will be set to the filename that the original\n * is associated with.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "", :type "void *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/pointer], :symbol "clang_remap_dispose", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_remap_dispose, :raw-comment "/**\n * Dispose the remapping.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "cursor", :type "CXCursor"} {:spelling "file", :type "void *"} {:spelling "visitor", :type "struct CXCursorAndRangeVisitor"}], :ret {:spelling "CXResult"}, :function/args [:clang/CXCursor :coffi.mem/pointer :clang/CXCursorAndRangeVisitor], :symbol "clang_findReferencesInFile", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_findReferencesInFile, :raw-comment "/**\n * Find references of a declaration in a specific file.\n *\n * \\param cursor pointing to a declaration or a reference of one.\n *\n * \\param file to search for references.\n *\n * \\param visitor callback that will receive pairs of CXCursor/CXSourceRange for\n * each reference found.\n * The CXSourceRange will point inside the file; if the reference is inside\n * a macro (and not a macro argument) the CXSourceRange will be invalid.\n *\n * \\returns one of the CXResult enumerators.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "TU", :type "struct CXTranslationUnitImpl *"} {:spelling "file", :type "void *"} {:spelling "visitor", :type "struct CXCursorAndRangeVisitor"}], :ret {:spelling "CXResult"}, :function/args [[:coffi.mem/pointer :clang/CXTranslationUnitImpl] :coffi.mem/pointer :clang/CXCursorAndRangeVisitor], :symbol "clang_findIncludesInFile", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_findIncludesInFile, :raw-comment "/**\n * Find #import/#include directives in a specific file.\n *\n * \\param TU translation unit containing the file to query.\n *\n * \\param file to search for #import/#include directives.\n *\n * \\param visitor callback that will receive pairs of CXCursor/CXSourceRange for\n * each directive found.\n *\n * \\returns one of the CXResult enumerators.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "", :type "CXCursor"} {:spelling "", :type "void *"} {:spelling "", :type "enum CXVisitorResult (^)(CXCursor, CXSourceRange)"}], :ret {:spelling "CXResult"}, :function/args [:clang/CXCursor :coffi.mem/pointer [:coffi.mem/pointer]], :symbol "clang_findReferencesInFileWithBlock", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_findReferencesInFileWithBlock, :raw-comment nil, :kind "CXCursor_FunctionDecl"} {:args [{:spelling "", :type "struct CXTranslationUnitImpl *"} {:spelling "", :type "void *"} {:spelling "", :type "enum CXVisitorResult (^)(CXCursor, CXSourceRange)"}], :ret {:spelling "CXResult"}, :function/args [[:coffi.mem/pointer :clang/CXTranslationUnitImpl] :coffi.mem/pointer [:coffi.mem/pointer]], :symbol "clang_findIncludesInFileWithBlock", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_findIncludesInFileWithBlock, :raw-comment nil, :kind "CXCursor_FunctionDecl"} {:args [{:spelling "", :type "CXIdxEntityKind"}], :ret {:spelling "int"}, :function/args [:coffi.mem/int], :symbol "clang_index_isEntityObjCContainerKind", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_index_isEntityObjCContainerKind, :raw-comment nil, :kind "CXCursor_FunctionDecl"} {:args [{:spelling "", :type "const CXIdxDeclInfo *"}], :ret {:spelling "const CXIdxObjCContainerDeclInfo *"}, :function/args [[:coffi.mem/pointer :clang/CXIdxDeclInfo]], :symbol "clang_index_getObjCContainerDeclInfo", :function/ret [:coffi.mem/pointer :clang/CXIdxObjCContainerDeclInfo], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_index_getObjCContainerDeclInfo, :raw-comment nil, :kind "CXCursor_FunctionDecl"} {:args [{:spelling "", :type "const CXIdxDeclInfo *"}], :ret {:spelling "const CXIdxObjCInterfaceDeclInfo *"}, :function/args [[:coffi.mem/pointer :clang/CXIdxDeclInfo]], :symbol "clang_index_getObjCInterfaceDeclInfo", :function/ret [:coffi.mem/pointer :clang/CXIdxObjCInterfaceDeclInfo], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_index_getObjCInterfaceDeclInfo, :raw-comment nil, :kind "CXCursor_FunctionDecl"} {:args [{:spelling "", :type "const CXIdxDeclInfo *"}], :ret {:spelling "const CXIdxObjCCategoryDeclInfo *"}, :function/args [[:coffi.mem/pointer :clang/CXIdxDeclInfo]], :symbol "clang_index_getObjCCategoryDeclInfo", :function/ret [:coffi.mem/pointer :clang/CXIdxObjCCategoryDeclInfo], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_index_getObjCCategoryDeclInfo, :raw-comment nil, :kind "CXCursor_FunctionDecl"} {:args [{:spelling "", :type "const CXIdxDeclInfo *"}], :ret {:spelling "const CXIdxObjCProtocolRefListInfo *"}, :function/args [[:coffi.mem/pointer :clang/CXIdxDeclInfo]], :symbol "clang_index_getObjCProtocolRefListInfo", :function/ret [:coffi.mem/pointer :clang/CXIdxObjCProtocolRefListInfo], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_index_getObjCProtocolRefListInfo, :raw-comment nil, :kind "CXCursor_FunctionDecl"} {:args [{:spelling "", :type "const CXIdxDeclInfo *"}], :ret {:spelling "const CXIdxObjCPropertyDeclInfo *"}, :function/args [[:coffi.mem/pointer :clang/CXIdxDeclInfo]], :symbol "clang_index_getObjCPropertyDeclInfo", :function/ret [:coffi.mem/pointer :clang/CXIdxObjCPropertyDeclInfo], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_index_getObjCPropertyDeclInfo, :raw-comment nil, :kind "CXCursor_FunctionDecl"} {:args [{:spelling "", :type "const CXIdxAttrInfo *"}], :ret {:spelling "const CXIdxIBOutletCollectionAttrInfo *"}, :function/args [[:coffi.mem/pointer :clang/CXIdxAttrInfo]], :symbol "clang_index_getIBOutletCollectionAttrInfo", :function/ret [:coffi.mem/pointer :clang/CXIdxIBOutletCollectionAttrInfo], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_index_getIBOutletCollectionAttrInfo, :raw-comment nil, :kind "CXCursor_FunctionDecl"} {:args [{:spelling "", :type "const CXIdxDeclInfo *"}], :ret {:spelling "const CXIdxCXXClassDeclInfo *"}, :function/args [[:coffi.mem/pointer :clang/CXIdxDeclInfo]], :symbol "clang_index_getCXXClassDeclInfo", :function/ret [:coffi.mem/pointer :clang/CXIdxCXXClassDeclInfo], :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_index_getCXXClassDeclInfo, :raw-comment nil, :kind "CXCursor_FunctionDecl"} {:args [{:spelling "", :type "const CXIdxContainerInfo *"}], :ret {:spelling "void *"}, :function/args [[:coffi.mem/pointer :clang/CXIdxContainerInfo]], :symbol "clang_index_getClientContainer", :function/ret :coffi.mem/pointer, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_index_getClientContainer, :raw-comment "/**\n * For retrieving a custom CXIdxClientContainer attached to a\n * container.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "", :type "const CXIdxContainerInfo *"} {:spelling "", :type "void *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clang/CXIdxContainerInfo] :coffi.mem/pointer], :symbol "clang_index_setClientContainer", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_index_setClientContainer, :raw-comment "/**\n * For setting a custom CXIdxClientContainer attached to a\n * container.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "", :type "const CXIdxEntityInfo *"}], :ret {:spelling "void *"}, :function/args [[:coffi.mem/pointer :clang/CXIdxEntityInfo]], :symbol "clang_index_getClientEntity", :function/ret :coffi.mem/pointer, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_index_getClientEntity, :raw-comment "/**\n * For retrieving a custom CXIdxClientEntity attached to an entity.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "", :type "const CXIdxEntityInfo *"} {:spelling "", :type "void *"}], :ret {:spelling "void"}, :function/args [[:coffi.mem/pointer :clang/CXIdxEntityInfo] :coffi.mem/pointer], :symbol "clang_index_setClientEntity", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_index_setClientEntity, :raw-comment "/**\n * For setting a custom CXIdxClientEntity attached to an entity.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "CIdx", :type "void *"}], :ret {:spelling "void *"}, :function/args [:coffi.mem/pointer], :symbol "clang_IndexAction_create", :function/ret :coffi.mem/pointer, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_IndexAction_create, :raw-comment "/**\n * An indexing action/session, to be applied to one or multiple\n * translation units.\n *\n * \\param CIdx The index object with which the index action will be associated.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "", :type "void *"}], :ret {:spelling "void"}, :function/args [:coffi.mem/pointer], :symbol "clang_IndexAction_dispose", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_IndexAction_dispose, :raw-comment "/**\n * Destroy the given index action.\n *\n * The index action must not be destroyed until all of the translation units\n * created within that index action have been destroyed.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "", :type "void *"} {:spelling "client_data", :type "void *"} {:spelling "index_callbacks", :type "IndexerCallbacks *"} {:spelling "index_callbacks_size", :type "unsigned int"} {:spelling "index_options", :type "unsigned int"} {:spelling "source_filename", :type "const char *"} {:spelling "command_line_args", :type "const char *const *"} {:spelling "num_command_line_args", :type "int"} {:spelling "unsaved_files", :type "struct CXUnsavedFile *"} {:spelling "num_unsaved_files", :type "unsigned int"} {:spelling "out_TU", :type "struct CXTranslationUnitImpl **"} {:spelling "TU_options", :type "unsigned int"}], :ret {:spelling "int"}, :function/args [:coffi.mem/pointer :coffi.mem/pointer [:coffi.mem/pointer :clang/IndexerCallbacks] :coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]] :coffi.mem/int [:coffi.mem/pointer :clang/CXUnsavedFile] :coffi.mem/int [:coffi.mem/pointer [:coffi.mem/pointer :clang/CXTranslationUnitImpl]] :coffi.mem/int], :symbol "clang_indexSourceFile", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_indexSourceFile, :raw-comment "/**\n * Index the given source file and the translation unit corresponding\n * to that file via callbacks implemented through #IndexerCallbacks.\n *\n * \\param client_data pointer data supplied by the client, which will\n * be passed to the invoked callbacks.\n *\n * \\param index_callbacks Pointer to indexing callbacks that the client\n * implements.\n *\n * \\param index_callbacks_size Size of #IndexerCallbacks structure that gets\n * passed in index_callbacks.\n *\n * \\param index_options A bitmask of options that affects how indexing is\n * performed. This should be a bitwise OR of the CXIndexOpt_XXX flags.\n *\n * \\param[out] out_TU pointer to store a \\c CXTranslationUnit that can be\n * reused after indexing is finished. Set to \\c NULL if you do not require it.\n *\n * \\returns 0 on success or if there were errors from which the compiler could\n * recover.  If there is a failure from which there is no recovery, returns\n * a non-zero \\c CXErrorCode.\n *\n * The rest of the parameters are the same as #clang_parseTranslationUnit.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "", :type "void *"} {:spelling "client_data", :type "void *"} {:spelling "index_callbacks", :type "IndexerCallbacks *"} {:spelling "index_callbacks_size", :type "unsigned int"} {:spelling "index_options", :type "unsigned int"} {:spelling "source_filename", :type "const char *"} {:spelling "command_line_args", :type "const char *const *"} {:spelling "num_command_line_args", :type "int"} {:spelling "unsaved_files", :type "struct CXUnsavedFile *"} {:spelling "num_unsaved_files", :type "unsigned int"} {:spelling "out_TU", :type "struct CXTranslationUnitImpl **"} {:spelling "TU_options", :type "unsigned int"}], :ret {:spelling "int"}, :function/args [:coffi.mem/pointer :coffi.mem/pointer [:coffi.mem/pointer :clang/IndexerCallbacks] :coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]] :coffi.mem/int [:coffi.mem/pointer :clang/CXUnsavedFile] :coffi.mem/int [:coffi.mem/pointer [:coffi.mem/pointer :clang/CXTranslationUnitImpl]] :coffi.mem/int], :symbol "clang_indexSourceFileFullArgv", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_indexSourceFileFullArgv, :raw-comment "/**\n * Same as clang_indexSourceFile but requires a full command line\n * for \\c command_line_args including argv[0]. This is useful if the standard\n * library paths are relative to the binary.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "", :type "void *"} {:spelling "client_data", :type "void *"} {:spelling "index_callbacks", :type "IndexerCallbacks *"} {:spelling "index_callbacks_size", :type "unsigned int"} {:spelling "index_options", :type "unsigned int"} {:spelling "", :type "struct CXTranslationUnitImpl *"}], :ret {:spelling "int"}, :function/args [:coffi.mem/pointer :coffi.mem/pointer [:coffi.mem/pointer :clang/IndexerCallbacks] :coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :clang/CXTranslationUnitImpl]], :symbol "clang_indexTranslationUnit", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_indexTranslationUnit, :raw-comment "/**\n * Index the given translation unit via callbacks implemented through\n * #IndexerCallbacks.\n *\n * The order of callback invocations is not guaranteed to be the same as\n * when indexing a source file. The high level order will be:\n *\n *   -Preprocessor callbacks invocations\n *   -Declaration/reference callbacks invocations\n *   -Diagnostic callback invocations\n *\n * The parameters are the same as #clang_indexSourceFile.\n *\n * \\returns If there is a failure from which there is no recovery, returns\n * non-zero, otherwise returns 0.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "loc", :type "CXIdxLoc"} {:spelling "indexFile", :type "void **"} {:spelling "file", :type "void **"} {:spelling "line", :type "unsigned int *"} {:spelling "column", :type "unsigned int *"} {:spelling "offset", :type "unsigned int *"}], :ret {:spelling "void"}, :function/args [:clang/CXIdxLoc [:coffi.mem/pointer :coffi.mem/pointer] [:coffi.mem/pointer :coffi.mem/pointer] [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :coffi.mem/int]], :symbol "clang_indexLoc_getFileLocation", :function/ret :coffi.mem/void, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_indexLoc_getFileLocation, :raw-comment "/**\n * Retrieve the CXIdxFile, file, line, column, and offset represented by\n * the given CXIdxLoc.\n *\n * If the location refers into a macro expansion, retrieves the\n * location of the macro expansion and if it refers into a macro argument\n * retrieves the location of the argument.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "loc", :type "CXIdxLoc"}], :ret {:spelling "CXSourceLocation"}, :function/args [:clang/CXIdxLoc], :symbol "clang_indexLoc_getCXSourceLocation", :function/ret :clang/CXSourceLocation, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_indexLoc_getCXSourceLocation, :raw-comment "/**\n * Retrieve the CXSourceLocation represented by the given CXIdxLoc.\n */", :kind "CXCursor_FunctionDecl"} {:args [{:spelling "T", :type "CXType"} {:spelling "visitor", :type "enum CXVisitorResult (*)(CXCursor, void *)"} {:spelling "client_data", :type "void *"}], :ret {:spelling "unsigned int"}, :function/args [:clang/CXType [:coffi.ffi/fn [:clang/CXCursor :coffi.mem/pointer] :coffi.mem/int] :coffi.mem/pointer], :symbol "clang_Type_visitFields", :function/ret :coffi.mem/int, :type "CXType_FunctionProto", :linkage "CXLinkage_External", :id :clang_Type_visitFields, :raw-comment "/**\n * Visit the fields of a particular type.\n *\n * This function visits all the direct fields of the given cursor,\n * invoking the given \\p visitor function with the cursors of each\n * visited field. The traversal may be ended prematurely, if\n * the visitor returns \\c CXFieldVisit_Break.\n *\n * \\param T the record type whose field may be visited.\n *\n * \\param visitor the visitor function that will be invoked for each\n * field of \\p T.\n *\n * \\param client_data pointer data supplied by the client, which will\n * be passed to the visitor each time it is invoked.\n *\n * \\returns a non-zero value if the traversal was terminated\n * prematurely by the visitor returning \\c CXFieldVisit_Break.\n */", :kind "CXCursor_FunctionDecl"}), :structs ({:kind "CXCursor_StructDecl", :type "CXType_Record", :id :clang/CXIdxObjCContainerDeclInfo, :spelling "CXIdxObjCContainerDeclInfo", :size-in-bytes 16, :fields [{:type "const CXIdxDeclInfo *", :datatype [:coffi.mem/pointer :clang/CXIdxDeclInfo], :name "declInfo", :calculated-offset 0} {:type "CXIdxObjCContainerKind", :datatype :coffi.mem/int, :name "kind", :calculated-offset 64}]} {:kind "CXCursor_StructDecl", :type "CXType_Record", :id :clang/CXVersion, :spelling "struct CXVersion", :size-in-bytes 12, :fields [{:type "int", :datatype :coffi.mem/int, :name "Major", :calculated-offset 0} {:type "int", :datatype :coffi.mem/int, :name "Minor", :calculated-offset 32} {:type "int", :datatype :coffi.mem/int, :name "Subminor", :calculated-offset 64}]} {:kind "CXCursor_StructDecl", :type "CXType_Record", :id :clang/CXSourceRangeList, :spelling "CXSourceRangeList", :size-in-bytes 16, :fields [{:type "unsigned int", :datatype :coffi.mem/int, :name "count", :calculated-offset 0} {:type "CXSourceRange *", :datatype [:coffi.mem/pointer :clang/CXSourceRange], :name "ranges", :calculated-offset 64}]} {:kind "CXCursor_StructDecl", :type "CXType_Record", :id :clang/CXVirtualFileOverlayImpl, :spelling "struct CXVirtualFileOverlayImpl", :size-in-bytes -2, :fields []} {:kind "CXCursor_StructDecl", :type "CXType_Record", :id :clang/CXCursorSetImpl, :spelling "struct CXCursorSetImpl", :size-in-bytes -2, :fields []} {:kind "CXCursor_StructDecl", :type "CXType_Record", :id :clang/CXTUResourceUsage, :spelling "struct CXTUResourceUsage", :size-in-bytes 24, :fields [{:type "void *", :datatype :coffi.mem/pointer, :name "data", :calculated-offset 0} {:type "unsigned int", :datatype :coffi.mem/int, :name "numEntries", :calculated-offset 64} {:type "struct CXTUResourceUsageEntry *", :datatype [:coffi.mem/pointer :clang/CXTUResourceUsageEntry], :name "entries", :calculated-offset 128}]} {:kind "CXCursor_StructDecl", :type "CXType_Record", :id :clang/CXSourceRange, :spelling "CXSourceRange", :size-in-bytes 24, :fields [{:type "const void *[2]", :datatype [:coffi.mem/array :coffi.mem/pointer 2], :name "ptr_data", :calculated-offset 0} {:type "unsigned int", :datatype :coffi.mem/int, :name "begin_int_data", :calculated-offset 128} {:type "unsigned int", :datatype :coffi.mem/int, :name "end_int_data", :calculated-offset 160}]} {:kind "CXCursor_StructDecl", :type "CXType_Record", :id :clang/CXString, :spelling "CXString", :size-in-bytes 16, :fields [{:type "const void *", :datatype :coffi.mem/pointer, :name "data", :calculated-offset 0} {:type "unsigned int", :datatype :coffi.mem/int, :name "private_flags", :calculated-offset 64}]} {:kind "CXCursor_StructDecl", :type "CXType_Record", :id :clang/CXPlatformAvailability, :spelling "struct CXPlatformAvailability", :size-in-bytes 72, :fields [{:type "CXString", :datatype :clang/CXString, :name "Platform", :calculated-offset 0} {:type "struct CXVersion", :datatype :clang/CXVersion, :name "Introduced", :calculated-offset 128} {:type "struct CXVersion", :datatype :clang/CXVersion, :name "Deprecated", :calculated-offset 224} {:type "struct CXVersion", :datatype :clang/CXVersion, :name "Obsoleted", :calculated-offset 320} {:type "int", :datatype :coffi.mem/int, :name "Unavailable", :calculated-offset 416} {:type "CXString", :datatype :clang/CXString, :name "Message", :calculated-offset 448}]} {:kind "CXCursor_StructDecl", :type "CXType_Record", :id :clang/CXToken, :spelling "CXToken", :size-in-bytes 24, :fields [{:type "unsigned int [4]", :datatype [:coffi.mem/array :coffi.mem/int 4], :name "int_data", :calculated-offset 0} {:type "void *", :datatype :coffi.mem/pointer, :name "ptr_data", :calculated-offset 128}]} {:kind "CXCursor_StructDecl", :type "CXType_Record", :id :clang/CXIdxObjCProtocolRefListInfo, :spelling "CXIdxObjCProtocolRefListInfo", :size-in-bytes 16, :fields [{:type "const CXIdxObjCProtocolRefInfo *const *", :datatype [:coffi.mem/pointer [:coffi.mem/pointer :clang/CXIdxObjCProtocolRefInfo]], :name "protocols", :calculated-offset 0} {:type "unsigned int", :datatype :coffi.mem/int, :name "numProtocols", :calculated-offset 64}]} {:kind "CXCursor_StructDecl", :type "CXType_Record", :id :clang/CXStringSet, :spelling "CXStringSet", :size-in-bytes 16, :fields [{:type "CXString *", :datatype [:coffi.mem/pointer :clang/CXString], :name "Strings", :calculated-offset 0} {:type "unsigned int", :datatype :coffi.mem/int, :name "Count", :calculated-offset 64}]} {:kind "CXCursor_StructDecl", :type "CXType_Record", :id :clang/CXTUResourceUsageEntry, :spelling "struct CXTUResourceUsageEntry", :size-in-bytes 16, :fields [{:type "enum CXTUResourceUsageKind", :datatype :coffi.mem/int, :name "kind", :calculated-offset 0} {:type "unsigned long", :datatype :coffi.mem/long, :name "amount", :calculated-offset 64}]} {:kind "CXCursor_StructDecl", :type "CXType_Record", :id :clang/CXModuleMapDescriptorImpl, :spelling "struct CXModuleMapDescriptorImpl", :size-in-bytes -2, :fields []} {:kind "CXCursor_StructDecl", :type "CXType_Record", :id :clang/IndexerCallbacks, :spelling "IndexerCallbacks", :size-in-bytes 64, :fields [{:type "int (*)(void *, void *)", :datatype [:coffi.ffi/fn [:coffi.mem/pointer :coffi.mem/pointer] :coffi.mem/int], :name "abortQuery", :calculated-offset 0} {:type "void (*)(void *, void *, void *)", :datatype [:coffi.ffi/fn [:coffi.mem/pointer :coffi.mem/pointer :coffi.mem/pointer] :coffi.mem/void], :name "diagnostic", :calculated-offset 64} {:type "void *(*)(void *, void *, void *)", :datatype [:coffi.ffi/fn [:coffi.mem/pointer :coffi.mem/pointer :coffi.mem/pointer] :coffi.mem/pointer], :name "enteredMainFile", :calculated-offset 128} {:type "void *(*)(void *, const CXIdxIncludedFileInfo *)", :datatype [:coffi.ffi/fn [:coffi.mem/pointer [:coffi.mem/pointer :clang/CXIdxIncludedFileInfo]] :coffi.mem/pointer], :name "ppIncludedFile", :calculated-offset 192} {:type "void *(*)(void *, const CXIdxImportedASTFileInfo *)", :datatype [:coffi.ffi/fn [:coffi.mem/pointer [:coffi.mem/pointer :clang/CXIdxImportedASTFileInfo]] :coffi.mem/pointer], :name "importedASTFile", :calculated-offset 256} {:type "void *(*)(void *, void *)", :datatype [:coffi.ffi/fn [:coffi.mem/pointer :coffi.mem/pointer] :coffi.mem/pointer], :name "startedTranslationUnit", :calculated-offset 320} {:type "void (*)(void *, const CXIdxDeclInfo *)", :datatype [:coffi.ffi/fn [:coffi.mem/pointer [:coffi.mem/pointer :clang/CXIdxDeclInfo]] :coffi.mem/void], :name "indexDeclaration", :calculated-offset 384} {:type "void (*)(void *, const CXIdxEntityRefInfo *)", :datatype [:coffi.ffi/fn [:coffi.mem/pointer [:coffi.mem/pointer :clang/CXIdxEntityRefInfo]] :coffi.mem/void], :name "indexEntityReference", :calculated-offset 448}]} {:kind "CXCursor_StructDecl", :type "CXType_Record", :id :clang/CXIdxObjCPropertyDeclInfo, :spelling "CXIdxObjCPropertyDeclInfo", :size-in-bytes 24, :fields [{:type "const CXIdxDeclInfo *", :datatype [:coffi.mem/pointer :clang/CXIdxDeclInfo], :name "declInfo", :calculated-offset 0} {:type "const CXIdxEntityInfo *", :datatype [:coffi.mem/pointer :clang/CXIdxEntityInfo], :name "getter", :calculated-offset 64} {:type "const CXIdxEntityInfo *", :datatype [:coffi.mem/pointer :clang/CXIdxEntityInfo], :name "setter", :calculated-offset 128}]} {:kind "CXCursor_StructDecl", :type "CXType_Record", :id :clang/CXIdxLoc, :spelling "CXIdxLoc", :size-in-bytes 24, :fields [{:type "void *[2]", :datatype [:coffi.mem/array :coffi.mem/pointer 2], :name "ptr_data", :calculated-offset 0} {:type "unsigned int", :datatype :coffi.mem/int, :name "int_data", :calculated-offset 128}]} {:kind "CXCursor_StructDecl", :type "CXType_Record", :id :clang/CXIdxImportedASTFileInfo, :spelling "CXIdxImportedASTFileInfo", :size-in-bytes 48, :fields [{:type "void *", :datatype :coffi.mem/pointer, :name "file", :calculated-offset 0} {:type "void *", :datatype :coffi.mem/pointer, :name "module", :calculated-offset 64} {:type "CXIdxLoc", :datatype :clang/CXIdxLoc, :name "loc", :calculated-offset 128} {:type "int", :datatype :coffi.mem/int, :name "isImplicit", :calculated-offset 320}]} {:kind "CXCursor_StructDecl", :type "CXType_Record", :id :clang/CXCursorAndRangeVisitor, :spelling "struct CXCursorAndRangeVisitor", :size-in-bytes 16, :fields [{:type "void *", :datatype :coffi.mem/pointer, :name "context", :calculated-offset 0} {:type "enum CXVisitorResult (*)(void *, CXCursor, CXSourceRange)", :datatype [:coffi.ffi/fn [:coffi.mem/pointer :clang/CXCursor :clang/CXSourceRange] :coffi.mem/int], :name "visit", :calculated-offset 64}]} {:kind "CXCursor_StructDecl", :type "CXType_Record", :id :clang/CXType, :spelling "CXType", :size-in-bytes 24, :fields [{:type "enum CXTypeKind", :datatype :coffi.mem/int, :name "kind", :calculated-offset 0} {:type "void *[2]", :datatype [:coffi.mem/array :coffi.mem/pointer 2], :name "data", :calculated-offset 64}]} {:kind "CXCursor_StructDecl", :type "CXType_Record", :id :clang/CXCodeCompleteResults, :spelling "CXCodeCompleteResults", :size-in-bytes 16, :fields [{:type "CXCompletionResult *", :datatype [:coffi.mem/pointer :clang/CXCompletionResult], :name "Results", :calculated-offset 0} {:type "unsigned int", :datatype :coffi.mem/int, :name "NumResults", :calculated-offset 64}]} {:kind "CXCursor_StructDecl", :type "CXType_Record", :id :clang/CXCursor, :spelling "CXCursor", :size-in-bytes 32, :fields [{:type "enum CXCursorKind", :datatype :coffi.mem/int, :name "kind", :calculated-offset 0} {:type "int", :datatype :coffi.mem/int, :name "xdata", :calculated-offset 32} {:type "const void *[3]", :datatype [:coffi.mem/array :coffi.mem/pointer 3], :name "data", :calculated-offset 64}]} {:kind "CXCursor_StructDecl", :type "CXType_Record", :id :clang/CXIdxEntityInfo, :spelling "CXIdxEntityInfo", :size-in-bytes 80, :fields [{:type "CXIdxEntityKind", :datatype :coffi.mem/int, :name "kind", :calculated-offset 0} {:type "CXIdxEntityCXXTemplateKind", :datatype :coffi.mem/int, :name "templateKind", :calculated-offset 32} {:type "CXIdxEntityLanguage", :datatype :coffi.mem/int, :name "lang", :calculated-offset 64} {:type "const char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "name", :calculated-offset 128} {:type "const char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "USR", :calculated-offset 192} {:type "CXCursor", :datatype :clang/CXCursor, :name "cursor", :calculated-offset 256} {:type "const CXIdxAttrInfo *const *", :datatype [:coffi.mem/pointer [:coffi.mem/pointer :clang/CXIdxAttrInfo]], :name "attributes", :calculated-offset 512} {:type "unsigned int", :datatype :coffi.mem/int, :name "numAttributes", :calculated-offset 576}]} {:kind "CXCursor_StructDecl", :type "CXType_Record", :id :clang/CXIdxContainerInfo, :spelling "CXIdxContainerInfo", :size-in-bytes 32, :fields [{:type "CXCursor", :datatype :clang/CXCursor, :name "cursor", :calculated-offset 0}]} {:kind "CXCursor_StructDecl", :type "CXType_Record", :id :clang/CXIdxObjCCategoryDeclInfo, :spelling "CXIdxObjCCategoryDeclInfo", :size-in-bytes 80, :fields [{:type "const CXIdxObjCContainerDeclInfo *", :datatype [:coffi.mem/pointer :clang/CXIdxObjCContainerDeclInfo], :name "containerInfo", :calculated-offset 0} {:type "const CXIdxEntityInfo *", :datatype [:coffi.mem/pointer :clang/CXIdxEntityInfo], :name "objcClass", :calculated-offset 64} {:type "CXCursor", :datatype :clang/CXCursor, :name "classCursor", :calculated-offset 128} {:type "CXIdxLoc", :datatype :clang/CXIdxLoc, :name "classLoc", :calculated-offset 384} {:type "const CXIdxObjCProtocolRefListInfo *", :datatype [:coffi.mem/pointer :clang/CXIdxObjCProtocolRefListInfo], :name "protocols", :calculated-offset 576}]} {:kind "CXCursor_StructDecl", :type "CXType_Record", :id :clang/CXIdxDeclInfo, :spelling "CXIdxDeclInfo", :size-in-bytes 128, :fields [{:type "const CXIdxEntityInfo *", :datatype [:coffi.mem/pointer :clang/CXIdxEntityInfo], :name "entityInfo", :calculated-offset 0} {:type "CXCursor", :datatype :clang/CXCursor, :name "cursor", :calculated-offset 64} {:type "CXIdxLoc", :datatype :clang/CXIdxLoc, :name "loc", :calculated-offset 320} {:type "const CXIdxContainerInfo *", :datatype [:coffi.mem/pointer :clang/CXIdxContainerInfo], :name "semanticContainer", :calculated-offset 512} {:type "const CXIdxContainerInfo *", :datatype [:coffi.mem/pointer :clang/CXIdxContainerInfo], :name "lexicalContainer", :calculated-offset 576} {:type "int", :datatype :coffi.mem/int, :name "isRedeclaration", :calculated-offset 640} {:type "int", :datatype :coffi.mem/int, :name "isDefinition", :calculated-offset 672} {:type "int", :datatype :coffi.mem/int, :name "isContainer", :calculated-offset 704} {:type "const CXIdxContainerInfo *", :datatype [:coffi.mem/pointer :clang/CXIdxContainerInfo], :name "declAsContainer", :calculated-offset 768} {:type "int", :datatype :coffi.mem/int, :name "isImplicit", :calculated-offset 832} {:type "const CXIdxAttrInfo *const *", :datatype [:coffi.mem/pointer [:coffi.mem/pointer :clang/CXIdxAttrInfo]], :name "attributes", :calculated-offset 896} {:type "unsigned int", :datatype :coffi.mem/int, :name "numAttributes", :calculated-offset 960} {:type "unsigned int", :datatype :coffi.mem/int, :name "flags", :calculated-offset 992}]} {:kind "CXCursor_StructDecl", :type "CXType_Record", :id :clang/CXIdxEntityRefInfo, :spelling "CXIdxEntityRefInfo", :size-in-bytes 96, :fields [{:type "CXIdxEntityRefKind", :datatype :coffi.mem/int, :name "kind", :calculated-offset 0} {:type "CXCursor", :datatype :clang/CXCursor, :name "cursor", :calculated-offset 64} {:type "CXIdxLoc", :datatype :clang/CXIdxLoc, :name "loc", :calculated-offset 320} {:type "const CXIdxEntityInfo *", :datatype [:coffi.mem/pointer :clang/CXIdxEntityInfo], :name "referencedEntity", :calculated-offset 512} {:type "const CXIdxEntityInfo *", :datatype [:coffi.mem/pointer :clang/CXIdxEntityInfo], :name "parentEntity", :calculated-offset 576} {:type "const CXIdxContainerInfo *", :datatype [:coffi.mem/pointer :clang/CXIdxContainerInfo], :name "container", :calculated-offset 640} {:type "CXSymbolRole", :datatype :coffi.mem/int, :name "role", :calculated-offset 704}]} {:kind "CXCursor_StructDecl", :type "CXType_Record", :id :clang/CXIdxIBOutletCollectionAttrInfo, :spelling "CXIdxIBOutletCollectionAttrInfo", :size-in-bytes 72, :fields [{:type "const CXIdxAttrInfo *", :datatype [:coffi.mem/pointer :clang/CXIdxAttrInfo], :name "attrInfo", :calculated-offset 0} {:type "const CXIdxEntityInfo *", :datatype [:coffi.mem/pointer :clang/CXIdxEntityInfo], :name "objcClass", :calculated-offset 64} {:type "CXCursor", :datatype :clang/CXCursor, :name "classCursor", :calculated-offset 128} {:type "CXIdxLoc", :datatype :clang/CXIdxLoc, :name "classLoc", :calculated-offset 384}]} {:kind "CXCursor_StructDecl", :type "CXType_Record", :id :clang/CXIdxAttrInfo, :spelling "CXIdxAttrInfo", :size-in-bytes 64, :fields [{:type "CXIdxAttrKind", :datatype :coffi.mem/int, :name "kind", :calculated-offset 0} {:type "CXCursor", :datatype :clang/CXCursor, :name "cursor", :calculated-offset 64} {:type "CXIdxLoc", :datatype :clang/CXIdxLoc, :name "loc", :calculated-offset 320}]} {:kind "CXCursor_StructDecl", :type "CXType_Record", :id :clang/CXIdxBaseClassInfo, :spelling "CXIdxBaseClassInfo", :size-in-bytes 64, :fields [{:type "const CXIdxEntityInfo *", :datatype [:coffi.mem/pointer :clang/CXIdxEntityInfo], :name "base", :calculated-offset 0} {:type "CXCursor", :datatype :clang/CXCursor, :name "cursor", :calculated-offset 64} {:type "CXIdxLoc", :datatype :clang/CXIdxLoc, :name "loc", :calculated-offset 320}]} {:kind "CXCursor_StructDecl", :type "CXType_Record", :id :clang/CXIdxObjCInterfaceDeclInfo, :spelling "CXIdxObjCInterfaceDeclInfo", :size-in-bytes 24, :fields [{:type "const CXIdxObjCContainerDeclInfo *", :datatype [:coffi.mem/pointer :clang/CXIdxObjCContainerDeclInfo], :name "containerInfo", :calculated-offset 0} {:type "const CXIdxBaseClassInfo *", :datatype [:coffi.mem/pointer :clang/CXIdxBaseClassInfo], :name "superInfo", :calculated-offset 64} {:type "const CXIdxObjCProtocolRefListInfo *", :datatype [:coffi.mem/pointer :clang/CXIdxObjCProtocolRefListInfo], :name "protocols", :calculated-offset 128}]} {:kind "CXCursor_StructDecl", :type "CXType_Record", :id :clang/CXIdxObjCProtocolRefInfo, :spelling "CXIdxObjCProtocolRefInfo", :size-in-bytes 64, :fields [{:type "const CXIdxEntityInfo *", :datatype [:coffi.mem/pointer :clang/CXIdxEntityInfo], :name "protocol", :calculated-offset 0} {:type "CXCursor", :datatype :clang/CXCursor, :name "cursor", :calculated-offset 64} {:type "CXIdxLoc", :datatype :clang/CXIdxLoc, :name "loc", :calculated-offset 320}]} {:kind "CXCursor_StructDecl", :type "CXType_Record", :id :clang/CXIdxIncludedFileInfo, :spelling "CXIdxIncludedFileInfo", :size-in-bytes 56, :fields [{:type "CXIdxLoc", :datatype :clang/CXIdxLoc, :name "hashLoc", :calculated-offset 0} {:type "const char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "filename", :calculated-offset 192} {:type "void *", :datatype :coffi.mem/pointer, :name "file", :calculated-offset 256} {:type "int", :datatype :coffi.mem/int, :name "isImport", :calculated-offset 320} {:type "int", :datatype :coffi.mem/int, :name "isAngled", :calculated-offset 352} {:type "int", :datatype :coffi.mem/int, :name "isModuleImport", :calculated-offset 384}]} {:kind "CXCursor_StructDecl", :type "CXType_Record", :id :clang/CXIdxCXXClassDeclInfo, :spelling "CXIdxCXXClassDeclInfo", :size-in-bytes 24, :fields [{:type "const CXIdxDeclInfo *", :datatype [:coffi.mem/pointer :clang/CXIdxDeclInfo], :name "declInfo", :calculated-offset 0} {:type "const CXIdxBaseClassInfo *const *", :datatype [:coffi.mem/pointer [:coffi.mem/pointer :clang/CXIdxBaseClassInfo]], :name "bases", :calculated-offset 64} {:type "unsigned int", :datatype :coffi.mem/int, :name "numBases", :calculated-offset 128}]} {:kind "CXCursor_StructDecl", :type "CXType_Record", :id :clang/CXCompletionResult, :spelling "CXCompletionResult", :size-in-bytes 16, :fields [{:type "enum CXCursorKind", :datatype :coffi.mem/int, :name "CursorKind", :calculated-offset 0} {:type "void *", :datatype :coffi.mem/pointer, :name "CompletionString", :calculated-offset 64}]} {:kind "CXCursor_StructDecl", :type "CXType_Record", :id :clang/CXUnsavedFile, :spelling "struct CXUnsavedFile", :size-in-bytes 24, :fields [{:type "const char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "Filename", :calculated-offset 0} {:type "const char *", :datatype [:coffi.mem/pointer :coffi.mem/char], :name "Contents", :calculated-offset 64} {:type "unsigned long", :datatype :coffi.mem/long, :name "Length", :calculated-offset 128}]} {:kind "CXCursor_StructDecl", :type "CXType_Record", :id :clang/CXTranslationUnitImpl, :spelling "struct CXTranslationUnitImpl", :size-in-bytes -2, :fields []} {:kind "CXCursor_StructDecl", :type "CXType_Record", :id :clang/CXSourceLocation, :spelling "CXSourceLocation", :size-in-bytes 24, :fields [{:type "const void *[2]", :datatype [:coffi.mem/array :coffi.mem/pointer 2], :name "ptr_data", :calculated-offset 0} {:type "unsigned int", :datatype :coffi.mem/int, :name "int_data", :calculated-offset 128}]} {:kind "CXCursor_StructDecl", :type "CXType_Record", :id :clang/CXTargetInfoImpl, :spelling "struct CXTargetInfoImpl", :size-in-bytes -2, :fields []} {:kind "CXCursor_StructDecl", :type "CXType_Record", :id :clang/CXFileUniqueID, :spelling "CXFileUniqueID", :size-in-bytes 24, :fields [{:type "unsigned long long [3]", :datatype [:coffi.mem/array :coffi.mem/long 3], :name "data", :calculated-offset 0}]}), :enums ({:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXError_Success", :value 0, :enum "CXErrorCode", :raw-comment "/**\n   * No error.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXError_Failure", :value 1, :enum "CXErrorCode", :raw-comment "/**\n   * A generic error code, no further details are available.\n   *\n   * Errors of this kind can get their own specific error codes in future\n   * libclang versions.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXError_Crashed", :value 2, :enum "CXErrorCode", :raw-comment "/**\n   * libclang crashed while performing the requested operation.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXError_InvalidArguments", :value 3, :enum "CXErrorCode", :raw-comment "/**\n   * The function detected that the arguments violate the function\n   * contract.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXError_ASTReadError", :value 4, :enum "CXErrorCode", :raw-comment "/**\n   * An AST deserialization error has occurred.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXAvailability_Available", :value 0, :enum "CXAvailabilityKind", :raw-comment "/**\n   * The entity is available.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXAvailability_Deprecated", :value 1, :enum "CXAvailabilityKind", :raw-comment "/**\n   * The entity is available, but has been deprecated (and its use is\n   * not recommended).\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXAvailability_NotAvailable", :value 2, :enum "CXAvailabilityKind", :raw-comment "/**\n   * The entity is not available; any use of it will be an error.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXAvailability_NotAccessible", :value 3, :enum "CXAvailabilityKind", :raw-comment "/**\n   * The entity is available, but not accessible; any use of it will be\n   * an error.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_ExceptionSpecificationKind_None", :value 0, :enum "CXCursor_ExceptionSpecificationKind", :raw-comment "/**\n   * The cursor has no exception specification.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_ExceptionSpecificationKind_DynamicNone", :value 1, :enum "CXCursor_ExceptionSpecificationKind", :raw-comment "/**\n   * The cursor has exception specification throw()\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_ExceptionSpecificationKind_Dynamic", :value 2, :enum "CXCursor_ExceptionSpecificationKind", :raw-comment "/**\n   * The cursor has exception specification throw(T1, T2)\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_ExceptionSpecificationKind_MSAny", :value 3, :enum "CXCursor_ExceptionSpecificationKind", :raw-comment "/**\n   * The cursor has exception specification throw(...).\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_ExceptionSpecificationKind_BasicNoexcept", :value 4, :enum "CXCursor_ExceptionSpecificationKind", :raw-comment "/**\n   * The cursor has exception specification basic noexcept.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_ExceptionSpecificationKind_ComputedNoexcept", :value 5, :enum "CXCursor_ExceptionSpecificationKind", :raw-comment "/**\n   * The cursor has exception specification computed noexcept.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_ExceptionSpecificationKind_Unevaluated", :value 6, :enum "CXCursor_ExceptionSpecificationKind", :raw-comment "/**\n   * The exception specification has not yet been evaluated.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_ExceptionSpecificationKind_Uninstantiated", :value 7, :enum "CXCursor_ExceptionSpecificationKind", :raw-comment "/**\n   * The exception specification has not yet been instantiated.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_ExceptionSpecificationKind_Unparsed", :value 8, :enum "CXCursor_ExceptionSpecificationKind", :raw-comment "/**\n   * The exception specification has not been parsed yet.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_ExceptionSpecificationKind_NoThrow", :value 9, :enum "CXCursor_ExceptionSpecificationKind", :raw-comment "/**\n   * The cursor has a __declspec(nothrow) exception specification.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXGlobalOpt_None", :value 0, :enum "", :raw-comment "/**\n   * Used to indicate that no special CXIndex options are needed.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXGlobalOpt_ThreadBackgroundPriorityForIndexing", :value 1, :enum "", :raw-comment "/**\n   * Used to indicate that threads that libclang creates for indexing\n   * purposes should use background priority.\n   *\n   * Affects #clang_indexSourceFile, #clang_indexTranslationUnit,\n   * #clang_parseTranslationUnit, #clang_saveTranslationUnit.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXGlobalOpt_ThreadBackgroundPriorityForEditing", :value 2, :enum "", :raw-comment "/**\n   * Used to indicate that threads that libclang creates for editing\n   * purposes should use background priority.\n   *\n   * Affects #clang_reparseTranslationUnit, #clang_codeCompleteAt,\n   * #clang_annotateTokens\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXGlobalOpt_ThreadBackgroundPriorityForAll", :value 3, :enum "", :raw-comment "/**\n   * Used to indicate that all threads that libclang creates should use\n   * background priority.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXGlobalOpt_None", :value 0, :enum "", :raw-comment "/**\n   * Used to indicate that no special CXIndex options are needed.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXGlobalOpt_ThreadBackgroundPriorityForIndexing", :value 1, :enum "", :raw-comment "/**\n   * Used to indicate that threads that libclang creates for indexing\n   * purposes should use background priority.\n   *\n   * Affects #clang_indexSourceFile, #clang_indexTranslationUnit,\n   * #clang_parseTranslationUnit, #clang_saveTranslationUnit.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXGlobalOpt_ThreadBackgroundPriorityForEditing", :value 2, :enum "", :raw-comment "/**\n   * Used to indicate that threads that libclang creates for editing\n   * purposes should use background priority.\n   *\n   * Affects #clang_reparseTranslationUnit, #clang_codeCompleteAt,\n   * #clang_annotateTokens\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXGlobalOpt_ThreadBackgroundPriorityForAll", :value 3, :enum "", :raw-comment "/**\n   * Used to indicate that all threads that libclang creates should use\n   * background priority.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXDiagnostic_Ignored", :value 0, :enum "CXDiagnosticSeverity", :raw-comment "/**\n   * A diagnostic that has been suppressed, e.g., by a command-line\n   * option.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXDiagnostic_Note", :value 1, :enum "CXDiagnosticSeverity", :raw-comment "/**\n   * This diagnostic is a note that should be attached to the\n   * previous (non-note) diagnostic.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXDiagnostic_Warning", :value 2, :enum "CXDiagnosticSeverity", :raw-comment "/**\n   * This diagnostic indicates suspicious code that may not be\n   * wrong.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXDiagnostic_Error", :value 3, :enum "CXDiagnosticSeverity", :raw-comment "/**\n   * This diagnostic indicates that the code is ill-formed.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXDiagnostic_Fatal", :value 4, :enum "CXDiagnosticSeverity", :raw-comment "/**\n   * This diagnostic indicates that the code is ill-formed such\n   * that future parser recovery is unlikely to produce useful\n   * results.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXLoadDiag_None", :value 0, :enum "CXLoadDiag_Error", :raw-comment "/**\n   * Indicates that no error occurred.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXLoadDiag_Unknown", :value 1, :enum "CXLoadDiag_Error", :raw-comment "/**\n   * Indicates that an unknown error occurred while attempting to\n   * deserialize diagnostics.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXLoadDiag_CannotLoad", :value 2, :enum "CXLoadDiag_Error", :raw-comment "/**\n   * Indicates that the file containing the serialized diagnostics\n   * could not be opened.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXLoadDiag_InvalidFile", :value 3, :enum "CXLoadDiag_Error", :raw-comment "/**\n   * Indicates that the serialized diagnostics file is invalid or\n   * corrupt.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXDiagnostic_DisplaySourceLocation", :value 1, :enum "CXDiagnosticDisplayOptions", :raw-comment "/**\n   * Display the source-location information where the\n   * diagnostic was located.\n   *\n   * When set, diagnostics will be prefixed by the file, line, and\n   * (optionally) column to which the diagnostic refers. For example,\n   *\n   * \\code\n   * test.c:28: warning: extra tokens at end of #endif directive\n   * \\endcode\n   *\n   * This option corresponds to the clang flag \\c -fshow-source-location.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXDiagnostic_DisplayColumn", :value 2, :enum "CXDiagnosticDisplayOptions", :raw-comment "/**\n   * If displaying the source-location information of the\n   * diagnostic, also include the column number.\n   *\n   * This option corresponds to the clang flag \\c -fshow-column.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXDiagnostic_DisplaySourceRanges", :value 4, :enum "CXDiagnosticDisplayOptions", :raw-comment "/**\n   * If displaying the source-location information of the\n   * diagnostic, also include information about source ranges in a\n   * machine-parsable format.\n   *\n   * This option corresponds to the clang flag\n   * \\c -fdiagnostics-print-source-range-info.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXDiagnostic_DisplayOption", :value 8, :enum "CXDiagnosticDisplayOptions", :raw-comment "/**\n   * Display the option name associated with this diagnostic, if any.\n   *\n   * The option name displayed (e.g., -Wconversion) will be placed in brackets\n   * after the diagnostic text. This option corresponds to the clang flag\n   * \\c -fdiagnostics-show-option.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXDiagnostic_DisplayCategoryId", :value 16, :enum "CXDiagnosticDisplayOptions", :raw-comment "/**\n   * Display the category number associated with this diagnostic, if any.\n   *\n   * The category number is displayed within brackets after the diagnostic text.\n   * This option corresponds to the clang flag\n   * \\c -fdiagnostics-show-category=id.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXDiagnostic_DisplayCategoryName", :value 32, :enum "CXDiagnosticDisplayOptions", :raw-comment "/**\n   * Display the category name associated with this diagnostic, if any.\n   *\n   * The category name is displayed within brackets after the diagnostic text.\n   * This option corresponds to the clang flag\n   * \\c -fdiagnostics-show-category=name.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXTranslationUnit_None", :value 0, :enum "CXTranslationUnit_Flags", :raw-comment "/**\n   * Used to indicate that no special translation-unit options are\n   * needed.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXTranslationUnit_DetailedPreprocessingRecord", :value 1, :enum "CXTranslationUnit_Flags", :raw-comment "/**\n   * Used to indicate that the parser should construct a \"detailed\"\n   * preprocessing record, including all macro definitions and instantiations.\n   *\n   * Constructing a detailed preprocessing record requires more memory\n   * and time to parse, since the information contained in the record\n   * is usually not retained. However, it can be useful for\n   * applications that require more detailed information about the\n   * behavior of the preprocessor.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXTranslationUnit_Incomplete", :value 2, :enum "CXTranslationUnit_Flags", :raw-comment "/**\n   * Used to indicate that the translation unit is incomplete.\n   *\n   * When a translation unit is considered \"incomplete\", semantic\n   * analysis that is typically performed at the end of the\n   * translation unit will be suppressed. For example, this suppresses\n   * the completion of tentative declarations in C and of\n   * instantiation of implicitly-instantiation function templates in\n   * C++. This option is typically used when parsing a header with the\n   * intent of producing a precompiled header.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXTranslationUnit_PrecompiledPreamble", :value 4, :enum "CXTranslationUnit_Flags", :raw-comment "/**\n   * Used to indicate that the translation unit should be built with an\n   * implicit precompiled header for the preamble.\n   *\n   * An implicit precompiled header is used as an optimization when a\n   * particular translation unit is likely to be reparsed many times\n   * when the sources aren't changing that often. In this case, an\n   * implicit precompiled header will be built containing all of the\n   * initial includes at the top of the main file (what we refer to as\n   * the \"preamble\" of the file). In subsequent parses, if the\n   * preamble or the files in it have not changed, \\c\n   * clang_reparseTranslationUnit() will re-use the implicit\n   * precompiled header to improve parsing performance.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXTranslationUnit_CacheCompletionResults", :value 8, :enum "CXTranslationUnit_Flags", :raw-comment "/**\n   * Used to indicate that the translation unit should cache some\n   * code-completion results with each reparse of the source file.\n   *\n   * Caching of code-completion results is a performance optimization that\n   * introduces some overhead to reparsing but improves the performance of\n   * code-completion operations.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXTranslationUnit_ForSerialization", :value 16, :enum "CXTranslationUnit_Flags", :raw-comment "/**\n   * Used to indicate that the translation unit will be serialized with\n   * \\c clang_saveTranslationUnit.\n   *\n   * This option is typically used when parsing a header with the intent of\n   * producing a precompiled header.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXTranslationUnit_CXXChainedPCH", :value 32, :enum "CXTranslationUnit_Flags", :raw-comment "/**\n   * DEPRECATED: Enabled chained precompiled preambles in C++.\n   *\n   * Note: this is a *temporary* option that is available only while\n   * we are testing C++ precompiled preamble support. It is deprecated.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXTranslationUnit_SkipFunctionBodies", :value 64, :enum "CXTranslationUnit_Flags", :raw-comment "/**\n   * Used to indicate that function/method bodies should be skipped while\n   * parsing.\n   *\n   * This option can be used to search for declarations/definitions while\n   * ignoring the usages.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXTranslationUnit_IncludeBriefCommentsInCodeCompletion", :value 128, :enum "CXTranslationUnit_Flags", :raw-comment "/**\n   * Used to indicate that brief documentation comments should be\n   * included into the set of code completions returned from this translation\n   * unit.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXTranslationUnit_CreatePreambleOnFirstParse", :value 256, :enum "CXTranslationUnit_Flags", :raw-comment "/**\n   * Used to indicate that the precompiled preamble should be created on\n   * the first parse. Otherwise it will be created on the first reparse. This\n   * trades runtime on the first parse (serializing the preamble takes time) for\n   * reduced runtime on the second parse (can now reuse the preamble).\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXTranslationUnit_KeepGoing", :value 512, :enum "CXTranslationUnit_Flags", :raw-comment "/**\n   * Do not stop processing when fatal errors are encountered.\n   *\n   * When fatal errors are encountered while parsing a translation unit,\n   * semantic analysis is typically stopped early when compiling code. A common\n   * source for fatal errors are unresolvable include files. For the\n   * purposes of an IDE, this is undesirable behavior and as much information\n   * as possible should be reported. Use this flag to enable this behavior.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXTranslationUnit_SingleFileParse", :value 1024, :enum "CXTranslationUnit_Flags", :raw-comment "/**\n   * Sets the preprocessor in a mode for parsing a single file only.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXTranslationUnit_LimitSkipFunctionBodiesToPreamble", :value 2048, :enum "CXTranslationUnit_Flags", :raw-comment "/**\n   * Used in combination with CXTranslationUnit_SkipFunctionBodies to\n   * constrain the skipping of function bodies to the preamble.\n   *\n   * The function bodies of the main file are not skipped.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXTranslationUnit_IncludeAttributedTypes", :value 4096, :enum "CXTranslationUnit_Flags", :raw-comment "/**\n   * Used to indicate that attributed types should be included in CXType.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXTranslationUnit_VisitImplicitAttributes", :value 8192, :enum "CXTranslationUnit_Flags", :raw-comment "/**\n   * Used to indicate that implicit attributes should be visited.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXTranslationUnit_IgnoreNonErrorsFromIncludedFiles", :value 16384, :enum "CXTranslationUnit_Flags", :raw-comment "/**\n   * Used to indicate that non-errors from included files should be ignored.\n   *\n   * If set, clang_getDiagnosticSetFromTU() will not report e.g. warnings from\n   * included files anymore. This speeds up clang_getDiagnosticSetFromTU() for\n   * the case where these warnings are not of interest, as for an IDE for\n   * example, which typically shows only the diagnostics in the main file.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXTranslationUnit_RetainExcludedConditionalBlocks", :value 32768, :enum "CXTranslationUnit_Flags", :raw-comment "/**\n   * Tells the preprocessor not to skip excluded conditional blocks.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXSaveTranslationUnit_None", :value 0, :enum "CXSaveTranslationUnit_Flags", :raw-comment "/**\n   * Used to indicate that no special saving options are needed.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXSaveError_None", :value 0, :enum "CXSaveError", :raw-comment "/**\n   * Indicates that no error occurred while saving a translation unit.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXSaveError_Unknown", :value 1, :enum "CXSaveError", :raw-comment "/**\n   * Indicates that an unknown error occurred while attempting to save\n   * the file.\n   *\n   * This error typically indicates that file I/O failed when attempting to\n   * write the file.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXSaveError_TranslationErrors", :value 2, :enum "CXSaveError", :raw-comment "/**\n   * Indicates that errors during translation prevented this attempt\n   * to save the translation unit.\n   *\n   * Errors that prevent the translation unit from being saved can be\n   * extracted using \\c clang_getNumDiagnostics() and \\c clang_getDiagnostic().\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXSaveError_InvalidTU", :value 3, :enum "CXSaveError", :raw-comment "/**\n   * Indicates that the translation unit to be saved was somehow\n   * invalid (e.g., NULL).\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXReparse_None", :value 0, :enum "CXReparse_Flags", :raw-comment "/**\n   * Used to indicate that no special reparsing options are needed.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXTUResourceUsage_AST", :value 1, :enum "CXTUResourceUsageKind", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXTUResourceUsage_Identifiers", :value 2, :enum "CXTUResourceUsageKind", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXTUResourceUsage_Selectors", :value 3, :enum "CXTUResourceUsageKind", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXTUResourceUsage_GlobalCompletionResults", :value 4, :enum "CXTUResourceUsageKind", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXTUResourceUsage_SourceManagerContentCache", :value 5, :enum "CXTUResourceUsageKind", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXTUResourceUsage_AST_SideTables", :value 6, :enum "CXTUResourceUsageKind", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXTUResourceUsage_SourceManager_Membuffer_Malloc", :value 7, :enum "CXTUResourceUsageKind", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXTUResourceUsage_SourceManager_Membuffer_MMap", :value 8, :enum "CXTUResourceUsageKind", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXTUResourceUsage_ExternalASTSource_Membuffer_Malloc", :value 9, :enum "CXTUResourceUsageKind", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXTUResourceUsage_ExternalASTSource_Membuffer_MMap", :value 10, :enum "CXTUResourceUsageKind", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXTUResourceUsage_Preprocessor", :value 11, :enum "CXTUResourceUsageKind", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXTUResourceUsage_PreprocessingRecord", :value 12, :enum "CXTUResourceUsageKind", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXTUResourceUsage_SourceManager_DataStructures", :value 13, :enum "CXTUResourceUsageKind", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXTUResourceUsage_Preprocessor_HeaderSearch", :value 14, :enum "CXTUResourceUsageKind", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXTUResourceUsage_MEMORY_IN_BYTES_BEGIN", :value 1, :enum "CXTUResourceUsageKind", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXTUResourceUsage_MEMORY_IN_BYTES_END", :value 14, :enum "CXTUResourceUsageKind", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXTUResourceUsage_First", :value 1, :enum "CXTUResourceUsageKind", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXTUResourceUsage_Last", :value 14, :enum "CXTUResourceUsageKind", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_UnexposedDecl", :value 1, :enum "CXCursorKind", :raw-comment "/**\n   * A declaration whose specific kind is not exposed via this\n   * interface.\n   *\n   * Unexposed declarations have the same operations as any other kind\n   * of declaration; one can extract their location information,\n   * spelling, find their definitions, etc. However, the specific kind\n   * of the declaration is not reported.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_StructDecl", :value 2, :enum "CXCursorKind", :raw-comment "/** A C or C++ struct. */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_UnionDecl", :value 3, :enum "CXCursorKind", :raw-comment "/** A C or C++ union. */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_ClassDecl", :value 4, :enum "CXCursorKind", :raw-comment "/** A C++ class. */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_EnumDecl", :value 5, :enum "CXCursorKind", :raw-comment "/** An enumeration. */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_FieldDecl", :value 6, :enum "CXCursorKind", :raw-comment "/**\n   * A field (in C) or non-static data member (in C++) in a\n   * struct, union, or C++ class.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_EnumConstantDecl", :value 7, :enum "CXCursorKind", :raw-comment "/** An enumerator constant. */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_FunctionDecl", :value 8, :enum "CXCursorKind", :raw-comment "/** A function. */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_VarDecl", :value 9, :enum "CXCursorKind", :raw-comment "/** A variable. */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_ParmDecl", :value 10, :enum "CXCursorKind", :raw-comment "/** A function or method parameter. */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_ObjCInterfaceDecl", :value 11, :enum "CXCursorKind", :raw-comment "/** An Objective-C \\@interface. */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_ObjCCategoryDecl", :value 12, :enum "CXCursorKind", :raw-comment "/** An Objective-C \\@interface for a category. */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_ObjCProtocolDecl", :value 13, :enum "CXCursorKind", :raw-comment "/** An Objective-C \\@protocol declaration. */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_ObjCPropertyDecl", :value 14, :enum "CXCursorKind", :raw-comment "/** An Objective-C \\@property declaration. */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_ObjCIvarDecl", :value 15, :enum "CXCursorKind", :raw-comment "/** An Objective-C instance variable. */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_ObjCInstanceMethodDecl", :value 16, :enum "CXCursorKind", :raw-comment "/** An Objective-C instance method. */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_ObjCClassMethodDecl", :value 17, :enum "CXCursorKind", :raw-comment "/** An Objective-C class method. */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_ObjCImplementationDecl", :value 18, :enum "CXCursorKind", :raw-comment "/** An Objective-C \\@implementation. */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_ObjCCategoryImplDecl", :value 19, :enum "CXCursorKind", :raw-comment "/** An Objective-C \\@implementation for a category. */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_TypedefDecl", :value 20, :enum "CXCursorKind", :raw-comment "/** A typedef. */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_CXXMethod", :value 21, :enum "CXCursorKind", :raw-comment "/** A C++ class method. */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_Namespace", :value 22, :enum "CXCursorKind", :raw-comment "/** A C++ namespace. */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_LinkageSpec", :value 23, :enum "CXCursorKind", :raw-comment "/** A linkage specification, e.g. 'extern \"C\"'. */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_Constructor", :value 24, :enum "CXCursorKind", :raw-comment "/** A C++ constructor. */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_Destructor", :value 25, :enum "CXCursorKind", :raw-comment "/** A C++ destructor. */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_ConversionFunction", :value 26, :enum "CXCursorKind", :raw-comment "/** A C++ conversion function. */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_TemplateTypeParameter", :value 27, :enum "CXCursorKind", :raw-comment "/** A C++ template type parameter. */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_NonTypeTemplateParameter", :value 28, :enum "CXCursorKind", :raw-comment "/** A C++ non-type template parameter. */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_TemplateTemplateParameter", :value 29, :enum "CXCursorKind", :raw-comment "/** A C++ template template parameter. */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_FunctionTemplate", :value 30, :enum "CXCursorKind", :raw-comment "/** A C++ function template. */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_ClassTemplate", :value 31, :enum "CXCursorKind", :raw-comment "/** A C++ class template. */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_ClassTemplatePartialSpecialization", :value 32, :enum "CXCursorKind", :raw-comment "/** A C++ class template partial specialization. */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_NamespaceAlias", :value 33, :enum "CXCursorKind", :raw-comment "/** A C++ namespace alias declaration. */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_UsingDirective", :value 34, :enum "CXCursorKind", :raw-comment "/** A C++ using directive. */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_UsingDeclaration", :value 35, :enum "CXCursorKind", :raw-comment "/** A C++ using declaration. */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_TypeAliasDecl", :value 36, :enum "CXCursorKind", :raw-comment "/** A C++ alias declaration */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_ObjCSynthesizeDecl", :value 37, :enum "CXCursorKind", :raw-comment "/** An Objective-C \\@synthesize definition. */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_ObjCDynamicDecl", :value 38, :enum "CXCursorKind", :raw-comment "/** An Objective-C \\@dynamic definition. */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_CXXAccessSpecifier", :value 39, :enum "CXCursorKind", :raw-comment "/** An access specifier. */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_FirstDecl", :value 1, :enum "CXCursorKind", :raw-comment "/** An access specifier. */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_LastDecl", :value 39, :enum "CXCursorKind", :raw-comment "/** An access specifier. */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_FirstRef", :value 40, :enum "CXCursorKind", :raw-comment "/** An access specifier. */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_ObjCSuperClassRef", :value 40, :enum "CXCursorKind", :raw-comment "/** An access specifier. */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_ObjCProtocolRef", :value 41, :enum "CXCursorKind", :raw-comment "/** An access specifier. */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_ObjCClassRef", :value 42, :enum "CXCursorKind", :raw-comment "/** An access specifier. */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_TypeRef", :value 43, :enum "CXCursorKind", :raw-comment "/**\n   * A reference to a type declaration.\n   *\n   * A type reference occurs anywhere where a type is named but not\n   * declared. For example, given:\n   *\n   * \\code\n   * typedef unsigned size_type;\n   * size_type size;\n   * \\endcode\n   *\n   * The typedef is a declaration of size_type (CXCursor_TypedefDecl),\n   * while the type of the variable \"size\" is referenced. The cursor\n   * referenced by the type of size is the typedef for size_type.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_CXXBaseSpecifier", :value 44, :enum "CXCursorKind", :raw-comment "/**\n   * A reference to a type declaration.\n   *\n   * A type reference occurs anywhere where a type is named but not\n   * declared. For example, given:\n   *\n   * \\code\n   * typedef unsigned size_type;\n   * size_type size;\n   * \\endcode\n   *\n   * The typedef is a declaration of size_type (CXCursor_TypedefDecl),\n   * while the type of the variable \"size\" is referenced. The cursor\n   * referenced by the type of size is the typedef for size_type.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_TemplateRef", :value 45, :enum "CXCursorKind", :raw-comment "/**\n   * A reference to a class template, function template, template\n   * template parameter, or class template partial specialization.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_NamespaceRef", :value 46, :enum "CXCursorKind", :raw-comment "/**\n   * A reference to a namespace or namespace alias.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_MemberRef", :value 47, :enum "CXCursorKind", :raw-comment "/**\n   * A reference to a member of a struct, union, or class that occurs in\n   * some non-expression context, e.g., a designated initializer.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_LabelRef", :value 48, :enum "CXCursorKind", :raw-comment "/**\n   * A reference to a labeled statement.\n   *\n   * This cursor kind is used to describe the jump to \"start_over\" in the\n   * goto statement in the following example:\n   *\n   * \\code\n   *   start_over:\n   *     ++counter;\n   *\n   *     goto start_over;\n   * \\endcode\n   *\n   * A label reference cursor refers to a label statement.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_OverloadedDeclRef", :value 49, :enum "CXCursorKind", :raw-comment "/**\n   * A reference to a set of overloaded functions or function templates\n   * that has not yet been resolved to a specific function or function template.\n   *\n   * An overloaded declaration reference cursor occurs in C++ templates where\n   * a dependent name refers to a function. For example:\n   *\n   * \\code\n   * template<typename T> void swap(T&, T&);\n   *\n   * struct X { ... };\n   * void swap(X&, X&);\n   *\n   * template<typename T>\n   * void reverse(T* first, T* last) {\n   *   while (first < last - 1) {\n   *     swap(*first, *--last);\n   *     ++first;\n   *   }\n   * }\n   *\n   * struct Y { };\n   * void swap(Y&, Y&);\n   * \\endcode\n   *\n   * Here, the identifier \"swap\" is associated with an overloaded declaration\n   * reference. In the template definition, \"swap\" refers to either of the two\n   * \"swap\" functions declared above, so both results will be available. At\n   * instantiation time, \"swap\" may also refer to other functions found via\n   * argument-dependent lookup (e.g., the \"swap\" function at the end of the\n   * example).\n   *\n   * The functions \\c clang_getNumOverloadedDecls() and\n   * \\c clang_getOverloadedDecl() can be used to retrieve the definitions\n   * referenced by this cursor.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_VariableRef", :value 50, :enum "CXCursorKind", :raw-comment "/**\n   * A reference to a variable that occurs in some non-expression\n   * context, e.g., a C++ lambda capture list.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_LastRef", :value 50, :enum "CXCursorKind", :raw-comment "/**\n   * A reference to a variable that occurs in some non-expression\n   * context, e.g., a C++ lambda capture list.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_FirstInvalid", :value 70, :enum "CXCursorKind", :raw-comment "/**\n   * A reference to a variable that occurs in some non-expression\n   * context, e.g., a C++ lambda capture list.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_InvalidFile", :value 70, :enum "CXCursorKind", :raw-comment "/**\n   * A reference to a variable that occurs in some non-expression\n   * context, e.g., a C++ lambda capture list.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_NoDeclFound", :value 71, :enum "CXCursorKind", :raw-comment "/**\n   * A reference to a variable that occurs in some non-expression\n   * context, e.g., a C++ lambda capture list.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_NotImplemented", :value 72, :enum "CXCursorKind", :raw-comment "/**\n   * A reference to a variable that occurs in some non-expression\n   * context, e.g., a C++ lambda capture list.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_InvalidCode", :value 73, :enum "CXCursorKind", :raw-comment "/**\n   * A reference to a variable that occurs in some non-expression\n   * context, e.g., a C++ lambda capture list.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_LastInvalid", :value 73, :enum "CXCursorKind", :raw-comment "/**\n   * A reference to a variable that occurs in some non-expression\n   * context, e.g., a C++ lambda capture list.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_FirstExpr", :value 100, :enum "CXCursorKind", :raw-comment "/**\n   * A reference to a variable that occurs in some non-expression\n   * context, e.g., a C++ lambda capture list.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_UnexposedExpr", :value 100, :enum "CXCursorKind", :raw-comment "/**\n   * An expression whose specific kind is not exposed via this\n   * interface.\n   *\n   * Unexposed expressions have the same operations as any other kind\n   * of expression; one can extract their location information,\n   * spelling, children, etc. However, the specific kind of the\n   * expression is not reported.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_DeclRefExpr", :value 101, :enum "CXCursorKind", :raw-comment "/**\n   * An expression that refers to some value declaration, such\n   * as a function, variable, or enumerator.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_MemberRefExpr", :value 102, :enum "CXCursorKind", :raw-comment "/**\n   * An expression that refers to a member of a struct, union,\n   * class, Objective-C class, etc.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_CallExpr", :value 103, :enum "CXCursorKind", :raw-comment "/** An expression that calls a function. */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_ObjCMessageExpr", :value 104, :enum "CXCursorKind", :raw-comment "/** An expression that sends a message to an Objective-C\n   object or class. */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_BlockExpr", :value 105, :enum "CXCursorKind", :raw-comment "/** An expression that represents a block literal. */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_IntegerLiteral", :value 106, :enum "CXCursorKind", :raw-comment "/** An integer literal.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_FloatingLiteral", :value 107, :enum "CXCursorKind", :raw-comment "/** A floating point number literal.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_ImaginaryLiteral", :value 108, :enum "CXCursorKind", :raw-comment "/** An imaginary number literal.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_StringLiteral", :value 109, :enum "CXCursorKind", :raw-comment "/** A string literal.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_CharacterLiteral", :value 110, :enum "CXCursorKind", :raw-comment "/** A character literal.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_ParenExpr", :value 111, :enum "CXCursorKind", :raw-comment "/** A parenthesized expression, e.g. \"(1)\".\n   *\n   * This AST node is only formed if full location information is requested.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_UnaryOperator", :value 112, :enum "CXCursorKind", :raw-comment "/** This represents the unary-expression's (except sizeof and\n   * alignof).\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_ArraySubscriptExpr", :value 113, :enum "CXCursorKind", :raw-comment "/** [C99 6.5.2.1] Array Subscripting.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_BinaryOperator", :value 114, :enum "CXCursorKind", :raw-comment "/** A builtin binary operation expression such as \"x + y\" or\n   * \"x <= y\".\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_CompoundAssignOperator", :value 115, :enum "CXCursorKind", :raw-comment "/** Compound assignment such as \"+=\".\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_ConditionalOperator", :value 116, :enum "CXCursorKind", :raw-comment "/** The ?: ternary operator.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_CStyleCastExpr", :value 117, :enum "CXCursorKind", :raw-comment "/** An explicit cast in C (C99 6.5.4) or a C-style cast in C++\n   * (C++ [expr.cast]), which uses the syntax (Type)expr.\n   *\n   * For example: (int)f.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_CompoundLiteralExpr", :value 118, :enum "CXCursorKind", :raw-comment "/** [C99 6.5.2.5]\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_InitListExpr", :value 119, :enum "CXCursorKind", :raw-comment "/** Describes an C or C++ initializer list.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_AddrLabelExpr", :value 120, :enum "CXCursorKind", :raw-comment "/** The GNU address of label extension, representing &&label.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_StmtExpr", :value 121, :enum "CXCursorKind", :raw-comment "/** This is the GNU Statement Expression extension: ({int X=4; X;})\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_GenericSelectionExpr", :value 122, :enum "CXCursorKind", :raw-comment "/** Represents a C11 generic selection.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_GNUNullExpr", :value 123, :enum "CXCursorKind", :raw-comment "/** Implements the GNU __null extension, which is a name for a null\n   * pointer constant that has integral type (e.g., int or long) and is the same\n   * size and alignment as a pointer.\n   *\n   * The __null extension is typically only used by system headers, which define\n   * NULL as __null in C++ rather than using 0 (which is an integer that may not\n   * match the size of a pointer).\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_CXXStaticCastExpr", :value 124, :enum "CXCursorKind", :raw-comment "/** C++'s static_cast<> expression.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_CXXDynamicCastExpr", :value 125, :enum "CXCursorKind", :raw-comment "/** C++'s dynamic_cast<> expression.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_CXXReinterpretCastExpr", :value 126, :enum "CXCursorKind", :raw-comment "/** C++'s reinterpret_cast<> expression.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_CXXConstCastExpr", :value 127, :enum "CXCursorKind", :raw-comment "/** C++'s const_cast<> expression.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_CXXFunctionalCastExpr", :value 128, :enum "CXCursorKind", :raw-comment "/** Represents an explicit C++ type conversion that uses \"functional\"\n   * notion (C++ [expr.type.conv]).\n   *\n   * Example:\n   * \\code\n   *   x = int(0.5);\n   * \\endcode\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_CXXTypeidExpr", :value 129, :enum "CXCursorKind", :raw-comment "/** A C++ typeid expression (C++ [expr.typeid]).\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_CXXBoolLiteralExpr", :value 130, :enum "CXCursorKind", :raw-comment "/** [C++ 2.13.5] C++ Boolean Literal.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_CXXNullPtrLiteralExpr", :value 131, :enum "CXCursorKind", :raw-comment "/** [C++0x 2.14.7] C++ Pointer Literal.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_CXXThisExpr", :value 132, :enum "CXCursorKind", :raw-comment "/** Represents the \"this\" expression in C++\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_CXXThrowExpr", :value 133, :enum "CXCursorKind", :raw-comment "/** [C++ 15] C++ Throw Expression.\n   *\n   * This handles 'throw' and 'throw' assignment-expression. When\n   * assignment-expression isn't present, Op will be null.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_CXXNewExpr", :value 134, :enum "CXCursorKind", :raw-comment "/** A new expression for memory allocation and constructor calls, e.g:\n   * \"new CXXNewExpr(foo)\".\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_CXXDeleteExpr", :value 135, :enum "CXCursorKind", :raw-comment "/** A delete expression for memory deallocation and destructor calls,\n   * e.g. \"delete[] pArray\".\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_UnaryExpr", :value 136, :enum "CXCursorKind", :raw-comment "/** A unary expression. (noexcept, sizeof, or other traits)\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_ObjCStringLiteral", :value 137, :enum "CXCursorKind", :raw-comment "/** An Objective-C string literal i.e. @\"foo\".\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_ObjCEncodeExpr", :value 138, :enum "CXCursorKind", :raw-comment "/** An Objective-C \\@encode expression.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_ObjCSelectorExpr", :value 139, :enum "CXCursorKind", :raw-comment "/** An Objective-C \\@selector expression.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_ObjCProtocolExpr", :value 140, :enum "CXCursorKind", :raw-comment "/** An Objective-C \\@protocol expression.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_ObjCBridgedCastExpr", :value 141, :enum "CXCursorKind", :raw-comment "/** An Objective-C \"bridged\" cast expression, which casts between\n   * Objective-C pointers and C pointers, transferring ownership in the process.\n   *\n   * \\code\n   *   NSString *str = (__bridge_transfer NSString *)CFCreateString();\n   * \\endcode\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_PackExpansionExpr", :value 142, :enum "CXCursorKind", :raw-comment "/** Represents a C++0x pack expansion that produces a sequence of\n   * expressions.\n   *\n   * A pack expansion expression contains a pattern (which itself is an\n   * expression) followed by an ellipsis. For example:\n   *\n   * \\code\n   * template<typename F, typename ...Types>\n   * void forward(F f, Types &&...args) {\n   *  f(static_cast<Types&&>(args)...);\n   * }\n   * \\endcode\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_SizeOfPackExpr", :value 143, :enum "CXCursorKind", :raw-comment "/** Represents an expression that computes the length of a parameter\n   * pack.\n   *\n   * \\code\n   * template<typename ...Types>\n   * struct count {\n   *   static const unsigned value = sizeof...(Types);\n   * };\n   * \\endcode\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_LambdaExpr", :value 144, :enum "CXCursorKind", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_ObjCBoolLiteralExpr", :value 145, :enum "CXCursorKind", :raw-comment "/** Objective-c Boolean Literal.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_ObjCSelfExpr", :value 146, :enum "CXCursorKind", :raw-comment "/** Represents the \"self\" expression in an Objective-C method.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_OMPArraySectionExpr", :value 147, :enum "CXCursorKind", :raw-comment "/** OpenMP 5.0 [2.1.5, Array Section].\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_ObjCAvailabilityCheckExpr", :value 148, :enum "CXCursorKind", :raw-comment "/** Represents an @available(...) check.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_FixedPointLiteral", :value 149, :enum "CXCursorKind", :raw-comment "/**\n   * Fixed point literal\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_OMPArrayShapingExpr", :value 150, :enum "CXCursorKind", :raw-comment "/** OpenMP 5.0 [2.1.4, Array Shaping].\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_OMPIteratorExpr", :value 151, :enum "CXCursorKind", :raw-comment "/**\n   * OpenMP 5.0 [2.1.6 Iterators]\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_CXXAddrspaceCastExpr", :value 152, :enum "CXCursorKind", :raw-comment "/** OpenCL's addrspace_cast<> expression.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_LastExpr", :value 152, :enum "CXCursorKind", :raw-comment "/** OpenCL's addrspace_cast<> expression.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_FirstStmt", :value 200, :enum "CXCursorKind", :raw-comment "/** OpenCL's addrspace_cast<> expression.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_UnexposedStmt", :value 200, :enum "CXCursorKind", :raw-comment "/**\n   * A statement whose specific kind is not exposed via this\n   * interface.\n   *\n   * Unexposed statements have the same operations as any other kind of\n   * statement; one can extract their location information, spelling,\n   * children, etc. However, the specific kind of the statement is not\n   * reported.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_LabelStmt", :value 201, :enum "CXCursorKind", :raw-comment "/** A labelled statement in a function.\n   *\n   * This cursor kind is used to describe the \"start_over:\" label statement in\n   * the following example:\n   *\n   * \\code\n   *   start_over:\n   *     ++counter;\n   * \\endcode\n   *\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_CompoundStmt", :value 202, :enum "CXCursorKind", :raw-comment "/** A group of statements like { stmt stmt }.\n   *\n   * This cursor kind is used to describe compound statements, e.g. function\n   * bodies.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_CaseStmt", :value 203, :enum "CXCursorKind", :raw-comment "/** A case statement.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_DefaultStmt", :value 204, :enum "CXCursorKind", :raw-comment "/** A default statement.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_IfStmt", :value 205, :enum "CXCursorKind", :raw-comment "/** An if statement\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_SwitchStmt", :value 206, :enum "CXCursorKind", :raw-comment "/** A switch statement.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_WhileStmt", :value 207, :enum "CXCursorKind", :raw-comment "/** A while statement.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_DoStmt", :value 208, :enum "CXCursorKind", :raw-comment "/** A do statement.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_ForStmt", :value 209, :enum "CXCursorKind", :raw-comment "/** A for statement.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_GotoStmt", :value 210, :enum "CXCursorKind", :raw-comment "/** A goto statement.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_IndirectGotoStmt", :value 211, :enum "CXCursorKind", :raw-comment "/** An indirect goto statement.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_ContinueStmt", :value 212, :enum "CXCursorKind", :raw-comment "/** A continue statement.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_BreakStmt", :value 213, :enum "CXCursorKind", :raw-comment "/** A break statement.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_ReturnStmt", :value 214, :enum "CXCursorKind", :raw-comment "/** A return statement.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_GCCAsmStmt", :value 215, :enum "CXCursorKind", :raw-comment "/** A GCC inline assembly statement extension.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_AsmStmt", :value 215, :enum "CXCursorKind", :raw-comment "/** A GCC inline assembly statement extension.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_ObjCAtTryStmt", :value 216, :enum "CXCursorKind", :raw-comment "/** Objective-C's overall \\@try-\\@catch-\\@finally statement.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_ObjCAtCatchStmt", :value 217, :enum "CXCursorKind", :raw-comment "/** Objective-C's \\@catch statement.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_ObjCAtFinallyStmt", :value 218, :enum "CXCursorKind", :raw-comment "/** Objective-C's \\@finally statement.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_ObjCAtThrowStmt", :value 219, :enum "CXCursorKind", :raw-comment "/** Objective-C's \\@throw statement.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_ObjCAtSynchronizedStmt", :value 220, :enum "CXCursorKind", :raw-comment "/** Objective-C's \\@synchronized statement.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_ObjCAutoreleasePoolStmt", :value 221, :enum "CXCursorKind", :raw-comment "/** Objective-C's autorelease pool statement.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_ObjCForCollectionStmt", :value 222, :enum "CXCursorKind", :raw-comment "/** Objective-C's collection statement.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_CXXCatchStmt", :value 223, :enum "CXCursorKind", :raw-comment "/** C++'s catch statement.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_CXXTryStmt", :value 224, :enum "CXCursorKind", :raw-comment "/** C++'s try statement.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_CXXForRangeStmt", :value 225, :enum "CXCursorKind", :raw-comment "/** C++'s for (* : *) statement.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_SEHTryStmt", :value 226, :enum "CXCursorKind", :raw-comment "/** Windows Structured Exception Handling's try statement.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_SEHExceptStmt", :value 227, :enum "CXCursorKind", :raw-comment "/** Windows Structured Exception Handling's except statement.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_SEHFinallyStmt", :value 228, :enum "CXCursorKind", :raw-comment "/** Windows Structured Exception Handling's finally statement.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_MSAsmStmt", :value 229, :enum "CXCursorKind", :raw-comment "/** A MS inline assembly statement extension.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_NullStmt", :value 230, :enum "CXCursorKind", :raw-comment "/** The null statement \";\": C99 6.8.3p3.\n   *\n   * This cursor kind is used to describe the null statement.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_DeclStmt", :value 231, :enum "CXCursorKind", :raw-comment "/** Adaptor class for mixing declarations with statements and\n   * expressions.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_OMPParallelDirective", :value 232, :enum "CXCursorKind", :raw-comment "/** OpenMP parallel directive.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_OMPSimdDirective", :value 233, :enum "CXCursorKind", :raw-comment "/** OpenMP SIMD directive.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_OMPForDirective", :value 234, :enum "CXCursorKind", :raw-comment "/** OpenMP for directive.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_OMPSectionsDirective", :value 235, :enum "CXCursorKind", :raw-comment "/** OpenMP sections directive.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_OMPSectionDirective", :value 236, :enum "CXCursorKind", :raw-comment "/** OpenMP section directive.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_OMPSingleDirective", :value 237, :enum "CXCursorKind", :raw-comment "/** OpenMP single directive.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_OMPParallelForDirective", :value 238, :enum "CXCursorKind", :raw-comment "/** OpenMP parallel for directive.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_OMPParallelSectionsDirective", :value 239, :enum "CXCursorKind", :raw-comment "/** OpenMP parallel sections directive.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_OMPTaskDirective", :value 240, :enum "CXCursorKind", :raw-comment "/** OpenMP task directive.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_OMPMasterDirective", :value 241, :enum "CXCursorKind", :raw-comment "/** OpenMP master directive.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_OMPCriticalDirective", :value 242, :enum "CXCursorKind", :raw-comment "/** OpenMP critical directive.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_OMPTaskyieldDirective", :value 243, :enum "CXCursorKind", :raw-comment "/** OpenMP taskyield directive.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_OMPBarrierDirective", :value 244, :enum "CXCursorKind", :raw-comment "/** OpenMP barrier directive.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_OMPTaskwaitDirective", :value 245, :enum "CXCursorKind", :raw-comment "/** OpenMP taskwait directive.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_OMPFlushDirective", :value 246, :enum "CXCursorKind", :raw-comment "/** OpenMP flush directive.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_SEHLeaveStmt", :value 247, :enum "CXCursorKind", :raw-comment "/** Windows Structured Exception Handling's leave statement.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_OMPOrderedDirective", :value 248, :enum "CXCursorKind", :raw-comment "/** OpenMP ordered directive.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_OMPAtomicDirective", :value 249, :enum "CXCursorKind", :raw-comment "/** OpenMP atomic directive.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_OMPForSimdDirective", :value 250, :enum "CXCursorKind", :raw-comment "/** OpenMP for SIMD directive.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_OMPParallelForSimdDirective", :value 251, :enum "CXCursorKind", :raw-comment "/** OpenMP parallel for SIMD directive.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_OMPTargetDirective", :value 252, :enum "CXCursorKind", :raw-comment "/** OpenMP target directive.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_OMPTeamsDirective", :value 253, :enum "CXCursorKind", :raw-comment "/** OpenMP teams directive.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_OMPTaskgroupDirective", :value 254, :enum "CXCursorKind", :raw-comment "/** OpenMP taskgroup directive.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_OMPCancellationPointDirective", :value 255, :enum "CXCursorKind", :raw-comment "/** OpenMP cancellation point directive.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_OMPCancelDirective", :value 256, :enum "CXCursorKind", :raw-comment "/** OpenMP cancel directive.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_OMPTargetDataDirective", :value 257, :enum "CXCursorKind", :raw-comment "/** OpenMP target data directive.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_OMPTaskLoopDirective", :value 258, :enum "CXCursorKind", :raw-comment "/** OpenMP taskloop directive.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_OMPTaskLoopSimdDirective", :value 259, :enum "CXCursorKind", :raw-comment "/** OpenMP taskloop simd directive.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_OMPDistributeDirective", :value 260, :enum "CXCursorKind", :raw-comment "/** OpenMP distribute directive.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_OMPTargetEnterDataDirective", :value 261, :enum "CXCursorKind", :raw-comment "/** OpenMP target enter data directive.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_OMPTargetExitDataDirective", :value 262, :enum "CXCursorKind", :raw-comment "/** OpenMP target exit data directive.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_OMPTargetParallelDirective", :value 263, :enum "CXCursorKind", :raw-comment "/** OpenMP target parallel directive.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_OMPTargetParallelForDirective", :value 264, :enum "CXCursorKind", :raw-comment "/** OpenMP target parallel for directive.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_OMPTargetUpdateDirective", :value 265, :enum "CXCursorKind", :raw-comment "/** OpenMP target update directive.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_OMPDistributeParallelForDirective", :value 266, :enum "CXCursorKind", :raw-comment "/** OpenMP distribute parallel for directive.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_OMPDistributeParallelForSimdDirective", :value 267, :enum "CXCursorKind", :raw-comment "/** OpenMP distribute parallel for simd directive.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_OMPDistributeSimdDirective", :value 268, :enum "CXCursorKind", :raw-comment "/** OpenMP distribute simd directive.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_OMPTargetParallelForSimdDirective", :value 269, :enum "CXCursorKind", :raw-comment "/** OpenMP target parallel for simd directive.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_OMPTargetSimdDirective", :value 270, :enum "CXCursorKind", :raw-comment "/** OpenMP target simd directive.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_OMPTeamsDistributeDirective", :value 271, :enum "CXCursorKind", :raw-comment "/** OpenMP teams distribute directive.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_OMPTeamsDistributeSimdDirective", :value 272, :enum "CXCursorKind", :raw-comment "/** OpenMP teams distribute simd directive.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_OMPTeamsDistributeParallelForSimdDirective", :value 273, :enum "CXCursorKind", :raw-comment "/** OpenMP teams distribute parallel for simd directive.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_OMPTeamsDistributeParallelForDirective", :value 274, :enum "CXCursorKind", :raw-comment "/** OpenMP teams distribute parallel for directive.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_OMPTargetTeamsDirective", :value 275, :enum "CXCursorKind", :raw-comment "/** OpenMP target teams directive.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_OMPTargetTeamsDistributeDirective", :value 276, :enum "CXCursorKind", :raw-comment "/** OpenMP target teams distribute directive.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_OMPTargetTeamsDistributeParallelForDirective", :value 277, :enum "CXCursorKind", :raw-comment "/** OpenMP target teams distribute parallel for directive.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_OMPTargetTeamsDistributeParallelForSimdDirective", :value 278, :enum "CXCursorKind", :raw-comment "/** OpenMP target teams distribute parallel for simd directive.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_OMPTargetTeamsDistributeSimdDirective", :value 279, :enum "CXCursorKind", :raw-comment "/** OpenMP target teams distribute simd directive.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_BuiltinBitCastExpr", :value 280, :enum "CXCursorKind", :raw-comment "/** C++2a std::bit_cast expression.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_OMPMasterTaskLoopDirective", :value 281, :enum "CXCursorKind", :raw-comment "/** OpenMP master taskloop directive.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_OMPParallelMasterTaskLoopDirective", :value 282, :enum "CXCursorKind", :raw-comment "/** OpenMP parallel master taskloop directive.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_OMPMasterTaskLoopSimdDirective", :value 283, :enum "CXCursorKind", :raw-comment "/** OpenMP master taskloop simd directive.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_OMPParallelMasterTaskLoopSimdDirective", :value 284, :enum "CXCursorKind", :raw-comment "/** OpenMP parallel master taskloop simd directive.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_OMPParallelMasterDirective", :value 285, :enum "CXCursorKind", :raw-comment "/** OpenMP parallel master directive.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_OMPDepobjDirective", :value 286, :enum "CXCursorKind", :raw-comment "/** OpenMP depobj directive.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_OMPScanDirective", :value 287, :enum "CXCursorKind", :raw-comment "/** OpenMP scan directive.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_OMPTileDirective", :value 288, :enum "CXCursorKind", :raw-comment "/** OpenMP tile directive.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_OMPCanonicalLoop", :value 289, :enum "CXCursorKind", :raw-comment "/** OpenMP canonical loop.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_OMPInteropDirective", :value 290, :enum "CXCursorKind", :raw-comment "/** OpenMP interop directive.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_OMPDispatchDirective", :value 291, :enum "CXCursorKind", :raw-comment "/** OpenMP dispatch directive.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_OMPMaskedDirective", :value 292, :enum "CXCursorKind", :raw-comment "/** OpenMP masked directive.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_OMPUnrollDirective", :value 293, :enum "CXCursorKind", :raw-comment "/** OpenMP unroll directive.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_LastStmt", :value 293, :enum "CXCursorKind", :raw-comment "/** OpenMP unroll directive.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_TranslationUnit", :value 300, :enum "CXCursorKind", :raw-comment "/**\n   * Cursor that represents the translation unit itself.\n   *\n   * The translation unit cursor exists primarily to act as the root\n   * cursor for traversing the contents of a translation unit.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_FirstAttr", :value 400, :enum "CXCursorKind", :raw-comment "/**\n   * Cursor that represents the translation unit itself.\n   *\n   * The translation unit cursor exists primarily to act as the root\n   * cursor for traversing the contents of a translation unit.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_UnexposedAttr", :value 400, :enum "CXCursorKind", :raw-comment "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_IBActionAttr", :value 401, :enum "CXCursorKind", :raw-comment "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_IBOutletAttr", :value 402, :enum "CXCursorKind", :raw-comment "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_IBOutletCollectionAttr", :value 403, :enum "CXCursorKind", :raw-comment "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_CXXFinalAttr", :value 404, :enum "CXCursorKind", :raw-comment "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_CXXOverrideAttr", :value 405, :enum "CXCursorKind", :raw-comment "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_AnnotateAttr", :value 406, :enum "CXCursorKind", :raw-comment "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_AsmLabelAttr", :value 407, :enum "CXCursorKind", :raw-comment "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_PackedAttr", :value 408, :enum "CXCursorKind", :raw-comment "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_PureAttr", :value 409, :enum "CXCursorKind", :raw-comment "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_ConstAttr", :value 410, :enum "CXCursorKind", :raw-comment "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_NoDuplicateAttr", :value 411, :enum "CXCursorKind", :raw-comment "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_CUDAConstantAttr", :value 412, :enum "CXCursorKind", :raw-comment "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_CUDADeviceAttr", :value 413, :enum "CXCursorKind", :raw-comment "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_CUDAGlobalAttr", :value 414, :enum "CXCursorKind", :raw-comment "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_CUDAHostAttr", :value 415, :enum "CXCursorKind", :raw-comment "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_CUDASharedAttr", :value 416, :enum "CXCursorKind", :raw-comment "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_VisibilityAttr", :value 417, :enum "CXCursorKind", :raw-comment "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_DLLExport", :value 418, :enum "CXCursorKind", :raw-comment "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_DLLImport", :value 419, :enum "CXCursorKind", :raw-comment "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_NSReturnsRetained", :value 420, :enum "CXCursorKind", :raw-comment "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_NSReturnsNotRetained", :value 421, :enum "CXCursorKind", :raw-comment "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_NSReturnsAutoreleased", :value 422, :enum "CXCursorKind", :raw-comment "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_NSConsumesSelf", :value 423, :enum "CXCursorKind", :raw-comment "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_NSConsumed", :value 424, :enum "CXCursorKind", :raw-comment "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_ObjCException", :value 425, :enum "CXCursorKind", :raw-comment "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_ObjCNSObject", :value 426, :enum "CXCursorKind", :raw-comment "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_ObjCIndependentClass", :value 427, :enum "CXCursorKind", :raw-comment "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_ObjCPreciseLifetime", :value 428, :enum "CXCursorKind", :raw-comment "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_ObjCReturnsInnerPointer", :value 429, :enum "CXCursorKind", :raw-comment "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_ObjCRequiresSuper", :value 430, :enum "CXCursorKind", :raw-comment "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_ObjCRootClass", :value 431, :enum "CXCursorKind", :raw-comment "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_ObjCSubclassingRestricted", :value 432, :enum "CXCursorKind", :raw-comment "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_ObjCExplicitProtocolImpl", :value 433, :enum "CXCursorKind", :raw-comment "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_ObjCDesignatedInitializer", :value 434, :enum "CXCursorKind", :raw-comment "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_ObjCRuntimeVisible", :value 435, :enum "CXCursorKind", :raw-comment "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_ObjCBoxable", :value 436, :enum "CXCursorKind", :raw-comment "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_FlagEnum", :value 437, :enum "CXCursorKind", :raw-comment "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_ConvergentAttr", :value 438, :enum "CXCursorKind", :raw-comment "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_WarnUnusedAttr", :value 439, :enum "CXCursorKind", :raw-comment "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_WarnUnusedResultAttr", :value 440, :enum "CXCursorKind", :raw-comment "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_AlignedAttr", :value 441, :enum "CXCursorKind", :raw-comment "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_LastAttr", :value 441, :enum "CXCursorKind", :raw-comment "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_PreprocessingDirective", :value 500, :enum "CXCursorKind", :raw-comment "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_MacroDefinition", :value 501, :enum "CXCursorKind", :raw-comment "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_MacroExpansion", :value 502, :enum "CXCursorKind", :raw-comment "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_MacroInstantiation", :value 502, :enum "CXCursorKind", :raw-comment "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_InclusionDirective", :value 503, :enum "CXCursorKind", :raw-comment "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_FirstPreprocessing", :value 500, :enum "CXCursorKind", :raw-comment "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_LastPreprocessing", :value 503, :enum "CXCursorKind", :raw-comment "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_ModuleImportDecl", :value 600, :enum "CXCursorKind", :raw-comment "/**\n   * A module import declaration.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_TypeAliasTemplateDecl", :value 601, :enum "CXCursorKind", :raw-comment "/**\n   * A module import declaration.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_StaticAssert", :value 602, :enum "CXCursorKind", :raw-comment "/**\n   * A static_assert or _Static_assert node\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_FriendDecl", :value 603, :enum "CXCursorKind", :raw-comment "/**\n   * a friend declaration.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_FirstExtraDecl", :value 600, :enum "CXCursorKind", :raw-comment "/**\n   * a friend declaration.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_LastExtraDecl", :value 603, :enum "CXCursorKind", :raw-comment "/**\n   * a friend declaration.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCursor_OverloadCandidate", :value 700, :enum "CXCursorKind", :raw-comment "/**\n   * A code completion overload candidate.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXLinkage_Invalid", :value 0, :enum "CXLinkageKind", :raw-comment "/** This value indicates that no linkage information is available\n   * for a provided CXCursor. */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXLinkage_NoLinkage", :value 1, :enum "CXLinkageKind", :raw-comment "/**\n   * This is the linkage for variables, parameters, and so on that\n   *  have automatic storage.  This covers normal (non-extern) local variables.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXLinkage_Internal", :value 2, :enum "CXLinkageKind", :raw-comment "/** This is the linkage for static variables and static functions. */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXLinkage_UniqueExternal", :value 3, :enum "CXLinkageKind", :raw-comment "/** This is the linkage for entities with external linkage that live\n   * in C++ anonymous namespaces.*/"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXLinkage_External", :value 4, :enum "CXLinkageKind", :raw-comment "/** This is the linkage for entities with true, external linkage. */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXVisibility_Invalid", :value 0, :enum "CXVisibilityKind", :raw-comment "/** This value indicates that no visibility information is available\n   * for a provided CXCursor. */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXVisibility_Hidden", :value 1, :enum "CXVisibilityKind", :raw-comment "/** Symbol not seen by the linker. */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXVisibility_Protected", :value 2, :enum "CXVisibilityKind", :raw-comment "/** Symbol seen by the linker but resolves to a symbol inside this object. */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXVisibility_Default", :value 3, :enum "CXVisibilityKind", :raw-comment "/** Symbol seen by the linker and acts like a normal symbol. */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXLanguage_Invalid", :value 0, :enum "CXLanguageKind", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXLanguage_C", :value 1, :enum "CXLanguageKind", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXLanguage_ObjC", :value 2, :enum "CXLanguageKind", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXLanguage_CPlusPlus", :value 3, :enum "CXLanguageKind", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXTLS_None", :value 0, :enum "CXTLSKind", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXTLS_Dynamic", :value 1, :enum "CXTLSKind", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXTLS_Static", :value 2, :enum "CXTLSKind", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_Invalid", :value 0, :enum "CXTypeKind", :raw-comment "/**\n   * Represents an invalid type (e.g., where no type is available).\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_Unexposed", :value 1, :enum "CXTypeKind", :raw-comment "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_Void", :value 2, :enum "CXTypeKind", :raw-comment "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_Bool", :value 3, :enum "CXTypeKind", :raw-comment "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_Char_U", :value 4, :enum "CXTypeKind", :raw-comment "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_UChar", :value 5, :enum "CXTypeKind", :raw-comment "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_Char16", :value 6, :enum "CXTypeKind", :raw-comment "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_Char32", :value 7, :enum "CXTypeKind", :raw-comment "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_UShort", :value 8, :enum "CXTypeKind", :raw-comment "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_UInt", :value 9, :enum "CXTypeKind", :raw-comment "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_ULong", :value 10, :enum "CXTypeKind", :raw-comment "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_ULongLong", :value 11, :enum "CXTypeKind", :raw-comment "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_UInt128", :value 12, :enum "CXTypeKind", :raw-comment "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_Char_S", :value 13, :enum "CXTypeKind", :raw-comment "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_SChar", :value 14, :enum "CXTypeKind", :raw-comment "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_WChar", :value 15, :enum "CXTypeKind", :raw-comment "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_Short", :value 16, :enum "CXTypeKind", :raw-comment "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_Int", :value 17, :enum "CXTypeKind", :raw-comment "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_Long", :value 18, :enum "CXTypeKind", :raw-comment "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_LongLong", :value 19, :enum "CXTypeKind", :raw-comment "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_Int128", :value 20, :enum "CXTypeKind", :raw-comment "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_Float", :value 21, :enum "CXTypeKind", :raw-comment "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_Double", :value 22, :enum "CXTypeKind", :raw-comment "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_LongDouble", :value 23, :enum "CXTypeKind", :raw-comment "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_NullPtr", :value 24, :enum "CXTypeKind", :raw-comment "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_Overload", :value 25, :enum "CXTypeKind", :raw-comment "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_Dependent", :value 26, :enum "CXTypeKind", :raw-comment "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_ObjCId", :value 27, :enum "CXTypeKind", :raw-comment "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_ObjCClass", :value 28, :enum "CXTypeKind", :raw-comment "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_ObjCSel", :value 29, :enum "CXTypeKind", :raw-comment "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_Float128", :value 30, :enum "CXTypeKind", :raw-comment "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_Half", :value 31, :enum "CXTypeKind", :raw-comment "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_Float16", :value 32, :enum "CXTypeKind", :raw-comment "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_ShortAccum", :value 33, :enum "CXTypeKind", :raw-comment "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_Accum", :value 34, :enum "CXTypeKind", :raw-comment "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_LongAccum", :value 35, :enum "CXTypeKind", :raw-comment "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_UShortAccum", :value 36, :enum "CXTypeKind", :raw-comment "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_UAccum", :value 37, :enum "CXTypeKind", :raw-comment "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_ULongAccum", :value 38, :enum "CXTypeKind", :raw-comment "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_BFloat16", :value 39, :enum "CXTypeKind", :raw-comment "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_FirstBuiltin", :value 2, :enum "CXTypeKind", :raw-comment "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_LastBuiltin", :value 39, :enum "CXTypeKind", :raw-comment "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_Complex", :value 100, :enum "CXTypeKind", :raw-comment "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_Pointer", :value 101, :enum "CXTypeKind", :raw-comment "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_BlockPointer", :value 102, :enum "CXTypeKind", :raw-comment "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_LValueReference", :value 103, :enum "CXTypeKind", :raw-comment "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_RValueReference", :value 104, :enum "CXTypeKind", :raw-comment "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_Record", :value 105, :enum "CXTypeKind", :raw-comment "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_Enum", :value 106, :enum "CXTypeKind", :raw-comment "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_Typedef", :value 107, :enum "CXTypeKind", :raw-comment "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_ObjCInterface", :value 108, :enum "CXTypeKind", :raw-comment "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_ObjCObjectPointer", :value 109, :enum "CXTypeKind", :raw-comment "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_FunctionNoProto", :value 110, :enum "CXTypeKind", :raw-comment "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_FunctionProto", :value 111, :enum "CXTypeKind", :raw-comment "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_ConstantArray", :value 112, :enum "CXTypeKind", :raw-comment "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_Vector", :value 113, :enum "CXTypeKind", :raw-comment "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_IncompleteArray", :value 114, :enum "CXTypeKind", :raw-comment "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_VariableArray", :value 115, :enum "CXTypeKind", :raw-comment "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_DependentSizedArray", :value 116, :enum "CXTypeKind", :raw-comment "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_MemberPointer", :value 117, :enum "CXTypeKind", :raw-comment "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_Auto", :value 118, :enum "CXTypeKind", :raw-comment "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_Elaborated", :value 119, :enum "CXTypeKind", :raw-comment "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_Pipe", :value 120, :enum "CXTypeKind", :raw-comment "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_OCLImage1dRO", :value 121, :enum "CXTypeKind", :raw-comment "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_OCLImage1dArrayRO", :value 122, :enum "CXTypeKind", :raw-comment "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_OCLImage1dBufferRO", :value 123, :enum "CXTypeKind", :raw-comment "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_OCLImage2dRO", :value 124, :enum "CXTypeKind", :raw-comment "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_OCLImage2dArrayRO", :value 125, :enum "CXTypeKind", :raw-comment "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_OCLImage2dDepthRO", :value 126, :enum "CXTypeKind", :raw-comment "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_OCLImage2dArrayDepthRO", :value 127, :enum "CXTypeKind", :raw-comment "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_OCLImage2dMSAARO", :value 128, :enum "CXTypeKind", :raw-comment "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_OCLImage2dArrayMSAARO", :value 129, :enum "CXTypeKind", :raw-comment "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_OCLImage2dMSAADepthRO", :value 130, :enum "CXTypeKind", :raw-comment "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_OCLImage2dArrayMSAADepthRO", :value 131, :enum "CXTypeKind", :raw-comment "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_OCLImage3dRO", :value 132, :enum "CXTypeKind", :raw-comment "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_OCLImage1dWO", :value 133, :enum "CXTypeKind", :raw-comment "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_OCLImage1dArrayWO", :value 134, :enum "CXTypeKind", :raw-comment "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_OCLImage1dBufferWO", :value 135, :enum "CXTypeKind", :raw-comment "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_OCLImage2dWO", :value 136, :enum "CXTypeKind", :raw-comment "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_OCLImage2dArrayWO", :value 137, :enum "CXTypeKind", :raw-comment "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_OCLImage2dDepthWO", :value 138, :enum "CXTypeKind", :raw-comment "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_OCLImage2dArrayDepthWO", :value 139, :enum "CXTypeKind", :raw-comment "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_OCLImage2dMSAAWO", :value 140, :enum "CXTypeKind", :raw-comment "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_OCLImage2dArrayMSAAWO", :value 141, :enum "CXTypeKind", :raw-comment "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_OCLImage2dMSAADepthWO", :value 142, :enum "CXTypeKind", :raw-comment "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_OCLImage2dArrayMSAADepthWO", :value 143, :enum "CXTypeKind", :raw-comment "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_OCLImage3dWO", :value 144, :enum "CXTypeKind", :raw-comment "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_OCLImage1dRW", :value 145, :enum "CXTypeKind", :raw-comment "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_OCLImage1dArrayRW", :value 146, :enum "CXTypeKind", :raw-comment "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_OCLImage1dBufferRW", :value 147, :enum "CXTypeKind", :raw-comment "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_OCLImage2dRW", :value 148, :enum "CXTypeKind", :raw-comment "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_OCLImage2dArrayRW", :value 149, :enum "CXTypeKind", :raw-comment "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_OCLImage2dDepthRW", :value 150, :enum "CXTypeKind", :raw-comment "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_OCLImage2dArrayDepthRW", :value 151, :enum "CXTypeKind", :raw-comment "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_OCLImage2dMSAARW", :value 152, :enum "CXTypeKind", :raw-comment "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_OCLImage2dArrayMSAARW", :value 153, :enum "CXTypeKind", :raw-comment "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_OCLImage2dMSAADepthRW", :value 154, :enum "CXTypeKind", :raw-comment "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_OCLImage2dArrayMSAADepthRW", :value 155, :enum "CXTypeKind", :raw-comment "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_OCLImage3dRW", :value 156, :enum "CXTypeKind", :raw-comment "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_OCLSampler", :value 157, :enum "CXTypeKind", :raw-comment "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_OCLEvent", :value 158, :enum "CXTypeKind", :raw-comment "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_OCLQueue", :value 159, :enum "CXTypeKind", :raw-comment "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_OCLReserveID", :value 160, :enum "CXTypeKind", :raw-comment "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_ObjCObject", :value 161, :enum "CXTypeKind", :raw-comment "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_ObjCTypeParam", :value 162, :enum "CXTypeKind", :raw-comment "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_Attributed", :value 163, :enum "CXTypeKind", :raw-comment "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_OCLIntelSubgroupAVCMcePayload", :value 164, :enum "CXTypeKind", :raw-comment "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_OCLIntelSubgroupAVCImePayload", :value 165, :enum "CXTypeKind", :raw-comment "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_OCLIntelSubgroupAVCRefPayload", :value 166, :enum "CXTypeKind", :raw-comment "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_OCLIntelSubgroupAVCSicPayload", :value 167, :enum "CXTypeKind", :raw-comment "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_OCLIntelSubgroupAVCMceResult", :value 168, :enum "CXTypeKind", :raw-comment "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_OCLIntelSubgroupAVCImeResult", :value 169, :enum "CXTypeKind", :raw-comment "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_OCLIntelSubgroupAVCRefResult", :value 170, :enum "CXTypeKind", :raw-comment "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_OCLIntelSubgroupAVCSicResult", :value 171, :enum "CXTypeKind", :raw-comment "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_OCLIntelSubgroupAVCImeResultSingleRefStreamout", :value 172, :enum "CXTypeKind", :raw-comment "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_OCLIntelSubgroupAVCImeResultDualRefStreamout", :value 173, :enum "CXTypeKind", :raw-comment "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_OCLIntelSubgroupAVCImeSingleRefStreamin", :value 174, :enum "CXTypeKind", :raw-comment "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_OCLIntelSubgroupAVCImeDualRefStreamin", :value 175, :enum "CXTypeKind", :raw-comment "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_ExtVector", :value 176, :enum "CXTypeKind", :raw-comment "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXType_Atomic", :value 177, :enum "CXTypeKind", :raw-comment "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCallingConv_Default", :value 0, :enum "CXCallingConv", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCallingConv_C", :value 1, :enum "CXCallingConv", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCallingConv_X86StdCall", :value 2, :enum "CXCallingConv", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCallingConv_X86FastCall", :value 3, :enum "CXCallingConv", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCallingConv_X86ThisCall", :value 4, :enum "CXCallingConv", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCallingConv_X86Pascal", :value 5, :enum "CXCallingConv", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCallingConv_AAPCS", :value 6, :enum "CXCallingConv", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCallingConv_AAPCS_VFP", :value 7, :enum "CXCallingConv", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCallingConv_X86RegCall", :value 8, :enum "CXCallingConv", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCallingConv_IntelOclBicc", :value 9, :enum "CXCallingConv", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCallingConv_Win64", :value 10, :enum "CXCallingConv", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCallingConv_X86_64Win64", :value 10, :enum "CXCallingConv", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCallingConv_X86_64SysV", :value 11, :enum "CXCallingConv", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCallingConv_X86VectorCall", :value 12, :enum "CXCallingConv", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCallingConv_Swift", :value 13, :enum "CXCallingConv", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCallingConv_PreserveMost", :value 14, :enum "CXCallingConv", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCallingConv_PreserveAll", :value 15, :enum "CXCallingConv", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCallingConv_AArch64VectorCall", :value 16, :enum "CXCallingConv", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCallingConv_SwiftAsync", :value 17, :enum "CXCallingConv", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCallingConv_Invalid", :value 100, :enum "CXCallingConv", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCallingConv_Unexposed", :value 200, :enum "CXCallingConv", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXTemplateArgumentKind_Null", :value 0, :enum "CXTemplateArgumentKind", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXTemplateArgumentKind_Type", :value 1, :enum "CXTemplateArgumentKind", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXTemplateArgumentKind_Declaration", :value 2, :enum "CXTemplateArgumentKind", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXTemplateArgumentKind_NullPtr", :value 3, :enum "CXTemplateArgumentKind", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXTemplateArgumentKind_Integral", :value 4, :enum "CXTemplateArgumentKind", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXTemplateArgumentKind_Template", :value 5, :enum "CXTemplateArgumentKind", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXTemplateArgumentKind_TemplateExpansion", :value 6, :enum "CXTemplateArgumentKind", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXTemplateArgumentKind_Expression", :value 7, :enum "CXTemplateArgumentKind", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXTemplateArgumentKind_Pack", :value 8, :enum "CXTemplateArgumentKind", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXTemplateArgumentKind_Invalid", :value 9, :enum "CXTemplateArgumentKind", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXTypeNullability_NonNull", :value 0, :enum "CXTypeNullabilityKind", :raw-comment "/**\n   * Values of this type can never be null.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXTypeNullability_Nullable", :value 1, :enum "CXTypeNullabilityKind", :raw-comment "/**\n   * Values of this type can be null.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXTypeNullability_Unspecified", :value 2, :enum "CXTypeNullabilityKind", :raw-comment "/**\n   * Whether values of this type can be null is (explicitly)\n   * unspecified. This captures a (fairly rare) case where we\n   * can't conclude anything about the nullability of the type even\n   * though it has been considered.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXTypeNullability_Invalid", :value 3, :enum "CXTypeNullabilityKind", :raw-comment "/**\n   * Nullability is not applicable to this type.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXTypeNullability_NullableResult", :value 4, :enum "CXTypeNullabilityKind", :raw-comment "/**\n   * Generally behaves like Nullable, except when used in a block parameter that\n   * was imported into a swift async method. There, swift will assume that the\n   * parameter can get null even if no error occured. _Nullable parameters are\n   * assumed to only get null on error.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXTypeLayoutError_Invalid", :value -1, :enum "CXTypeLayoutError", :raw-comment "/**\n   * Type is of kind CXType_Invalid.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXTypeLayoutError_Incomplete", :value -2, :enum "CXTypeLayoutError", :raw-comment "/**\n   * The type is an incomplete Type.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXTypeLayoutError_Dependent", :value -3, :enum "CXTypeLayoutError", :raw-comment "/**\n   * The type is a dependent Type.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXTypeLayoutError_NotConstantSize", :value -4, :enum "CXTypeLayoutError", :raw-comment "/**\n   * The type is not a constant size type.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXTypeLayoutError_InvalidFieldName", :value -5, :enum "CXTypeLayoutError", :raw-comment "/**\n   * The Field name is not valid for this record.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXTypeLayoutError_Undeduced", :value -6, :enum "CXTypeLayoutError", :raw-comment "/**\n   * The type is undeduced.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXRefQualifier_None", :value 0, :enum "CXRefQualifierKind", :raw-comment "/** No ref-qualifier was provided. */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXRefQualifier_LValue", :value 1, :enum "CXRefQualifierKind", :raw-comment "/** An lvalue ref-qualifier was provided (\\c &). */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXRefQualifier_RValue", :value 2, :enum "CXRefQualifierKind", :raw-comment "/** An rvalue ref-qualifier was provided (\\c &&). */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CX_CXXInvalidAccessSpecifier", :value 0, :enum "CX_CXXAccessSpecifier", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CX_CXXPublic", :value 1, :enum "CX_CXXAccessSpecifier", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CX_CXXProtected", :value 2, :enum "CX_CXXAccessSpecifier", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CX_CXXPrivate", :value 3, :enum "CX_CXXAccessSpecifier", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CX_SC_Invalid", :value 0, :enum "CX_StorageClass", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CX_SC_None", :value 1, :enum "CX_StorageClass", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CX_SC_Extern", :value 2, :enum "CX_StorageClass", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CX_SC_Static", :value 3, :enum "CX_StorageClass", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CX_SC_PrivateExtern", :value 4, :enum "CX_StorageClass", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CX_SC_OpenCLWorkGroupLocal", :value 5, :enum "CX_StorageClass", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CX_SC_Auto", :value 6, :enum "CX_StorageClass", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CX_SC_Register", :value 7, :enum "CX_StorageClass", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXChildVisit_Break", :value 0, :enum "CXChildVisitResult", :raw-comment "/**\n   * Terminates the cursor traversal.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXChildVisit_Continue", :value 1, :enum "CXChildVisitResult", :raw-comment "/**\n   * Continues the cursor traversal with the next sibling of\n   * the cursor just visited, without visiting its children.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXChildVisit_Recurse", :value 2, :enum "CXChildVisitResult", :raw-comment "/**\n   * Recursively traverse the children of this cursor, using\n   * the same visitor and client data.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXPrintingPolicy_Indentation", :value 0, :enum "CXPrintingPolicyProperty", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXPrintingPolicy_SuppressSpecifiers", :value 1, :enum "CXPrintingPolicyProperty", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXPrintingPolicy_SuppressTagKeyword", :value 2, :enum "CXPrintingPolicyProperty", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXPrintingPolicy_IncludeTagDefinition", :value 3, :enum "CXPrintingPolicyProperty", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXPrintingPolicy_SuppressScope", :value 4, :enum "CXPrintingPolicyProperty", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXPrintingPolicy_SuppressUnwrittenScope", :value 5, :enum "CXPrintingPolicyProperty", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXPrintingPolicy_SuppressInitializers", :value 6, :enum "CXPrintingPolicyProperty", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXPrintingPolicy_ConstantArraySizeAsWritten", :value 7, :enum "CXPrintingPolicyProperty", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXPrintingPolicy_AnonymousTagLocations", :value 8, :enum "CXPrintingPolicyProperty", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXPrintingPolicy_SuppressStrongLifetime", :value 9, :enum "CXPrintingPolicyProperty", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXPrintingPolicy_SuppressLifetimeQualifiers", :value 10, :enum "CXPrintingPolicyProperty", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXPrintingPolicy_SuppressTemplateArgsInCXXConstructors", :value 11, :enum "CXPrintingPolicyProperty", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXPrintingPolicy_Bool", :value 12, :enum "CXPrintingPolicyProperty", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXPrintingPolicy_Restrict", :value 13, :enum "CXPrintingPolicyProperty", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXPrintingPolicy_Alignof", :value 14, :enum "CXPrintingPolicyProperty", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXPrintingPolicy_UnderscoreAlignof", :value 15, :enum "CXPrintingPolicyProperty", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXPrintingPolicy_UseVoidForZeroParams", :value 16, :enum "CXPrintingPolicyProperty", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXPrintingPolicy_TerseOutput", :value 17, :enum "CXPrintingPolicyProperty", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXPrintingPolicy_PolishForDeclaration", :value 18, :enum "CXPrintingPolicyProperty", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXPrintingPolicy_Half", :value 19, :enum "CXPrintingPolicyProperty", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXPrintingPolicy_MSWChar", :value 20, :enum "CXPrintingPolicyProperty", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXPrintingPolicy_IncludeNewlines", :value 21, :enum "CXPrintingPolicyProperty", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXPrintingPolicy_MSVCFormatting", :value 22, :enum "CXPrintingPolicyProperty", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXPrintingPolicy_ConstantsAsWritten", :value 23, :enum "CXPrintingPolicyProperty", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXPrintingPolicy_SuppressImplicitBase", :value 24, :enum "CXPrintingPolicyProperty", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXPrintingPolicy_FullyQualifiedName", :value 25, :enum "CXPrintingPolicyProperty", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXPrintingPolicy_LastProperty", :value 25, :enum "CXPrintingPolicyProperty", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXObjCPropertyAttr_noattr", :value 0, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXObjCPropertyAttr_readonly", :value 1, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXObjCPropertyAttr_getter", :value 2, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXObjCPropertyAttr_assign", :value 4, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXObjCPropertyAttr_readwrite", :value 8, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXObjCPropertyAttr_retain", :value 16, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXObjCPropertyAttr_copy", :value 32, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXObjCPropertyAttr_nonatomic", :value 64, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXObjCPropertyAttr_setter", :value 128, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXObjCPropertyAttr_atomic", :value 256, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXObjCPropertyAttr_weak", :value 512, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXObjCPropertyAttr_strong", :value 1024, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXObjCPropertyAttr_unsafe_unretained", :value 2048, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXObjCPropertyAttr_class", :value 4096, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXObjCPropertyAttr_noattr", :value 0, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXObjCPropertyAttr_readonly", :value 1, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXObjCPropertyAttr_getter", :value 2, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXObjCPropertyAttr_assign", :value 4, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXObjCPropertyAttr_readwrite", :value 8, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXObjCPropertyAttr_retain", :value 16, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXObjCPropertyAttr_copy", :value 32, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXObjCPropertyAttr_nonatomic", :value 64, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXObjCPropertyAttr_setter", :value 128, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXObjCPropertyAttr_atomic", :value 256, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXObjCPropertyAttr_weak", :value 512, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXObjCPropertyAttr_strong", :value 1024, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXObjCPropertyAttr_unsafe_unretained", :value 2048, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXObjCPropertyAttr_class", :value 4096, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXObjCDeclQualifier_None", :value 0, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXObjCDeclQualifier_In", :value 1, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXObjCDeclQualifier_Inout", :value 2, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXObjCDeclQualifier_Out", :value 4, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXObjCDeclQualifier_Bycopy", :value 8, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXObjCDeclQualifier_Byref", :value 16, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXObjCDeclQualifier_Oneway", :value 32, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXObjCDeclQualifier_None", :value 0, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXObjCDeclQualifier_In", :value 1, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXObjCDeclQualifier_Inout", :value 2, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXObjCDeclQualifier_Out", :value 4, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXObjCDeclQualifier_Bycopy", :value 8, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXObjCDeclQualifier_Byref", :value 16, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXObjCDeclQualifier_Oneway", :value 32, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXNameRange_WantQualifier", :value 1, :enum "CXNameRefFlags", :raw-comment "/**\n   * Include the nested-name-specifier, e.g. Foo:: in x.Foo::y, in the\n   * range.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXNameRange_WantTemplateArgs", :value 2, :enum "CXNameRefFlags", :raw-comment "/**\n   * Include the explicit template arguments, e.g. \\<int> in x.f<int>,\n   * in the range.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXNameRange_WantSinglePiece", :value 4, :enum "CXNameRefFlags", :raw-comment "/**\n   * If the name is non-contiguous, return the full spanning range.\n   *\n   * Non-contiguous names occur in Objective-C when a selector with two or more\n   * parameters is used, or in C++ when using an operator:\n   * \\code\n   * [object doSomething:here withValue:there]; // Objective-C\n   * return some_vector[1]; // C++\n   * \\endcode\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXToken_Punctuation", :value 0, :enum "CXTokenKind", :raw-comment "/**\n   * A token that contains some kind of punctuation.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXToken_Keyword", :value 1, :enum "CXTokenKind", :raw-comment "/**\n   * A language keyword.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXToken_Identifier", :value 2, :enum "CXTokenKind", :raw-comment "/**\n   * An identifier (that is not a keyword).\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXToken_Literal", :value 3, :enum "CXTokenKind", :raw-comment "/**\n   * A numeric, string, or character literal.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXToken_Comment", :value 4, :enum "CXTokenKind", :raw-comment "/**\n   * A comment.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXToken_Punctuation", :value 0, :enum "CXTokenKind", :raw-comment "/**\n   * A token that contains some kind of punctuation.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXToken_Keyword", :value 1, :enum "CXTokenKind", :raw-comment "/**\n   * A language keyword.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXToken_Identifier", :value 2, :enum "CXTokenKind", :raw-comment "/**\n   * An identifier (that is not a keyword).\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXToken_Literal", :value 3, :enum "CXTokenKind", :raw-comment "/**\n   * A numeric, string, or character literal.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXToken_Comment", :value 4, :enum "CXTokenKind", :raw-comment "/**\n   * A comment.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCompletionChunk_Optional", :value 0, :enum "CXCompletionChunkKind", :raw-comment "/**\n   * A code-completion string that describes \"optional\" text that\n   * could be a part of the template (but is not required).\n   *\n   * The Optional chunk is the only kind of chunk that has a code-completion\n   * string for its representation, which is accessible via\n   * \\c clang_getCompletionChunkCompletionString(). The code-completion string\n   * describes an additional part of the template that is completely optional.\n   * For example, optional chunks can be used to describe the placeholders for\n   * arguments that match up with defaulted function parameters, e.g. given:\n   *\n   * \\code\n   * void f(int x, float y = 3.14, double z = 2.71828);\n   * \\endcode\n   *\n   * The code-completion string for this function would contain:\n   *   - a TypedText chunk for \"f\".\n   *   - a LeftParen chunk for \"(\".\n   *   - a Placeholder chunk for \"int x\"\n   *   - an Optional chunk containing the remaining defaulted arguments, e.g.,\n   *       - a Comma chunk for \",\"\n   *       - a Placeholder chunk for \"float y\"\n   *       - an Optional chunk containing the last defaulted argument:\n   *           - a Comma chunk for \",\"\n   *           - a Placeholder chunk for \"double z\"\n   *   - a RightParen chunk for \")\"\n   *\n   * There are many ways to handle Optional chunks. Two simple approaches are:\n   *   - Completely ignore optional chunks, in which case the template for the\n   *     function \"f\" would only include the first parameter (\"int x\").\n   *   - Fully expand all optional chunks, in which case the template for the\n   *     function \"f\" would have all of the parameters.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCompletionChunk_TypedText", :value 1, :enum "CXCompletionChunkKind", :raw-comment "/**\n   * Text that a user would be expected to type to get this\n   * code-completion result.\n   *\n   * There will be exactly one \"typed text\" chunk in a semantic string, which\n   * will typically provide the spelling of a keyword or the name of a\n   * declaration that could be used at the current code point. Clients are\n   * expected to filter the code-completion results based on the text in this\n   * chunk.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCompletionChunk_Text", :value 2, :enum "CXCompletionChunkKind", :raw-comment "/**\n   * Text that should be inserted as part of a code-completion result.\n   *\n   * A \"text\" chunk represents text that is part of the template to be\n   * inserted into user code should this particular code-completion result\n   * be selected.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCompletionChunk_Placeholder", :value 3, :enum "CXCompletionChunkKind", :raw-comment "/**\n   * Placeholder text that should be replaced by the user.\n   *\n   * A \"placeholder\" chunk marks a place where the user should insert text\n   * into the code-completion template. For example, placeholders might mark\n   * the function parameters for a function declaration, to indicate that the\n   * user should provide arguments for each of those parameters. The actual\n   * text in a placeholder is a suggestion for the text to display before\n   * the user replaces the placeholder with real code.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCompletionChunk_Informative", :value 4, :enum "CXCompletionChunkKind", :raw-comment "/**\n   * Informative text that should be displayed but never inserted as\n   * part of the template.\n   *\n   * An \"informative\" chunk contains annotations that can be displayed to\n   * help the user decide whether a particular code-completion result is the\n   * right option, but which is not part of the actual template to be inserted\n   * by code completion.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCompletionChunk_CurrentParameter", :value 5, :enum "CXCompletionChunkKind", :raw-comment "/**\n   * Text that describes the current parameter when code-completion is\n   * referring to function call, message send, or template specialization.\n   *\n   * A \"current parameter\" chunk occurs when code-completion is providing\n   * information about a parameter corresponding to the argument at the\n   * code-completion point. For example, given a function\n   *\n   * \\code\n   * int add(int x, int y);\n   * \\endcode\n   *\n   * and the source code \\c add(, where the code-completion point is after the\n   * \"(\", the code-completion string will contain a \"current parameter\" chunk\n   * for \"int x\", indicating that the current argument will initialize that\n   * parameter. After typing further, to \\c add(17, (where the code-completion\n   * point is after the \",\"), the code-completion string will contain a\n   * \"current parameter\" chunk to \"int y\".\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCompletionChunk_LeftParen", :value 6, :enum "CXCompletionChunkKind", :raw-comment "/**\n   * A left parenthesis ('('), used to initiate a function call or\n   * signal the beginning of a function parameter list.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCompletionChunk_RightParen", :value 7, :enum "CXCompletionChunkKind", :raw-comment "/**\n   * A right parenthesis (')'), used to finish a function call or\n   * signal the end of a function parameter list.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCompletionChunk_LeftBracket", :value 8, :enum "CXCompletionChunkKind", :raw-comment "/**\n   * A left bracket ('[').\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCompletionChunk_RightBracket", :value 9, :enum "CXCompletionChunkKind", :raw-comment "/**\n   * A right bracket (']').\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCompletionChunk_LeftBrace", :value 10, :enum "CXCompletionChunkKind", :raw-comment "/**\n   * A left brace ('{').\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCompletionChunk_RightBrace", :value 11, :enum "CXCompletionChunkKind", :raw-comment "/**\n   * A right brace ('}').\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCompletionChunk_LeftAngle", :value 12, :enum "CXCompletionChunkKind", :raw-comment "/**\n   * A left angle bracket ('<').\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCompletionChunk_RightAngle", :value 13, :enum "CXCompletionChunkKind", :raw-comment "/**\n   * A right angle bracket ('>').\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCompletionChunk_Comma", :value 14, :enum "CXCompletionChunkKind", :raw-comment "/**\n   * A comma separator (',').\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCompletionChunk_ResultType", :value 15, :enum "CXCompletionChunkKind", :raw-comment "/**\n   * Text that specifies the result type of a given result.\n   *\n   * This special kind of informative chunk is not meant to be inserted into\n   * the text buffer. Rather, it is meant to illustrate the type that an\n   * expression using the given completion string would have.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCompletionChunk_Colon", :value 16, :enum "CXCompletionChunkKind", :raw-comment "/**\n   * A colon (':').\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCompletionChunk_SemiColon", :value 17, :enum "CXCompletionChunkKind", :raw-comment "/**\n   * A semicolon (';').\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCompletionChunk_Equal", :value 18, :enum "CXCompletionChunkKind", :raw-comment "/**\n   * An '=' sign.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCompletionChunk_HorizontalSpace", :value 19, :enum "CXCompletionChunkKind", :raw-comment "/**\n   * Horizontal space (' ').\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCompletionChunk_VerticalSpace", :value 20, :enum "CXCompletionChunkKind", :raw-comment "/**\n   * Vertical space ('\\\\n'), after which it is generally a good idea to\n   * perform indentation.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCodeComplete_IncludeMacros", :value 1, :enum "CXCodeComplete_Flags", :raw-comment "/**\n   * Whether to include macros within the set of code\n   * completions returned.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCodeComplete_IncludeCodePatterns", :value 2, :enum "CXCodeComplete_Flags", :raw-comment "/**\n   * Whether to include code patterns for language constructs\n   * within the set of code completions, e.g., for loops.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCodeComplete_IncludeBriefComments", :value 4, :enum "CXCodeComplete_Flags", :raw-comment "/**\n   * Whether to include brief documentation within the set of code\n   * completions returned.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCodeComplete_SkipPreamble", :value 8, :enum "CXCodeComplete_Flags", :raw-comment "/**\n   * Whether to speed up completion by omitting top- or namespace-level entities\n   * defined in the preamble. There's no guarantee any particular entity is\n   * omitted. This may be useful if the headers are indexed externally.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCodeComplete_IncludeCompletionsWithFixIts", :value 16, :enum "CXCodeComplete_Flags", :raw-comment "/**\n   * Whether to include completions with small\n   * fix-its, e.g. change '.' to '->' on member access, etc.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCompletionContext_Unexposed", :value 0, :enum "CXCompletionContext", :raw-comment "/**\n   * The context for completions is unexposed, as only Clang results\n   * should be included. (This is equivalent to having no context bits set.)\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCompletionContext_AnyType", :value 1, :enum "CXCompletionContext", :raw-comment "/**\n   * Completions for any possible type should be included in the results.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCompletionContext_AnyValue", :value 2, :enum "CXCompletionContext", :raw-comment "/**\n   * Completions for any possible value (variables, function calls, etc.)\n   * should be included in the results.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCompletionContext_ObjCObjectValue", :value 4, :enum "CXCompletionContext", :raw-comment "/**\n   * Completions for values that resolve to an Objective-C object should\n   * be included in the results.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCompletionContext_ObjCSelectorValue", :value 8, :enum "CXCompletionContext", :raw-comment "/**\n   * Completions for values that resolve to an Objective-C selector\n   * should be included in the results.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCompletionContext_CXXClassTypeValue", :value 16, :enum "CXCompletionContext", :raw-comment "/**\n   * Completions for values that resolve to a C++ class type should be\n   * included in the results.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCompletionContext_DotMemberAccess", :value 32, :enum "CXCompletionContext", :raw-comment "/**\n   * Completions for fields of the member being accessed using the dot\n   * operator should be included in the results.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCompletionContext_ArrowMemberAccess", :value 64, :enum "CXCompletionContext", :raw-comment "/**\n   * Completions for fields of the member being accessed using the arrow\n   * operator should be included in the results.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCompletionContext_ObjCPropertyAccess", :value 128, :enum "CXCompletionContext", :raw-comment "/**\n   * Completions for properties of the Objective-C object being accessed\n   * using the dot operator should be included in the results.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCompletionContext_EnumTag", :value 256, :enum "CXCompletionContext", :raw-comment "/**\n   * Completions for enum tags should be included in the results.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCompletionContext_UnionTag", :value 512, :enum "CXCompletionContext", :raw-comment "/**\n   * Completions for union tags should be included in the results.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCompletionContext_StructTag", :value 1024, :enum "CXCompletionContext", :raw-comment "/**\n   * Completions for struct tags should be included in the results.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCompletionContext_ClassTag", :value 2048, :enum "CXCompletionContext", :raw-comment "/**\n   * Completions for C++ class names should be included in the results.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCompletionContext_Namespace", :value 4096, :enum "CXCompletionContext", :raw-comment "/**\n   * Completions for C++ namespaces and namespace aliases should be\n   * included in the results.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCompletionContext_NestedNameSpecifier", :value 8192, :enum "CXCompletionContext", :raw-comment "/**\n   * Completions for C++ nested name specifiers should be included in\n   * the results.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCompletionContext_ObjCInterface", :value 16384, :enum "CXCompletionContext", :raw-comment "/**\n   * Completions for Objective-C interfaces (classes) should be included\n   * in the results.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCompletionContext_ObjCProtocol", :value 32768, :enum "CXCompletionContext", :raw-comment "/**\n   * Completions for Objective-C protocols should be included in\n   * the results.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCompletionContext_ObjCCategory", :value 65536, :enum "CXCompletionContext", :raw-comment "/**\n   * Completions for Objective-C categories should be included in\n   * the results.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCompletionContext_ObjCInstanceMessage", :value 131072, :enum "CXCompletionContext", :raw-comment "/**\n   * Completions for Objective-C instance messages should be included\n   * in the results.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCompletionContext_ObjCClassMessage", :value 262144, :enum "CXCompletionContext", :raw-comment "/**\n   * Completions for Objective-C class messages should be included in\n   * the results.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCompletionContext_ObjCSelectorName", :value 524288, :enum "CXCompletionContext", :raw-comment "/**\n   * Completions for Objective-C selector names should be included in\n   * the results.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCompletionContext_MacroName", :value 1048576, :enum "CXCompletionContext", :raw-comment "/**\n   * Completions for preprocessor macro names should be included in\n   * the results.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCompletionContext_NaturalLanguage", :value 2097152, :enum "CXCompletionContext", :raw-comment "/**\n   * Natural language completions should be included in the results.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCompletionContext_IncludedFile", :value 4194304, :enum "CXCompletionContext", :raw-comment "/**\n   * #include file completions should be included in the results.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXCompletionContext_Unknown", :value 8388607, :enum "CXCompletionContext", :raw-comment "/**\n   * The current context is unknown, so set all contexts.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXEval_Int", :value 1, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXEval_Float", :value 2, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXEval_ObjCStrLiteral", :value 3, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXEval_StrLiteral", :value 4, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXEval_CFStr", :value 5, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXEval_Other", :value 6, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXEval_UnExposed", :value 0, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXEval_Int", :value 1, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXEval_Float", :value 2, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXEval_ObjCStrLiteral", :value 3, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXEval_StrLiteral", :value 4, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXEval_CFStr", :value 5, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXEval_Other", :value 6, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXEval_UnExposed", :value 0, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXVisit_Break", :value 0, :enum "CXVisitorResult", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXVisit_Continue", :value 1, :enum "CXVisitorResult", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXResult_Success", :value 0, :enum "", :raw-comment "/**\n   * Function returned successfully.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXResult_Invalid", :value 1, :enum "", :raw-comment "/**\n   * One of the parameters was invalid for the function.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXResult_VisitBreak", :value 2, :enum "", :raw-comment "/**\n   * The function was terminated by a callback (e.g. it returned\n   * CXVisit_Break)\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXResult_Success", :value 0, :enum "", :raw-comment "/**\n   * Function returned successfully.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXResult_Invalid", :value 1, :enum "", :raw-comment "/**\n   * One of the parameters was invalid for the function.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXResult_VisitBreak", :value 2, :enum "", :raw-comment "/**\n   * The function was terminated by a callback (e.g. it returned\n   * CXVisit_Break)\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxEntity_Unexposed", :value 0, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxEntity_Typedef", :value 1, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxEntity_Function", :value 2, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxEntity_Variable", :value 3, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxEntity_Field", :value 4, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxEntity_EnumConstant", :value 5, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxEntity_ObjCClass", :value 6, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxEntity_ObjCProtocol", :value 7, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxEntity_ObjCCategory", :value 8, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxEntity_ObjCInstanceMethod", :value 9, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxEntity_ObjCClassMethod", :value 10, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxEntity_ObjCProperty", :value 11, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxEntity_ObjCIvar", :value 12, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxEntity_Enum", :value 13, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxEntity_Struct", :value 14, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxEntity_Union", :value 15, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxEntity_CXXClass", :value 16, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxEntity_CXXNamespace", :value 17, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxEntity_CXXNamespaceAlias", :value 18, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxEntity_CXXStaticVariable", :value 19, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxEntity_CXXStaticMethod", :value 20, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxEntity_CXXInstanceMethod", :value 21, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxEntity_CXXConstructor", :value 22, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxEntity_CXXDestructor", :value 23, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxEntity_CXXConversionFunction", :value 24, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxEntity_CXXTypeAlias", :value 25, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxEntity_CXXInterface", :value 26, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxEntity_Unexposed", :value 0, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxEntity_Typedef", :value 1, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxEntity_Function", :value 2, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxEntity_Variable", :value 3, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxEntity_Field", :value 4, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxEntity_EnumConstant", :value 5, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxEntity_ObjCClass", :value 6, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxEntity_ObjCProtocol", :value 7, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxEntity_ObjCCategory", :value 8, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxEntity_ObjCInstanceMethod", :value 9, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxEntity_ObjCClassMethod", :value 10, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxEntity_ObjCProperty", :value 11, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxEntity_ObjCIvar", :value 12, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxEntity_Enum", :value 13, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxEntity_Struct", :value 14, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxEntity_Union", :value 15, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxEntity_CXXClass", :value 16, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxEntity_CXXNamespace", :value 17, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxEntity_CXXNamespaceAlias", :value 18, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxEntity_CXXStaticVariable", :value 19, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxEntity_CXXStaticMethod", :value 20, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxEntity_CXXInstanceMethod", :value 21, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxEntity_CXXConstructor", :value 22, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxEntity_CXXDestructor", :value 23, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxEntity_CXXConversionFunction", :value 24, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxEntity_CXXTypeAlias", :value 25, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxEntity_CXXInterface", :value 26, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxEntityLang_None", :value 0, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxEntityLang_C", :value 1, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxEntityLang_ObjC", :value 2, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxEntityLang_CXX", :value 3, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxEntityLang_Swift", :value 4, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxEntityLang_None", :value 0, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxEntityLang_C", :value 1, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxEntityLang_ObjC", :value 2, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxEntityLang_CXX", :value 3, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxEntityLang_Swift", :value 4, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxEntity_NonTemplate", :value 0, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxEntity_Template", :value 1, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxEntity_TemplatePartialSpecialization", :value 2, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxEntity_TemplateSpecialization", :value 3, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxEntity_NonTemplate", :value 0, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxEntity_Template", :value 1, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxEntity_TemplatePartialSpecialization", :value 2, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxEntity_TemplateSpecialization", :value 3, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxAttr_Unexposed", :value 0, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxAttr_IBAction", :value 1, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxAttr_IBOutlet", :value 2, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxAttr_IBOutletCollection", :value 3, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxAttr_Unexposed", :value 0, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxAttr_IBAction", :value 1, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxAttr_IBOutlet", :value 2, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxAttr_IBOutletCollection", :value 3, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxDeclFlag_Skipped", :value 1, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxDeclFlag_Skipped", :value 1, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxObjCContainer_ForwardRef", :value 0, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxObjCContainer_Interface", :value 1, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxObjCContainer_Implementation", :value 2, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxObjCContainer_ForwardRef", :value 0, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxObjCContainer_Interface", :value 1, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxObjCContainer_Implementation", :value 2, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxEntityRef_Direct", :value 1, :enum "", :raw-comment "/**\n   * The entity is referenced directly in user's code.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxEntityRef_Implicit", :value 2, :enum "", :raw-comment "/**\n   * An implicit reference, e.g. a reference of an Objective-C method\n   * via the dot syntax.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxEntityRef_Direct", :value 1, :enum "", :raw-comment "/**\n   * The entity is referenced directly in user's code.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIdxEntityRef_Implicit", :value 2, :enum "", :raw-comment "/**\n   * An implicit reference, e.g. a reference of an Objective-C method\n   * via the dot syntax.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXSymbolRole_None", :value 0, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXSymbolRole_Declaration", :value 1, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXSymbolRole_Definition", :value 2, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXSymbolRole_Reference", :value 4, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXSymbolRole_Read", :value 8, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXSymbolRole_Write", :value 16, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXSymbolRole_Call", :value 32, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXSymbolRole_Dynamic", :value 64, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXSymbolRole_AddressOf", :value 128, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXSymbolRole_Implicit", :value 256, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXSymbolRole_None", :value 0, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXSymbolRole_Declaration", :value 1, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXSymbolRole_Definition", :value 2, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXSymbolRole_Reference", :value 4, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXSymbolRole_Read", :value 8, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXSymbolRole_Write", :value 16, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXSymbolRole_Call", :value 32, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXSymbolRole_Dynamic", :value 64, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXSymbolRole_AddressOf", :value 128, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXSymbolRole_Implicit", :value 256, :enum "", :raw-comment nil} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIndexOpt_None", :value 0, :enum "", :raw-comment "/**\n   * Used to indicate that no special indexing options are needed.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIndexOpt_SuppressRedundantRefs", :value 1, :enum "", :raw-comment "/**\n   * Used to indicate that IndexerCallbacks#indexEntityReference should\n   * be invoked for only one reference of an entity per source file that does\n   * not also include a declaration/definition of the entity.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIndexOpt_IndexFunctionLocalSymbols", :value 2, :enum "", :raw-comment "/**\n   * Function-local symbols should be indexed. If this is not set\n   * function-local symbols will be ignored.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIndexOpt_IndexImplicitTemplateInstantiations", :value 4, :enum "", :raw-comment "/**\n   * Implicit function/class template instantiations should be indexed.\n   * If this is not set, implicit instantiations will be ignored.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIndexOpt_SuppressWarnings", :value 8, :enum "", :raw-comment "/**\n   * Suppress all compiler warnings when parsing for indexing.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIndexOpt_SkipParsedBodiesInSession", :value 16, :enum "", :raw-comment "/**\n   * Skip a function/method body that was already parsed during an\n   * indexing session associated with a \\c CXIndexAction object.\n   * Bodies in system headers are always skipped.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIndexOpt_None", :value 0, :enum "", :raw-comment "/**\n   * Used to indicate that no special indexing options are needed.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIndexOpt_SuppressRedundantRefs", :value 1, :enum "", :raw-comment "/**\n   * Used to indicate that IndexerCallbacks#indexEntityReference should\n   * be invoked for only one reference of an entity per source file that does\n   * not also include a declaration/definition of the entity.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIndexOpt_IndexFunctionLocalSymbols", :value 2, :enum "", :raw-comment "/**\n   * Function-local symbols should be indexed. If this is not set\n   * function-local symbols will be ignored.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIndexOpt_IndexImplicitTemplateInstantiations", :value 4, :enum "", :raw-comment "/**\n   * Implicit function/class template instantiations should be indexed.\n   * If this is not set, implicit instantiations will be ignored.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIndexOpt_SuppressWarnings", :value 8, :enum "", :raw-comment "/**\n   * Suppress all compiler warnings when parsing for indexing.\n   */"} {:kind "CXCursor_EnumConstantDecl", :type "CXType_Int", :name "CXIndexOpt_SkipParsedBodiesInSession", :value 16, :enum "", :raw-comment "/**\n   * Skip a function/method body that was already parsed during an\n   * indexing session associated with a \\c CXIndexAction object.\n   * Bodies in system headers are always skipped.\n   */"})}