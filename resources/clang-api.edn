{:functions ({:args ({:spelling "string", :type "CXString"}), :ret {:spelling "const char *", :type "const char *"}, :function/args [:clang/CXString], :symbol "clang_getCString", :name "clang_getCString", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getCString, :doc "/**\n * Retrieve the character data associated with the given string.\n */"} {:args ({:spelling "string", :type "CXString"}), :ret {:spelling "void", :type "void"}, :function/args [:clang/CXString], :symbol "clang_disposeString", :name "clang_disposeString", :function/ret :coffi.mem/void, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_disposeString, :doc "/**\n * Free the given string.\n */"} {:args ({:spelling "set", :type "CXStringSet *"}), :ret {:spelling "void", :type "void"}, :function/args [[:coffi.mem/pointer :clang/CXStringSet]], :symbol "clang_disposeStringSet", :name "clang_disposeStringSet", :function/ret :coffi.mem/void, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_disposeStringSet, :doc "/**\n * Free the given string set.\n */"} {:args (), :ret {:spelling "unsigned long long", :type "unsigned long long"}, :function/args [], :symbol "clang_getBuildSessionTimestamp", :name "clang_getBuildSessionTimestamp", :function/ret :coffi.mem/long, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getBuildSessionTimestamp, :doc "/**\n * Return the timestamp for use with Clang's\n * \\c -fbuild-session-timestamp= option.\n */"} {:args ({:spelling "options", :type "unsigned int"}), :ret {:spelling "CXVirtualFileOverlay", :type "struct CXVirtualFileOverlayImpl *"}, :function/args [:coffi.mem/int], :symbol "clang_VirtualFileOverlay_create", :name "clang_VirtualFileOverlay_create", :function/ret [:coffi.mem/pointer :clang/CXVirtualFileOverlayImpl], :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_VirtualFileOverlay_create, :doc "/**\n * Create a \\c CXVirtualFileOverlay object.\n * Must be disposed with \\c clang_VirtualFileOverlay_dispose().\n *\n * \\param options is reserved, always pass 0.\n */"} {:args ({:spelling "", :type "struct CXVirtualFileOverlayImpl *"} {:spelling "virtualPath", :type "const char *"} {:spelling "realPath", :type "const char *"}), :ret {:spelling "enum CXErrorCode", :type "enum CXErrorCode"}, :function/args [[:coffi.mem/pointer :clang/CXVirtualFileOverlayImpl] [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/char]], :symbol "clang_VirtualFileOverlay_addFileMapping", :name "clang_VirtualFileOverlay_addFileMapping", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_VirtualFileOverlay_addFileMapping, :doc "/**\n * Map an absolute virtual file path to an absolute real one.\n * The virtual path must be canonicalized (not contain \".\"/\"..\").\n * \\returns 0 for success, non-zero to indicate an error.\n */"} {:args ({:spelling "", :type "struct CXVirtualFileOverlayImpl *"} {:spelling "caseSensitive", :type "int"}), :ret {:spelling "enum CXErrorCode", :type "enum CXErrorCode"}, :function/args [[:coffi.mem/pointer :clang/CXVirtualFileOverlayImpl] :coffi.mem/int], :symbol "clang_VirtualFileOverlay_setCaseSensitivity", :name "clang_VirtualFileOverlay_setCaseSensitivity", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_VirtualFileOverlay_setCaseSensitivity, :doc "/**\n * Set the case sensitivity for the \\c CXVirtualFileOverlay object.\n * The \\c CXVirtualFileOverlay object is case-sensitive by default, this\n * option can be used to override the default.\n * \\returns 0 for success, non-zero to indicate an error.\n */"} {:args ({:spelling "", :type "struct CXVirtualFileOverlayImpl *"} {:spelling "options", :type "unsigned int"} {:spelling "out_buffer_ptr", :type "char **"} {:spelling "out_buffer_size", :type "unsigned int *"}), :ret {:spelling "enum CXErrorCode", :type "enum CXErrorCode"}, :function/args [[:coffi.mem/pointer :clang/CXVirtualFileOverlayImpl] :coffi.mem/int [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]] [:coffi.mem/pointer :coffi.mem/int]], :symbol "clang_VirtualFileOverlay_writeToBuffer", :name "clang_VirtualFileOverlay_writeToBuffer", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_VirtualFileOverlay_writeToBuffer, :doc "/**\n * Write out the \\c CXVirtualFileOverlay object to a char buffer.\n *\n * \\param options is reserved, always pass 0.\n * \\param out_buffer_ptr pointer to receive the buffer pointer, which should be\n * disposed using \\c clang_free().\n * \\param out_buffer_size pointer to receive the buffer size.\n * \\returns 0 for success, non-zero to indicate an error.\n */"} {:args ({:spelling "buffer", :type "void *"}), :ret {:spelling "void", :type "void"}, :function/args [:coffi.mem/pointer], :symbol "clang_free", :name "clang_free", :function/ret :coffi.mem/void, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_free, :doc "/**\n * free memory allocated by libclang, such as the buffer returned by\n * \\c CXVirtualFileOverlay() or \\c clang_ModuleMapDescriptor_writeToBuffer().\n *\n * \\param buffer memory pointer to free.\n */"} {:args ({:spelling "", :type "struct CXVirtualFileOverlayImpl *"}), :ret {:spelling "void", :type "void"}, :function/args [[:coffi.mem/pointer :clang/CXVirtualFileOverlayImpl]], :symbol "clang_VirtualFileOverlay_dispose", :name "clang_VirtualFileOverlay_dispose", :function/ret :coffi.mem/void, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_VirtualFileOverlay_dispose, :doc "/**\n * Dispose a \\c CXVirtualFileOverlay object.\n */"} {:args ({:spelling "options", :type "unsigned int"}), :ret {:spelling "CXModuleMapDescriptor", :type "struct CXModuleMapDescriptorImpl *"}, :function/args [:coffi.mem/int], :symbol "clang_ModuleMapDescriptor_create", :name "clang_ModuleMapDescriptor_create", :function/ret [:coffi.mem/pointer :clang/CXModuleMapDescriptorImpl], :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_ModuleMapDescriptor_create, :doc "/**\n * Create a \\c CXModuleMapDescriptor object.\n * Must be disposed with \\c clang_ModuleMapDescriptor_dispose().\n *\n * \\param options is reserved, always pass 0.\n */"} {:args ({:spelling "", :type "struct CXModuleMapDescriptorImpl *"} {:spelling "name", :type "const char *"}), :ret {:spelling "enum CXErrorCode", :type "enum CXErrorCode"}, :function/args [[:coffi.mem/pointer :clang/CXModuleMapDescriptorImpl] [:coffi.mem/pointer :coffi.mem/char]], :symbol "clang_ModuleMapDescriptor_setFrameworkModuleName", :name "clang_ModuleMapDescriptor_setFrameworkModuleName", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_ModuleMapDescriptor_setFrameworkModuleName, :doc "/**\n * Sets the framework module name that the module.map describes.\n * \\returns 0 for success, non-zero to indicate an error.\n */"} {:args ({:spelling "", :type "struct CXModuleMapDescriptorImpl *"} {:spelling "name", :type "const char *"}), :ret {:spelling "enum CXErrorCode", :type "enum CXErrorCode"}, :function/args [[:coffi.mem/pointer :clang/CXModuleMapDescriptorImpl] [:coffi.mem/pointer :coffi.mem/char]], :symbol "clang_ModuleMapDescriptor_setUmbrellaHeader", :name "clang_ModuleMapDescriptor_setUmbrellaHeader", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_ModuleMapDescriptor_setUmbrellaHeader, :doc "/**\n * Sets the umbrella header name that the module.map describes.\n * \\returns 0 for success, non-zero to indicate an error.\n */"} {:args ({:spelling "", :type "struct CXModuleMapDescriptorImpl *"} {:spelling "options", :type "unsigned int"} {:spelling "out_buffer_ptr", :type "char **"} {:spelling "out_buffer_size", :type "unsigned int *"}), :ret {:spelling "enum CXErrorCode", :type "enum CXErrorCode"}, :function/args [[:coffi.mem/pointer :clang/CXModuleMapDescriptorImpl] :coffi.mem/int [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]] [:coffi.mem/pointer :coffi.mem/int]], :symbol "clang_ModuleMapDescriptor_writeToBuffer", :name "clang_ModuleMapDescriptor_writeToBuffer", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_ModuleMapDescriptor_writeToBuffer, :doc "/**\n * Write out the \\c CXModuleMapDescriptor object to a char buffer.\n *\n * \\param options is reserved, always pass 0.\n * \\param out_buffer_ptr pointer to receive the buffer pointer, which should be\n * disposed using \\c clang_free().\n * \\param out_buffer_size pointer to receive the buffer size.\n * \\returns 0 for success, non-zero to indicate an error.\n */"} {:args ({:spelling "", :type "struct CXModuleMapDescriptorImpl *"}), :ret {:spelling "void", :type "void"}, :function/args [[:coffi.mem/pointer :clang/CXModuleMapDescriptorImpl]], :symbol "clang_ModuleMapDescriptor_dispose", :name "clang_ModuleMapDescriptor_dispose", :function/ret :coffi.mem/void, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_ModuleMapDescriptor_dispose, :doc "/**\n * Dispose a \\c CXModuleMapDescriptor object.\n */"} {:args ({:spelling "excludeDeclarationsFromPCH", :type "int"} {:spelling "displayDiagnostics", :type "int"}), :ret {:spelling "CXIndex", :type "void *"}, :function/args [:coffi.mem/int :coffi.mem/int], :symbol "clang_createIndex", :name "clang_createIndex", :function/ret :coffi.mem/pointer, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_createIndex, :doc "/**\n * Provides a shared context for creating translation units.\n *\n * It provides two options:\n *\n * - excludeDeclarationsFromPCH: When non-zero, allows enumeration of \"local\"\n * declarations (when loading any new translation units). A \"local\" declaration\n * is one that belongs in the translation unit itself and not in a precompiled\n * header that was used by the translation unit. If zero, all declarations\n * will be enumerated.\n *\n * Here is an example:\n *\n * \\code\n *   // excludeDeclsFromPCH = 1, displayDiagnostics=1\n *   Idx = clang_createIndex(1, 1);\n *\n *   // IndexTest.pch was produced with the following command:\n *   // \"clang -x c IndexTest.h -emit-ast -o IndexTest.pch\"\n *   TU = clang_createTranslationUnit(Idx, \"IndexTest.pch\");\n *\n *   // This will load all the symbols from 'IndexTest.pch'\n *   clang_visitChildren(clang_getTranslationUnitCursor(TU),\n *                       TranslationUnitVisitor, 0);\n *   clang_disposeTranslationUnit(TU);\n *\n *   // This will load all the symbols from 'IndexTest.c', excluding symbols\n *   // from 'IndexTest.pch'.\n *   char *args[] = { \"-Xclang\", \"-include-pch=IndexTest.pch\" };\n *   TU = clang_createTranslationUnitFromSourceFile(Idx, \"IndexTest.c\", 2, args,\n *                                                  0, 0);\n *   clang_visitChildren(clang_getTranslationUnitCursor(TU),\n *                       TranslationUnitVisitor, 0);\n *   clang_disposeTranslationUnit(TU);\n * \\endcode\n *\n * This process of creating the 'pch', loading it separately, and using it (via\n * -include-pch) allows 'excludeDeclsFromPCH' to remove redundant callbacks\n * (which gives the indexer the same performance benefit as the compiler).\n */"} {:args ({:spelling "index", :type "void *"}), :ret {:spelling "void", :type "void"}, :function/args [:coffi.mem/pointer], :symbol "clang_disposeIndex", :name "clang_disposeIndex", :function/ret :coffi.mem/void, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_disposeIndex, :doc "/**\n * Destroy the given index.\n *\n * The index must not be destroyed until all of the translation units created\n * within that index have been destroyed.\n */"} {:args ({:spelling "", :type "void *"} {:spelling "options", :type "unsigned int"}), :ret {:spelling "void", :type "void"}, :function/args [:coffi.mem/pointer :coffi.mem/int], :symbol "clang_CXIndex_setGlobalOptions", :name "clang_CXIndex_setGlobalOptions", :function/ret :coffi.mem/void, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_CXIndex_setGlobalOptions, :doc "/**\n * Sets general options associated with a CXIndex.\n *\n * For example:\n * \\code\n * CXIndex idx = ...;\n * clang_CXIndex_setGlobalOptions(idx,\n *     clang_CXIndex_getGlobalOptions(idx) |\n *     CXGlobalOpt_ThreadBackgroundPriorityForIndexing);\n * \\endcode\n *\n * \\param options A bitmask of options, a bitwise OR of CXGlobalOpt_XXX flags.\n */"} {:args ({:spelling "", :type "void *"}), :ret {:spelling "unsigned int", :type "unsigned int"}, :function/args [:coffi.mem/pointer], :symbol "clang_CXIndex_getGlobalOptions", :name "clang_CXIndex_getGlobalOptions", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_CXIndex_getGlobalOptions, :doc "/**\n * Gets the general options associated with a CXIndex.\n *\n * \\returns A bitmask of options, a bitwise OR of CXGlobalOpt_XXX flags that\n * are associated with the given CXIndex object.\n */"} {:args ({:spelling "", :type "void *"} {:spelling "Path", :type "const char *"}), :ret {:spelling "void", :type "void"}, :function/args [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]], :symbol "clang_CXIndex_setInvocationEmissionPathOption", :name "clang_CXIndex_setInvocationEmissionPathOption", :function/ret :coffi.mem/void, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_CXIndex_setInvocationEmissionPathOption, :doc "/**\n * Sets the invocation emission path option in a CXIndex.\n *\n * The invocation emission path specifies a path which will contain log\n * files for certain libclang invocations. A null value (default) implies that\n * libclang invocations are not logged..\n */"} {:args ({:spelling "SFile", :type "void *"}), :ret {:spelling "CXString", :type "CXString"}, :function/args [:coffi.mem/pointer], :symbol "clang_getFileName", :name "clang_getFileName", :function/ret :clang/CXString, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getFileName, :doc "/**\n * Retrieve the complete file and path name of the given file.\n */"} {:args ({:spelling "SFile", :type "void *"}), :ret {:spelling "int", :type "int"}, :function/args [:coffi.mem/pointer], :symbol "clang_getFileTime", :name "clang_getFileTime", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getFileTime, :doc "/**\n * Retrieve the last modification time of the given file.\n */"} {:args ({:spelling "file", :type "void *"} {:spelling "outID", :type "CXFileUniqueID *"}), :ret {:spelling "int", :type "int"}, :function/args [:coffi.mem/pointer [:coffi.mem/pointer :clang/CXFileUniqueID]], :symbol "clang_getFileUniqueID", :name "clang_getFileUniqueID", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getFileUniqueID, :doc "/**\n * Retrieve the unique ID for the given \\c file.\n *\n * \\param file the file to get the ID for.\n * \\param outID stores the returned CXFileUniqueID.\n * \\returns If there was a failure getting the unique ID, returns non-zero,\n * otherwise returns 0.\n */"} {:args ({:spelling "tu", :type "struct CXTranslationUnitImpl *"} {:spelling "file", :type "void *"}), :ret {:spelling "unsigned int", :type "unsigned int"}, :function/args [[:coffi.mem/pointer :clang/CXTranslationUnitImpl] :coffi.mem/pointer], :symbol "clang_isFileMultipleIncludeGuarded", :name "clang_isFileMultipleIncludeGuarded", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_isFileMultipleIncludeGuarded, :doc "/**\n * Determine whether the given header is guarded against\n * multiple inclusions, either with the conventional\n * \\#ifndef/\\#define/\\#endif macro guards or with \\#pragma once.\n */"} {:args ({:spelling "tu", :type "struct CXTranslationUnitImpl *"} {:spelling "file_name", :type "const char *"}), :ret {:spelling "CXFile", :type "void *"}, :function/args [[:coffi.mem/pointer :clang/CXTranslationUnitImpl] [:coffi.mem/pointer :coffi.mem/char]], :symbol "clang_getFile", :name "clang_getFile", :function/ret :coffi.mem/pointer, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getFile, :doc "/**\n * Retrieve a file handle within the given translation unit.\n *\n * \\param tu the translation unit\n *\n * \\param file_name the name of the file.\n *\n * \\returns the file handle for the named file in the translation unit \\p tu,\n * or a NULL file handle if the file was not a part of this translation unit.\n */"} {:args ({:spelling "tu", :type "struct CXTranslationUnitImpl *"} {:spelling "file", :type "void *"} {:spelling "size", :type "int *"}), :ret {:spelling "const char *", :type "const char *"}, :function/args [[:coffi.mem/pointer :clang/CXTranslationUnitImpl] :coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/int]], :symbol "clang_getFileContents", :name "clang_getFileContents", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getFileContents, :doc "/**\n * Retrieve the buffer associated with the given file.\n *\n * \\param tu the translation unit\n *\n * \\param file the file for which to retrieve the buffer.\n *\n * \\param size [out] if non-NULL, will be set to the size of the buffer.\n *\n * \\returns a pointer to the buffer in memory that holds the contents of\n * \\p file, or a NULL pointer when the file is not loaded.\n */"} {:args ({:spelling "file1", :type "void *"} {:spelling "file2", :type "void *"}), :ret {:spelling "int", :type "int"}, :function/args [:coffi.mem/pointer :coffi.mem/pointer], :symbol "clang_File_isEqual", :name "clang_File_isEqual", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_File_isEqual, :doc "/**\n * Returns non-zero if the \\c file1 and \\c file2 point to the same file,\n * or they are both NULL.\n */"} {:args ({:spelling "file", :type "void *"}), :ret {:spelling "CXString", :type "CXString"}, :function/args [:coffi.mem/pointer], :symbol "clang_File_tryGetRealPathName", :name "clang_File_tryGetRealPathName", :function/ret :clang/CXString, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_File_tryGetRealPathName, :doc "/**\n * Returns the real path name of \\c file.\n *\n * An empty string may be returned. Use \\c clang_getFileName() in that case.\n */"} {:args (), :ret {:spelling "CXSourceLocation", :type "CXSourceLocation"}, :function/args [], :symbol "clang_getNullLocation", :name "clang_getNullLocation", :function/ret :clang/CXSourceLocation, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getNullLocation, :doc "/**\n * Retrieve a NULL (invalid) source location.\n */"} {:args ({:spelling "loc1", :type "CXSourceLocation"} {:spelling "loc2", :type "CXSourceLocation"}), :ret {:spelling "unsigned int", :type "unsigned int"}, :function/args [:clang/CXSourceLocation :clang/CXSourceLocation], :symbol "clang_equalLocations", :name "clang_equalLocations", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_equalLocations, :doc "/**\n * Determine whether two source locations, which must refer into\n * the same translation unit, refer to exactly the same point in the source\n * code.\n *\n * \\returns non-zero if the source locations refer to the same location, zero\n * if they refer to different locations.\n */"} {:args ({:spelling "tu", :type "struct CXTranslationUnitImpl *"} {:spelling "file", :type "void *"} {:spelling "line", :type "unsigned int"} {:spelling "column", :type "unsigned int"}), :ret {:spelling "CXSourceLocation", :type "CXSourceLocation"}, :function/args [[:coffi.mem/pointer :clang/CXTranslationUnitImpl] :coffi.mem/pointer :coffi.mem/int :coffi.mem/int], :symbol "clang_getLocation", :name "clang_getLocation", :function/ret :clang/CXSourceLocation, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getLocation, :doc "/**\n * Retrieves the source location associated with a given file/line/column\n * in a particular translation unit.\n */"} {:args ({:spelling "tu", :type "struct CXTranslationUnitImpl *"} {:spelling "file", :type "void *"} {:spelling "offset", :type "unsigned int"}), :ret {:spelling "CXSourceLocation", :type "CXSourceLocation"}, :function/args [[:coffi.mem/pointer :clang/CXTranslationUnitImpl] :coffi.mem/pointer :coffi.mem/int], :symbol "clang_getLocationForOffset", :name "clang_getLocationForOffset", :function/ret :clang/CXSourceLocation, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getLocationForOffset, :doc "/**\n * Retrieves the source location associated with a given character offset\n * in a particular translation unit.\n */"} {:args ({:spelling "location", :type "CXSourceLocation"}), :ret {:spelling "int", :type "int"}, :function/args [:clang/CXSourceLocation], :symbol "clang_Location_isInSystemHeader", :name "clang_Location_isInSystemHeader", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_Location_isInSystemHeader, :doc "/**\n * Returns non-zero if the given source location is in a system header.\n */"} {:args ({:spelling "location", :type "CXSourceLocation"}), :ret {:spelling "int", :type "int"}, :function/args [:clang/CXSourceLocation], :symbol "clang_Location_isFromMainFile", :name "clang_Location_isFromMainFile", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_Location_isFromMainFile, :doc "/**\n * Returns non-zero if the given source location is in the main file of\n * the corresponding translation unit.\n */"} {:args (), :ret {:spelling "CXSourceRange", :type "CXSourceRange"}, :function/args [], :symbol "clang_getNullRange", :name "clang_getNullRange", :function/ret :clang/CXSourceRange, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getNullRange, :doc "/**\n * Retrieve a NULL (invalid) source range.\n */"} {:args ({:spelling "begin", :type "CXSourceLocation"} {:spelling "end", :type "CXSourceLocation"}), :ret {:spelling "CXSourceRange", :type "CXSourceRange"}, :function/args [:clang/CXSourceLocation :clang/CXSourceLocation], :symbol "clang_getRange", :name "clang_getRange", :function/ret :clang/CXSourceRange, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getRange, :doc "/**\n * Retrieve a source range given the beginning and ending source\n * locations.\n */"} {:args ({:spelling "range1", :type "CXSourceRange"} {:spelling "range2", :type "CXSourceRange"}), :ret {:spelling "unsigned int", :type "unsigned int"}, :function/args [:clang/CXSourceRange :clang/CXSourceRange], :symbol "clang_equalRanges", :name "clang_equalRanges", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_equalRanges, :doc "/**\n * Determine whether two ranges are equivalent.\n *\n * \\returns non-zero if the ranges are the same, zero if they differ.\n */"} {:args ({:spelling "range", :type "CXSourceRange"}), :ret {:spelling "int", :type "int"}, :function/args [:clang/CXSourceRange], :symbol "clang_Range_isNull", :name "clang_Range_isNull", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_Range_isNull, :doc "/**\n * Returns non-zero if \\p range is null.\n */"} {:args ({:spelling "location", :type "CXSourceLocation"} {:spelling "file", :type "void **"} {:spelling "line", :type "unsigned int *"} {:spelling "column", :type "unsigned int *"} {:spelling "offset", :type "unsigned int *"}), :ret {:spelling "void", :type "void"}, :function/args [:clang/CXSourceLocation [:coffi.mem/pointer :coffi.mem/pointer] [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :coffi.mem/int]], :symbol "clang_getExpansionLocation", :name "clang_getExpansionLocation", :function/ret :coffi.mem/void, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getExpansionLocation, :doc "/**\n * Retrieve the file, line, column, and offset represented by\n * the given source location.\n *\n * If the location refers into a macro expansion, retrieves the\n * location of the macro expansion.\n *\n * \\param location the location within a source file that will be decomposed\n * into its parts.\n *\n * \\param file [out] if non-NULL, will be set to the file to which the given\n * source location points.\n *\n * \\param line [out] if non-NULL, will be set to the line to which the given\n * source location points.\n *\n * \\param column [out] if non-NULL, will be set to the column to which the given\n * source location points.\n *\n * \\param offset [out] if non-NULL, will be set to the offset into the\n * buffer to which the given source location points.\n */"} {:args ({:spelling "location", :type "CXSourceLocation"} {:spelling "filename", :type "CXString *"} {:spelling "line", :type "unsigned int *"} {:spelling "column", :type "unsigned int *"}), :ret {:spelling "void", :type "void"}, :function/args [:clang/CXSourceLocation [:coffi.mem/pointer :clang/CXString] [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :coffi.mem/int]], :symbol "clang_getPresumedLocation", :name "clang_getPresumedLocation", :function/ret :coffi.mem/void, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getPresumedLocation, :doc "/**\n * Retrieve the file, line and column represented by the given source\n * location, as specified in a # line directive.\n *\n * Example: given the following source code in a file somefile.c\n *\n * \\code\n * #123 \"dummy.c\" 1\n *\n * static int func(void)\n * {\n *     return 0;\n * }\n * \\endcode\n *\n * the location information returned by this function would be\n *\n * File: dummy.c Line: 124 Column: 12\n *\n * whereas clang_getExpansionLocation would have returned\n *\n * File: somefile.c Line: 3 Column: 12\n *\n * \\param location the location within a source file that will be decomposed\n * into its parts.\n *\n * \\param filename [out] if non-NULL, will be set to the filename of the\n * source location. Note that filenames returned will be for \"virtual\" files,\n * which don't necessarily exist on the machine running clang - e.g. when\n * parsing preprocessed output obtained from a different environment. If\n * a non-NULL value is passed in, remember to dispose of the returned value\n * using \\c clang_disposeString() once you've finished with it. For an invalid\n * source location, an empty string is returned.\n *\n * \\param line [out] if non-NULL, will be set to the line number of the\n * source location. For an invalid source location, zero is returned.\n *\n * \\param column [out] if non-NULL, will be set to the column number of the\n * source location. For an invalid source location, zero is returned.\n */"} {:args ({:spelling "location", :type "CXSourceLocation"} {:spelling "file", :type "void **"} {:spelling "line", :type "unsigned int *"} {:spelling "column", :type "unsigned int *"} {:spelling "offset", :type "unsigned int *"}), :ret {:spelling "void", :type "void"}, :function/args [:clang/CXSourceLocation [:coffi.mem/pointer :coffi.mem/pointer] [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :coffi.mem/int]], :symbol "clang_getInstantiationLocation", :name "clang_getInstantiationLocation", :function/ret :coffi.mem/void, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getInstantiationLocation, :doc "/**\n * Legacy API to retrieve the file, line, column, and offset represented\n * by the given source location.\n *\n * This interface has been replaced by the newer interface\n * #clang_getExpansionLocation(). See that interface's documentation for\n * details.\n */"} {:args ({:spelling "location", :type "CXSourceLocation"} {:spelling "file", :type "void **"} {:spelling "line", :type "unsigned int *"} {:spelling "column", :type "unsigned int *"} {:spelling "offset", :type "unsigned int *"}), :ret {:spelling "void", :type "void"}, :function/args [:clang/CXSourceLocation [:coffi.mem/pointer :coffi.mem/pointer] [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :coffi.mem/int]], :symbol "clang_getSpellingLocation", :name "clang_getSpellingLocation", :function/ret :coffi.mem/void, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getSpellingLocation, :doc "/**\n * Retrieve the file, line, column, and offset represented by\n * the given source location.\n *\n * If the location refers into a macro instantiation, return where the\n * location was originally spelled in the source file.\n *\n * \\param location the location within a source file that will be decomposed\n * into its parts.\n *\n * \\param file [out] if non-NULL, will be set to the file to which the given\n * source location points.\n *\n * \\param line [out] if non-NULL, will be set to the line to which the given\n * source location points.\n *\n * \\param column [out] if non-NULL, will be set to the column to which the given\n * source location points.\n *\n * \\param offset [out] if non-NULL, will be set to the offset into the\n * buffer to which the given source location points.\n */"} {:args ({:spelling "location", :type "CXSourceLocation"} {:spelling "file", :type "void **"} {:spelling "line", :type "unsigned int *"} {:spelling "column", :type "unsigned int *"} {:spelling "offset", :type "unsigned int *"}), :ret {:spelling "void", :type "void"}, :function/args [:clang/CXSourceLocation [:coffi.mem/pointer :coffi.mem/pointer] [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :coffi.mem/int]], :symbol "clang_getFileLocation", :name "clang_getFileLocation", :function/ret :coffi.mem/void, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getFileLocation, :doc "/**\n * Retrieve the file, line, column, and offset represented by\n * the given source location.\n *\n * If the location refers into a macro expansion, return where the macro was\n * expanded or where the macro argument was written, if the location points at\n * a macro argument.\n *\n * \\param location the location within a source file that will be decomposed\n * into its parts.\n *\n * \\param file [out] if non-NULL, will be set to the file to which the given\n * source location points.\n *\n * \\param line [out] if non-NULL, will be set to the line to which the given\n * source location points.\n *\n * \\param column [out] if non-NULL, will be set to the column to which the given\n * source location points.\n *\n * \\param offset [out] if non-NULL, will be set to the offset into the\n * buffer to which the given source location points.\n */"} {:args ({:spelling "range", :type "CXSourceRange"}), :ret {:spelling "CXSourceLocation", :type "CXSourceLocation"}, :function/args [:clang/CXSourceRange], :symbol "clang_getRangeStart", :name "clang_getRangeStart", :function/ret :clang/CXSourceLocation, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getRangeStart, :doc "/**\n * Retrieve a source location representing the first character within a\n * source range.\n */"} {:args ({:spelling "range", :type "CXSourceRange"}), :ret {:spelling "CXSourceLocation", :type "CXSourceLocation"}, :function/args [:clang/CXSourceRange], :symbol "clang_getRangeEnd", :name "clang_getRangeEnd", :function/ret :clang/CXSourceLocation, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getRangeEnd, :doc "/**\n * Retrieve a source location representing the last character within a\n * source range.\n */"} {:args ({:spelling "tu", :type "struct CXTranslationUnitImpl *"} {:spelling "file", :type "void *"}), :ret {:spelling "CXSourceRangeList *", :type "CXSourceRangeList *"}, :function/args [[:coffi.mem/pointer :clang/CXTranslationUnitImpl] :coffi.mem/pointer], :symbol "clang_getSkippedRanges", :name "clang_getSkippedRanges", :function/ret [:coffi.mem/pointer :clang/CXSourceRangeList], :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getSkippedRanges, :doc "/**\n * Retrieve all ranges that were skipped by the preprocessor.\n *\n * The preprocessor will skip lines when they are surrounded by an\n * if/ifdef/ifndef directive whose condition does not evaluate to true.\n */"} {:args ({:spelling "tu", :type "struct CXTranslationUnitImpl *"}), :ret {:spelling "CXSourceRangeList *", :type "CXSourceRangeList *"}, :function/args [[:coffi.mem/pointer :clang/CXTranslationUnitImpl]], :symbol "clang_getAllSkippedRanges", :name "clang_getAllSkippedRanges", :function/ret [:coffi.mem/pointer :clang/CXSourceRangeList], :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getAllSkippedRanges, :doc "/**\n * Retrieve all ranges from all files that were skipped by the\n * preprocessor.\n *\n * The preprocessor will skip lines when they are surrounded by an\n * if/ifdef/ifndef directive whose condition does not evaluate to true.\n */"} {:args ({:spelling "ranges", :type "CXSourceRangeList *"}), :ret {:spelling "void", :type "void"}, :function/args [[:coffi.mem/pointer :clang/CXSourceRangeList]], :symbol "clang_disposeSourceRangeList", :name "clang_disposeSourceRangeList", :function/ret :coffi.mem/void, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_disposeSourceRangeList, :doc "/**\n * Destroy the given \\c CXSourceRangeList.\n */"} {:args ({:spelling "Diags", :type "void *"}), :ret {:spelling "unsigned int", :type "unsigned int"}, :function/args [:coffi.mem/pointer], :symbol "clang_getNumDiagnosticsInSet", :name "clang_getNumDiagnosticsInSet", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getNumDiagnosticsInSet, :doc "/**\n * Determine the number of diagnostics in a CXDiagnosticSet.\n */"} {:args ({:spelling "Diags", :type "void *"} {:spelling "Index", :type "unsigned int"}), :ret {:spelling "CXDiagnostic", :type "void *"}, :function/args [:coffi.mem/pointer :coffi.mem/int], :symbol "clang_getDiagnosticInSet", :name "clang_getDiagnosticInSet", :function/ret :coffi.mem/pointer, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getDiagnosticInSet, :doc "/**\n * Retrieve a diagnostic associated with the given CXDiagnosticSet.\n *\n * \\param Diags the CXDiagnosticSet to query.\n * \\param Index the zero-based diagnostic number to retrieve.\n *\n * \\returns the requested diagnostic. This diagnostic must be freed\n * via a call to \\c clang_disposeDiagnostic().\n */"} {:args ({:spelling "file", :type "const char *"} {:spelling "error", :type "enum CXLoadDiag_Error *"} {:spelling "errorString", :type "CXString *"}), :ret {:spelling "CXDiagnosticSet", :type "void *"}, :function/args [[:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :clang/CXString]], :symbol "clang_loadDiagnostics", :name "clang_loadDiagnostics", :function/ret :coffi.mem/pointer, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_loadDiagnostics, :doc "/**\n * Deserialize a set of diagnostics from a Clang diagnostics bitcode\n * file.\n *\n * \\param file The name of the file to deserialize.\n * \\param error A pointer to a enum value recording if there was a problem\n *        deserializing the diagnostics.\n * \\param errorString A pointer to a CXString for recording the error string\n *        if the file was not successfully loaded.\n *\n * \\returns A loaded CXDiagnosticSet if successful, and NULL otherwise.  These\n * diagnostics should be released using clang_disposeDiagnosticSet().\n */"} {:args ({:spelling "Diags", :type "void *"}), :ret {:spelling "void", :type "void"}, :function/args [:coffi.mem/pointer], :symbol "clang_disposeDiagnosticSet", :name "clang_disposeDiagnosticSet", :function/ret :coffi.mem/void, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_disposeDiagnosticSet, :doc "/**\n * Release a CXDiagnosticSet and all of its contained diagnostics.\n */"} {:args ({:spelling "D", :type "void *"}), :ret {:spelling "CXDiagnosticSet", :type "void *"}, :function/args [:coffi.mem/pointer], :symbol "clang_getChildDiagnostics", :name "clang_getChildDiagnostics", :function/ret :coffi.mem/pointer, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getChildDiagnostics, :doc "/**\n * Retrieve the child diagnostics of a CXDiagnostic.\n *\n * This CXDiagnosticSet does not need to be released by\n * clang_disposeDiagnosticSet.\n */"} {:args ({:spelling "Unit", :type "struct CXTranslationUnitImpl *"}), :ret {:spelling "unsigned int", :type "unsigned int"}, :function/args [[:coffi.mem/pointer :clang/CXTranslationUnitImpl]], :symbol "clang_getNumDiagnostics", :name "clang_getNumDiagnostics", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getNumDiagnostics, :doc "/**\n * Determine the number of diagnostics produced for the given\n * translation unit.\n */"} {:args ({:spelling "Unit", :type "struct CXTranslationUnitImpl *"} {:spelling "Index", :type "unsigned int"}), :ret {:spelling "CXDiagnostic", :type "void *"}, :function/args [[:coffi.mem/pointer :clang/CXTranslationUnitImpl] :coffi.mem/int], :symbol "clang_getDiagnostic", :name "clang_getDiagnostic", :function/ret :coffi.mem/pointer, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getDiagnostic, :doc "/**\n * Retrieve a diagnostic associated with the given translation unit.\n *\n * \\param Unit the translation unit to query.\n * \\param Index the zero-based diagnostic number to retrieve.\n *\n * \\returns the requested diagnostic. This diagnostic must be freed\n * via a call to \\c clang_disposeDiagnostic().\n */"} {:args ({:spelling "Unit", :type "struct CXTranslationUnitImpl *"}), :ret {:spelling "CXDiagnosticSet", :type "void *"}, :function/args [[:coffi.mem/pointer :clang/CXTranslationUnitImpl]], :symbol "clang_getDiagnosticSetFromTU", :name "clang_getDiagnosticSetFromTU", :function/ret :coffi.mem/pointer, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getDiagnosticSetFromTU, :doc "/**\n * Retrieve the complete set of diagnostics associated with a\n *        translation unit.\n *\n * \\param Unit the translation unit to query.\n */"} {:args ({:spelling "Diagnostic", :type "void *"}), :ret {:spelling "void", :type "void"}, :function/args [:coffi.mem/pointer], :symbol "clang_disposeDiagnostic", :name "clang_disposeDiagnostic", :function/ret :coffi.mem/void, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_disposeDiagnostic, :doc "/**\n * Destroy a diagnostic.\n */"} {:args ({:spelling "Diagnostic", :type "void *"} {:spelling "Options", :type "unsigned int"}), :ret {:spelling "CXString", :type "CXString"}, :function/args [:coffi.mem/pointer :coffi.mem/int], :symbol "clang_formatDiagnostic", :name "clang_formatDiagnostic", :function/ret :clang/CXString, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_formatDiagnostic, :doc "/**\n * Format the given diagnostic in a manner that is suitable for display.\n *\n * This routine will format the given diagnostic to a string, rendering\n * the diagnostic according to the various options given. The\n * \\c clang_defaultDiagnosticDisplayOptions() function returns the set of\n * options that most closely mimics the behavior of the clang compiler.\n *\n * \\param Diagnostic The diagnostic to print.\n *\n * \\param Options A set of options that control the diagnostic display,\n * created by combining \\c CXDiagnosticDisplayOptions values.\n *\n * \\returns A new string containing for formatted diagnostic.\n */"} {:args (), :ret {:spelling "unsigned int", :type "unsigned int"}, :function/args [], :symbol "clang_defaultDiagnosticDisplayOptions", :name "clang_defaultDiagnosticDisplayOptions", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_defaultDiagnosticDisplayOptions, :doc "/**\n * Retrieve the set of display options most similar to the\n * default behavior of the clang compiler.\n *\n * \\returns A set of display options suitable for use with \\c\n * clang_formatDiagnostic().\n */"} {:args ({:spelling "", :type "void *"}), :ret {:spelling "enum CXDiagnosticSeverity", :type "enum CXDiagnosticSeverity"}, :function/args [:coffi.mem/pointer], :symbol "clang_getDiagnosticSeverity", :name "clang_getDiagnosticSeverity", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getDiagnosticSeverity, :doc "/**\n * Determine the severity of the given diagnostic.\n */"} {:args ({:spelling "", :type "void *"}), :ret {:spelling "CXSourceLocation", :type "CXSourceLocation"}, :function/args [:coffi.mem/pointer], :symbol "clang_getDiagnosticLocation", :name "clang_getDiagnosticLocation", :function/ret :clang/CXSourceLocation, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getDiagnosticLocation, :doc "/**\n * Retrieve the source location of the given diagnostic.\n *\n * This location is where Clang would print the caret ('^') when\n * displaying the diagnostic on the command line.\n */"} {:args ({:spelling "", :type "void *"}), :ret {:spelling "CXString", :type "CXString"}, :function/args [:coffi.mem/pointer], :symbol "clang_getDiagnosticSpelling", :name "clang_getDiagnosticSpelling", :function/ret :clang/CXString, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getDiagnosticSpelling, :doc "/**\n * Retrieve the text of the given diagnostic.\n */"} {:args ({:spelling "Diag", :type "void *"} {:spelling "Disable", :type "CXString *"}), :ret {:spelling "CXString", :type "CXString"}, :function/args [:coffi.mem/pointer [:coffi.mem/pointer :clang/CXString]], :symbol "clang_getDiagnosticOption", :name "clang_getDiagnosticOption", :function/ret :clang/CXString, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getDiagnosticOption, :doc "/**\n * Retrieve the name of the command-line option that enabled this\n * diagnostic.\n *\n * \\param Diag The diagnostic to be queried.\n *\n * \\param Disable If non-NULL, will be set to the option that disables this\n * diagnostic (if any).\n *\n * \\returns A string that contains the command-line option used to enable this\n * warning, such as \"-Wconversion\" or \"-pedantic\".\n */"} {:args ({:spelling "", :type "void *"}), :ret {:spelling "unsigned int", :type "unsigned int"}, :function/args [:coffi.mem/pointer], :symbol "clang_getDiagnosticCategory", :name "clang_getDiagnosticCategory", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getDiagnosticCategory, :doc "/**\n * Retrieve the category number for this diagnostic.\n *\n * Diagnostics can be categorized into groups along with other, related\n * diagnostics (e.g., diagnostics under the same warning flag). This routine\n * retrieves the category number for the given diagnostic.\n *\n * \\returns The number of the category that contains this diagnostic, or zero\n * if this diagnostic is uncategorized.\n */"} {:args ({:spelling "Category", :type "unsigned int"}), :ret {:spelling "CXString", :type "CXString"}, :function/args [:coffi.mem/int], :symbol "clang_getDiagnosticCategoryName", :name "clang_getDiagnosticCategoryName", :function/ret :clang/CXString, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getDiagnosticCategoryName, :doc "/**\n * Retrieve the name of a particular diagnostic category.  This\n *  is now deprecated.  Use clang_getDiagnosticCategoryText()\n *  instead.\n *\n * \\param Category A diagnostic category number, as returned by\n * \\c clang_getDiagnosticCategory().\n *\n * \\returns The name of the given diagnostic category.\n */"} {:args ({:spelling "", :type "void *"}), :ret {:spelling "CXString", :type "CXString"}, :function/args [:coffi.mem/pointer], :symbol "clang_getDiagnosticCategoryText", :name "clang_getDiagnosticCategoryText", :function/ret :clang/CXString, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getDiagnosticCategoryText, :doc "/**\n * Retrieve the diagnostic category text for a given diagnostic.\n *\n * \\returns The text of the given diagnostic category.\n */"} {:args ({:spelling "", :type "void *"}), :ret {:spelling "unsigned int", :type "unsigned int"}, :function/args [:coffi.mem/pointer], :symbol "clang_getDiagnosticNumRanges", :name "clang_getDiagnosticNumRanges", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getDiagnosticNumRanges, :doc "/**\n * Determine the number of source ranges associated with the given\n * diagnostic.\n */"} {:args ({:spelling "Diagnostic", :type "void *"} {:spelling "Range", :type "unsigned int"}), :ret {:spelling "CXSourceRange", :type "CXSourceRange"}, :function/args [:coffi.mem/pointer :coffi.mem/int], :symbol "clang_getDiagnosticRange", :name "clang_getDiagnosticRange", :function/ret :clang/CXSourceRange, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getDiagnosticRange, :doc "/**\n * Retrieve a source range associated with the diagnostic.\n *\n * A diagnostic's source ranges highlight important elements in the source\n * code. On the command line, Clang displays source ranges by\n * underlining them with '~' characters.\n *\n * \\param Diagnostic the diagnostic whose range is being extracted.\n *\n * \\param Range the zero-based index specifying which range to\n *\n * \\returns the requested source range.\n */"} {:args ({:spelling "Diagnostic", :type "void *"}), :ret {:spelling "unsigned int", :type "unsigned int"}, :function/args [:coffi.mem/pointer], :symbol "clang_getDiagnosticNumFixIts", :name "clang_getDiagnosticNumFixIts", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getDiagnosticNumFixIts, :doc "/**\n * Determine the number of fix-it hints associated with the\n * given diagnostic.\n */"} {:args ({:spelling "Diagnostic", :type "void *"} {:spelling "FixIt", :type "unsigned int"} {:spelling "ReplacementRange", :type "CXSourceRange *"}), :ret {:spelling "CXString", :type "CXString"}, :function/args [:coffi.mem/pointer :coffi.mem/int [:coffi.mem/pointer :clang/CXSourceRange]], :symbol "clang_getDiagnosticFixIt", :name "clang_getDiagnosticFixIt", :function/ret :clang/CXString, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getDiagnosticFixIt, :doc "/**\n * Retrieve the replacement information for a given fix-it.\n *\n * Fix-its are described in terms of a source range whose contents\n * should be replaced by a string. This approach generalizes over\n * three kinds of operations: removal of source code (the range covers\n * the code to be removed and the replacement string is empty),\n * replacement of source code (the range covers the code to be\n * replaced and the replacement string provides the new code), and\n * insertion (both the start and end of the range point at the\n * insertion location, and the replacement string provides the text to\n * insert).\n *\n * \\param Diagnostic The diagnostic whose fix-its are being queried.\n *\n * \\param FixIt The zero-based index of the fix-it.\n *\n * \\param ReplacementRange The source range whose contents will be\n * replaced with the returned replacement string. Note that source\n * ranges are half-open ranges [a, b), so the source code should be\n * replaced from a and up to (but not including) b.\n *\n * \\returns A string containing text that should be replace the source\n * code indicated by the \\c ReplacementRange.\n */"} {:args ({:spelling "CTUnit", :type "struct CXTranslationUnitImpl *"}), :ret {:spelling "CXString", :type "CXString"}, :function/args [[:coffi.mem/pointer :clang/CXTranslationUnitImpl]], :symbol "clang_getTranslationUnitSpelling", :name "clang_getTranslationUnitSpelling", :function/ret :clang/CXString, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getTranslationUnitSpelling, :doc "/**\n * Get the original translation unit source file name.\n */"} {:args ({:spelling "CIdx", :type "void *"} {:spelling "source_filename", :type "const char *"} {:spelling "num_clang_command_line_args", :type "int"} {:spelling "clang_command_line_args", :type "const char *const *"} {:spelling "num_unsaved_files", :type "unsigned int"} {:spelling "unsaved_files", :type "struct CXUnsavedFile *"}), :ret {:spelling "CXTranslationUnit", :type "struct CXTranslationUnitImpl *"}, :function/args [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]] :coffi.mem/int [:coffi.mem/pointer :clang/CXUnsavedFile]], :symbol "clang_createTranslationUnitFromSourceFile", :name "clang_createTranslationUnitFromSourceFile", :function/ret [:coffi.mem/pointer :clang/CXTranslationUnitImpl], :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_createTranslationUnitFromSourceFile, :doc "/**\n * Return the CXTranslationUnit for a given source file and the provided\n * command line arguments one would pass to the compiler.\n *\n * Note: The 'source_filename' argument is optional.  If the caller provides a\n * NULL pointer, the name of the source file is expected to reside in the\n * specified command line arguments.\n *\n * Note: When encountered in 'clang_command_line_args', the following options\n * are ignored:\n *\n *   '-c'\n *   '-emit-ast'\n *   '-fsyntax-only'\n *   '-o \\<output file>'  (both '-o' and '\\<output file>' are ignored)\n *\n * \\param CIdx The index object with which the translation unit will be\n * associated.\n *\n * \\param source_filename The name of the source file to load, or NULL if the\n * source file is included in \\p clang_command_line_args.\n *\n * \\param num_clang_command_line_args The number of command-line arguments in\n * \\p clang_command_line_args.\n *\n * \\param clang_command_line_args The command-line arguments that would be\n * passed to the \\c clang executable if it were being invoked out-of-process.\n * These command-line options will be parsed and will affect how the translation\n * unit is parsed. Note that the following options are ignored: '-c',\n * '-emit-ast', '-fsyntax-only' (which is the default), and '-o \\<output file>'.\n *\n * \\param num_unsaved_files the number of unsaved file entries in \\p\n * unsaved_files.\n *\n * \\param unsaved_files the files that have not yet been saved to disk\n * but may be required for code completion, including the contents of\n * those files.  The contents and name of these files (as specified by\n * CXUnsavedFile) are copied when necessary, so the client only needs to\n * guarantee their validity until the call to this function returns.\n */"} {:args ({:spelling "CIdx", :type "void *"} {:spelling "ast_filename", :type "const char *"}), :ret {:spelling "CXTranslationUnit", :type "struct CXTranslationUnitImpl *"}, :function/args [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]], :symbol "clang_createTranslationUnit", :name "clang_createTranslationUnit", :function/ret [:coffi.mem/pointer :clang/CXTranslationUnitImpl], :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_createTranslationUnit, :doc "/**\n * Same as \\c clang_createTranslationUnit2, but returns\n * the \\c CXTranslationUnit instead of an error code.  In case of an error this\n * routine returns a \\c NULL \\c CXTranslationUnit, without further detailed\n * error codes.\n */"} {:args ({:spelling "CIdx", :type "void *"} {:spelling "ast_filename", :type "const char *"} {:spelling "out_TU", :type "struct CXTranslationUnitImpl **"}), :ret {:spelling "enum CXErrorCode", :type "enum CXErrorCode"}, :function/args [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer [:coffi.mem/pointer :clang/CXTranslationUnitImpl]]], :symbol "clang_createTranslationUnit2", :name "clang_createTranslationUnit2", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_createTranslationUnit2, :doc "/**\n * Create a translation unit from an AST file (\\c -emit-ast).\n *\n * \\param[out] out_TU A non-NULL pointer to store the created\n * \\c CXTranslationUnit.\n *\n * \\returns Zero on success, otherwise returns an error code.\n */"} {:args (), :ret {:spelling "unsigned int", :type "unsigned int"}, :function/args [], :symbol "clang_defaultEditingTranslationUnitOptions", :name "clang_defaultEditingTranslationUnitOptions", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_defaultEditingTranslationUnitOptions, :doc "/**\n * Returns the set of flags that is suitable for parsing a translation\n * unit that is being edited.\n *\n * The set of flags returned provide options for \\c clang_parseTranslationUnit()\n * to indicate that the translation unit is likely to be reparsed many times,\n * either explicitly (via \\c clang_reparseTranslationUnit()) or implicitly\n * (e.g., by code completion (\\c clang_codeCompletionAt())). The returned flag\n * set contains an unspecified set of optimizations (e.g., the precompiled\n * preamble) geared toward improving the performance of these routines. The\n * set of optimizations enabled may change from one version to the next.\n */"} {:args ({:spelling "CIdx", :type "void *"} {:spelling "source_filename", :type "const char *"} {:spelling "command_line_args", :type "const char *const *"} {:spelling "num_command_line_args", :type "int"} {:spelling "unsaved_files", :type "struct CXUnsavedFile *"} {:spelling "num_unsaved_files", :type "unsigned int"} {:spelling "options", :type "unsigned int"}), :ret {:spelling "CXTranslationUnit", :type "struct CXTranslationUnitImpl *"}, :function/args [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]] :coffi.mem/int [:coffi.mem/pointer :clang/CXUnsavedFile] :coffi.mem/int :coffi.mem/int], :symbol "clang_parseTranslationUnit", :name "clang_parseTranslationUnit", :function/ret [:coffi.mem/pointer :clang/CXTranslationUnitImpl], :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_parseTranslationUnit, :doc "/**\n * Same as \\c clang_parseTranslationUnit2, but returns\n * the \\c CXTranslationUnit instead of an error code.  In case of an error this\n * routine returns a \\c NULL \\c CXTranslationUnit, without further detailed\n * error codes.\n */"} {:args ({:spelling "CIdx", :type "void *"} {:spelling "source_filename", :type "const char *"} {:spelling "command_line_args", :type "const char *const *"} {:spelling "num_command_line_args", :type "int"} {:spelling "unsaved_files", :type "struct CXUnsavedFile *"} {:spelling "num_unsaved_files", :type "unsigned int"} {:spelling "options", :type "unsigned int"} {:spelling "out_TU", :type "struct CXTranslationUnitImpl **"}), :ret {:spelling "enum CXErrorCode", :type "enum CXErrorCode"}, :function/args [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]] :coffi.mem/int [:coffi.mem/pointer :clang/CXUnsavedFile] :coffi.mem/int :coffi.mem/int [:coffi.mem/pointer [:coffi.mem/pointer :clang/CXTranslationUnitImpl]]], :symbol "clang_parseTranslationUnit2", :name "clang_parseTranslationUnit2", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_parseTranslationUnit2, :doc "/**\n * Parse the given source file and the translation unit corresponding\n * to that file.\n *\n * This routine is the main entry point for the Clang C API, providing the\n * ability to parse a source file into a translation unit that can then be\n * queried by other functions in the API. This routine accepts a set of\n * command-line arguments so that the compilation can be configured in the same\n * way that the compiler is configured on the command line.\n *\n * \\param CIdx The index object with which the translation unit will be\n * associated.\n *\n * \\param source_filename The name of the source file to load, or NULL if the\n * source file is included in \\c command_line_args.\n *\n * \\param command_line_args The command-line arguments that would be\n * passed to the \\c clang executable if it were being invoked out-of-process.\n * These command-line options will be parsed and will affect how the translation\n * unit is parsed. Note that the following options are ignored: '-c',\n * '-emit-ast', '-fsyntax-only' (which is the default), and '-o \\<output file>'.\n *\n * \\param num_command_line_args The number of command-line arguments in\n * \\c command_line_args.\n *\n * \\param unsaved_files the files that have not yet been saved to disk\n * but may be required for parsing, including the contents of\n * those files.  The contents and name of these files (as specified by\n * CXUnsavedFile) are copied when necessary, so the client only needs to\n * guarantee their validity until the call to this function returns.\n *\n * \\param num_unsaved_files the number of unsaved file entries in \\p\n * unsaved_files.\n *\n * \\param options A bitmask of options that affects how the translation unit\n * is managed but not its compilation. This should be a bitwise OR of the\n * CXTranslationUnit_XXX flags.\n *\n * \\param[out] out_TU A non-NULL pointer to store the created\n * \\c CXTranslationUnit, describing the parsed code and containing any\n * diagnostics produced by the compiler.\n *\n * \\returns Zero on success, otherwise returns an error code.\n */"} {:args ({:spelling "CIdx", :type "void *"} {:spelling "source_filename", :type "const char *"} {:spelling "command_line_args", :type "const char *const *"} {:spelling "num_command_line_args", :type "int"} {:spelling "unsaved_files", :type "struct CXUnsavedFile *"} {:spelling "num_unsaved_files", :type "unsigned int"} {:spelling "options", :type "unsigned int"} {:spelling "out_TU", :type "struct CXTranslationUnitImpl **"}), :ret {:spelling "enum CXErrorCode", :type "enum CXErrorCode"}, :function/args [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]] :coffi.mem/int [:coffi.mem/pointer :clang/CXUnsavedFile] :coffi.mem/int :coffi.mem/int [:coffi.mem/pointer [:coffi.mem/pointer :clang/CXTranslationUnitImpl]]], :symbol "clang_parseTranslationUnit2FullArgv", :name "clang_parseTranslationUnit2FullArgv", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_parseTranslationUnit2FullArgv, :doc "/**\n * Same as clang_parseTranslationUnit2 but requires a full command line\n * for \\c command_line_args including argv[0]. This is useful if the standard\n * library paths are relative to the binary.\n */"} {:args ({:spelling "TU", :type "struct CXTranslationUnitImpl *"}), :ret {:spelling "unsigned int", :type "unsigned int"}, :function/args [[:coffi.mem/pointer :clang/CXTranslationUnitImpl]], :symbol "clang_defaultSaveOptions", :name "clang_defaultSaveOptions", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_defaultSaveOptions, :doc "/**\n * Returns the set of flags that is suitable for saving a translation\n * unit.\n *\n * The set of flags returned provide options for\n * \\c clang_saveTranslationUnit() by default. The returned flag\n * set contains an unspecified set of options that save translation units with\n * the most commonly-requested data.\n */"} {:args ({:spelling "TU", :type "struct CXTranslationUnitImpl *"} {:spelling "FileName", :type "const char *"} {:spelling "options", :type "unsigned int"}), :ret {:spelling "int", :type "int"}, :function/args [[:coffi.mem/pointer :clang/CXTranslationUnitImpl] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int], :symbol "clang_saveTranslationUnit", :name "clang_saveTranslationUnit", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_saveTranslationUnit, :doc "/**\n * Saves a translation unit into a serialized representation of\n * that translation unit on disk.\n *\n * Any translation unit that was parsed without error can be saved\n * into a file. The translation unit can then be deserialized into a\n * new \\c CXTranslationUnit with \\c clang_createTranslationUnit() or,\n * if it is an incomplete translation unit that corresponds to a\n * header, used as a precompiled header when parsing other translation\n * units.\n *\n * \\param TU The translation unit to save.\n *\n * \\param FileName The file to which the translation unit will be saved.\n *\n * \\param options A bitmask of options that affects how the translation unit\n * is saved. This should be a bitwise OR of the\n * CXSaveTranslationUnit_XXX flags.\n *\n * \\returns A value that will match one of the enumerators of the CXSaveError\n * enumeration. Zero (CXSaveError_None) indicates that the translation unit was\n * saved successfully, while a non-zero value indicates that a problem occurred.\n */"} {:args ({:spelling "", :type "struct CXTranslationUnitImpl *"}), :ret {:spelling "unsigned int", :type "unsigned int"}, :function/args [[:coffi.mem/pointer :clang/CXTranslationUnitImpl]], :symbol "clang_suspendTranslationUnit", :name "clang_suspendTranslationUnit", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_suspendTranslationUnit, :doc "/**\n * Suspend a translation unit in order to free memory associated with it.\n *\n * A suspended translation unit uses significantly less memory but on the other\n * side does not support any other calls than \\c clang_reparseTranslationUnit\n * to resume it or \\c clang_disposeTranslationUnit to dispose it completely.\n */"} {:args ({:spelling "", :type "struct CXTranslationUnitImpl *"}), :ret {:spelling "void", :type "void"}, :function/args [[:coffi.mem/pointer :clang/CXTranslationUnitImpl]], :symbol "clang_disposeTranslationUnit", :name "clang_disposeTranslationUnit", :function/ret :coffi.mem/void, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_disposeTranslationUnit, :doc "/**\n * Destroy the specified CXTranslationUnit object.\n */"} {:args ({:spelling "TU", :type "struct CXTranslationUnitImpl *"}), :ret {:spelling "unsigned int", :type "unsigned int"}, :function/args [[:coffi.mem/pointer :clang/CXTranslationUnitImpl]], :symbol "clang_defaultReparseOptions", :name "clang_defaultReparseOptions", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_defaultReparseOptions, :doc "/**\n * Returns the set of flags that is suitable for reparsing a translation\n * unit.\n *\n * The set of flags returned provide options for\n * \\c clang_reparseTranslationUnit() by default. The returned flag\n * set contains an unspecified set of optimizations geared toward common uses\n * of reparsing. The set of optimizations enabled may change from one version\n * to the next.\n */"} {:args ({:spelling "TU", :type "struct CXTranslationUnitImpl *"} {:spelling "num_unsaved_files", :type "unsigned int"} {:spelling "unsaved_files", :type "struct CXUnsavedFile *"} {:spelling "options", :type "unsigned int"}), :ret {:spelling "int", :type "int"}, :function/args [[:coffi.mem/pointer :clang/CXTranslationUnitImpl] :coffi.mem/int [:coffi.mem/pointer :clang/CXUnsavedFile] :coffi.mem/int], :symbol "clang_reparseTranslationUnit", :name "clang_reparseTranslationUnit", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_reparseTranslationUnit, :doc "/**\n * Reparse the source files that produced this translation unit.\n *\n * This routine can be used to re-parse the source files that originally\n * created the given translation unit, for example because those source files\n * have changed (either on disk or as passed via \\p unsaved_files). The\n * source code will be reparsed with the same command-line options as it\n * was originally parsed.\n *\n * Reparsing a translation unit invalidates all cursors and source locations\n * that refer into that translation unit. This makes reparsing a translation\n * unit semantically equivalent to destroying the translation unit and then\n * creating a new translation unit with the same command-line arguments.\n * However, it may be more efficient to reparse a translation\n * unit using this routine.\n *\n * \\param TU The translation unit whose contents will be re-parsed. The\n * translation unit must originally have been built with\n * \\c clang_createTranslationUnitFromSourceFile().\n *\n * \\param num_unsaved_files The number of unsaved file entries in \\p\n * unsaved_files.\n *\n * \\param unsaved_files The files that have not yet been saved to disk\n * but may be required for parsing, including the contents of\n * those files.  The contents and name of these files (as specified by\n * CXUnsavedFile) are copied when necessary, so the client only needs to\n * guarantee their validity until the call to this function returns.\n *\n * \\param options A bitset of options composed of the flags in CXReparse_Flags.\n * The function \\c clang_defaultReparseOptions() produces a default set of\n * options recommended for most uses, based on the translation unit.\n *\n * \\returns 0 if the sources could be reparsed.  A non-zero error code will be\n * returned if reparsing was impossible, such that the translation unit is\n * invalid. In such cases, the only valid call for \\c TU is\n * \\c clang_disposeTranslationUnit(TU).  The error codes returned by this\n * routine are described by the \\c CXErrorCode enum.\n */"} {:args ({:spelling "kind", :type "enum CXTUResourceUsageKind"}), :ret {:spelling "const char *", :type "const char *"}, :function/args [:coffi.mem/int], :symbol "clang_getTUResourceUsageName", :name "clang_getTUResourceUsageName", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getTUResourceUsageName, :doc "/**\n * Returns the human-readable null-terminated C string that represents\n *  the name of the memory category.  This string should never be freed.\n */"} {:args ({:spelling "TU", :type "struct CXTranslationUnitImpl *"}), :ret {:spelling "CXTUResourceUsage", :type "struct CXTUResourceUsage"}, :function/args [[:coffi.mem/pointer :clang/CXTranslationUnitImpl]], :symbol "clang_getCXTUResourceUsage", :name "clang_getCXTUResourceUsage", :function/ret :clang/CXTUResourceUsage, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getCXTUResourceUsage, :doc "/**\n * Return the memory usage of a translation unit.  This object\n *  should be released with clang_disposeCXTUResourceUsage().\n */"} {:args ({:spelling "usage", :type "struct CXTUResourceUsage"}), :ret {:spelling "void", :type "void"}, :function/args [:clang/CXTUResourceUsage], :symbol "clang_disposeCXTUResourceUsage", :name "clang_disposeCXTUResourceUsage", :function/ret :coffi.mem/void, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_disposeCXTUResourceUsage, :doc nil} {:args ({:spelling "CTUnit", :type "struct CXTranslationUnitImpl *"}), :ret {:spelling "CXTargetInfo", :type "struct CXTargetInfoImpl *"}, :function/args [[:coffi.mem/pointer :clang/CXTranslationUnitImpl]], :symbol "clang_getTranslationUnitTargetInfo", :name "clang_getTranslationUnitTargetInfo", :function/ret [:coffi.mem/pointer :clang/CXTargetInfoImpl], :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getTranslationUnitTargetInfo, :doc "/**\n * Get target information for this translation unit.\n *\n * The CXTargetInfo object cannot outlive the CXTranslationUnit object.\n */"} {:args ({:spelling "Info", :type "struct CXTargetInfoImpl *"}), :ret {:spelling "void", :type "void"}, :function/args [[:coffi.mem/pointer :clang/CXTargetInfoImpl]], :symbol "clang_TargetInfo_dispose", :name "clang_TargetInfo_dispose", :function/ret :coffi.mem/void, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_TargetInfo_dispose, :doc "/**\n * Destroy the CXTargetInfo object.\n */"} {:args ({:spelling "Info", :type "struct CXTargetInfoImpl *"}), :ret {:spelling "CXString", :type "CXString"}, :function/args [[:coffi.mem/pointer :clang/CXTargetInfoImpl]], :symbol "clang_TargetInfo_getTriple", :name "clang_TargetInfo_getTriple", :function/ret :clang/CXString, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_TargetInfo_getTriple, :doc "/**\n * Get the normalized target triple as a string.\n *\n * Returns the empty string in case of any error.\n */"} {:args ({:spelling "Info", :type "struct CXTargetInfoImpl *"}), :ret {:spelling "int", :type "int"}, :function/args [[:coffi.mem/pointer :clang/CXTargetInfoImpl]], :symbol "clang_TargetInfo_getPointerWidth", :name "clang_TargetInfo_getPointerWidth", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_TargetInfo_getPointerWidth, :doc "/**\n * Get the pointer width of the target in bits.\n *\n * Returns -1 in case of error.\n */"} {:args (), :ret {:spelling "CXCursor", :type "CXCursor"}, :function/args [], :symbol "clang_getNullCursor", :name "clang_getNullCursor", :function/ret :clang/CXCursor, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getNullCursor, :doc "/**\n * Retrieve the NULL cursor, which represents no entity.\n */"} {:args ({:spelling "", :type "struct CXTranslationUnitImpl *"}), :ret {:spelling "CXCursor", :type "CXCursor"}, :function/args [[:coffi.mem/pointer :clang/CXTranslationUnitImpl]], :symbol "clang_getTranslationUnitCursor", :name "clang_getTranslationUnitCursor", :function/ret :clang/CXCursor, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getTranslationUnitCursor, :doc "/**\n * Retrieve the cursor that represents the given translation unit.\n *\n * The translation unit cursor can be used to start traversing the\n * various declarations within the given translation unit.\n */"} {:args ({:spelling "", :type "CXCursor"} {:spelling "", :type "CXCursor"}), :ret {:spelling "unsigned int", :type "unsigned int"}, :function/args [:clang/CXCursor :clang/CXCursor], :symbol "clang_equalCursors", :name "clang_equalCursors", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_equalCursors, :doc "/**\n * Determine whether two cursors are equivalent.\n */"} {:args ({:spelling "cursor", :type "CXCursor"}), :ret {:spelling "int", :type "int"}, :function/args [:clang/CXCursor], :symbol "clang_Cursor_isNull", :name "clang_Cursor_isNull", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_Cursor_isNull, :doc "/**\n * Returns non-zero if \\p cursor is null.\n */"} {:args ({:spelling "", :type "CXCursor"}), :ret {:spelling "unsigned int", :type "unsigned int"}, :function/args [:clang/CXCursor], :symbol "clang_hashCursor", :name "clang_hashCursor", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_hashCursor, :doc "/**\n * Compute a hash value for the given cursor.\n */"} {:args ({:spelling "", :type "CXCursor"}), :ret {:spelling "enum CXCursorKind", :type "enum CXCursorKind"}, :function/args [:clang/CXCursor], :symbol "clang_getCursorKind", :name "clang_getCursorKind", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getCursorKind, :doc "/**\n * Retrieve the kind of the given cursor.\n */"} {:args ({:spelling "", :type "enum CXCursorKind"}), :ret {:spelling "unsigned int", :type "unsigned int"}, :function/args [:coffi.mem/int], :symbol "clang_isDeclaration", :name "clang_isDeclaration", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_isDeclaration, :doc "/**\n * Determine whether the given cursor kind represents a declaration.\n */"} {:args ({:spelling "", :type "CXCursor"}), :ret {:spelling "unsigned int", :type "unsigned int"}, :function/args [:clang/CXCursor], :symbol "clang_isInvalidDeclaration", :name "clang_isInvalidDeclaration", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_isInvalidDeclaration, :doc "/**\n * Determine whether the given declaration is invalid.\n *\n * A declaration is invalid if it could not be parsed successfully.\n *\n * \\returns non-zero if the cursor represents a declaration and it is\n * invalid, otherwise NULL.\n */"} {:args ({:spelling "", :type "enum CXCursorKind"}), :ret {:spelling "unsigned int", :type "unsigned int"}, :function/args [:coffi.mem/int], :symbol "clang_isReference", :name "clang_isReference", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_isReference, :doc "/**\n * Determine whether the given cursor kind represents a simple\n * reference.\n *\n * Note that other kinds of cursors (such as expressions) can also refer to\n * other cursors. Use clang_getCursorReferenced() to determine whether a\n * particular cursor refers to another entity.\n */"} {:args ({:spelling "", :type "enum CXCursorKind"}), :ret {:spelling "unsigned int", :type "unsigned int"}, :function/args [:coffi.mem/int], :symbol "clang_isExpression", :name "clang_isExpression", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_isExpression, :doc "/**\n * Determine whether the given cursor kind represents an expression.\n */"} {:args ({:spelling "", :type "enum CXCursorKind"}), :ret {:spelling "unsigned int", :type "unsigned int"}, :function/args [:coffi.mem/int], :symbol "clang_isStatement", :name "clang_isStatement", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_isStatement, :doc "/**\n * Determine whether the given cursor kind represents a statement.\n */"} {:args ({:spelling "", :type "enum CXCursorKind"}), :ret {:spelling "unsigned int", :type "unsigned int"}, :function/args [:coffi.mem/int], :symbol "clang_isAttribute", :name "clang_isAttribute", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_isAttribute, :doc "/**\n * Determine whether the given cursor kind represents an attribute.\n */"} {:args ({:spelling "C", :type "CXCursor"}), :ret {:spelling "unsigned int", :type "unsigned int"}, :function/args [:clang/CXCursor], :symbol "clang_Cursor_hasAttrs", :name "clang_Cursor_hasAttrs", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_Cursor_hasAttrs, :doc "/**\n * Determine whether the given cursor has any attributes.\n */"} {:args ({:spelling "", :type "enum CXCursorKind"}), :ret {:spelling "unsigned int", :type "unsigned int"}, :function/args [:coffi.mem/int], :symbol "clang_isInvalid", :name "clang_isInvalid", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_isInvalid, :doc "/**\n * Determine whether the given cursor kind represents an invalid\n * cursor.\n */"} {:args ({:spelling "", :type "enum CXCursorKind"}), :ret {:spelling "unsigned int", :type "unsigned int"}, :function/args [:coffi.mem/int], :symbol "clang_isTranslationUnit", :name "clang_isTranslationUnit", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_isTranslationUnit, :doc "/**\n * Determine whether the given cursor kind represents a translation\n * unit.\n */"} {:args ({:spelling "", :type "enum CXCursorKind"}), :ret {:spelling "unsigned int", :type "unsigned int"}, :function/args [:coffi.mem/int], :symbol "clang_isPreprocessing", :name "clang_isPreprocessing", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_isPreprocessing, :doc "/***\n * Determine whether the given cursor represents a preprocessing\n * element, such as a preprocessor directive or macro instantiation.\n */"} {:args ({:spelling "", :type "enum CXCursorKind"}), :ret {:spelling "unsigned int", :type "unsigned int"}, :function/args [:coffi.mem/int], :symbol "clang_isUnexposed", :name "clang_isUnexposed", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_isUnexposed, :doc "/***\n * Determine whether the given cursor represents a currently\n *  unexposed piece of the AST (e.g., CXCursor_UnexposedStmt).\n */"} {:args ({:spelling "cursor", :type "CXCursor"}), :ret {:spelling "enum CXLinkageKind", :type "enum CXLinkageKind"}, :function/args [:clang/CXCursor], :symbol "clang_getCursorLinkage", :name "clang_getCursorLinkage", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getCursorLinkage, :doc "/**\n * Determine the linkage of the entity referred to by a given cursor.\n */"} {:args ({:spelling "cursor", :type "CXCursor"}), :ret {:spelling "enum CXVisibilityKind", :type "enum CXVisibilityKind"}, :function/args [:clang/CXCursor], :symbol "clang_getCursorVisibility", :name "clang_getCursorVisibility", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getCursorVisibility, :doc "/**\n * Describe the visibility of the entity referred to by a cursor.\n *\n * This returns the default visibility if not explicitly specified by\n * a visibility attribute. The default visibility may be changed by\n * commandline arguments.\n *\n * \\param cursor The cursor to query.\n *\n * \\returns The visibility of the cursor.\n */"} {:args ({:spelling "cursor", :type "CXCursor"}), :ret {:spelling "enum CXAvailabilityKind", :type "enum CXAvailabilityKind"}, :function/args [:clang/CXCursor], :symbol "clang_getCursorAvailability", :name "clang_getCursorAvailability", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getCursorAvailability, :doc "/**\n * Determine the availability of the entity that this cursor refers to,\n * taking the current target platform into account.\n *\n * \\param cursor The cursor to query.\n *\n * \\returns The availability of the cursor.\n */"} {:args ({:spelling "cursor", :type "CXCursor"} {:spelling "always_deprecated", :type "int *"} {:spelling "deprecated_message", :type "CXString *"} {:spelling "always_unavailable", :type "int *"} {:spelling "unavailable_message", :type "CXString *"} {:spelling "availability", :type "struct CXPlatformAvailability *"} {:spelling "availability_size", :type "int"}), :ret {:spelling "int", :type "int"}, :function/args [:clang/CXCursor [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :clang/CXString] [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :clang/CXString] [:coffi.mem/pointer :clang/CXPlatformAvailability] :coffi.mem/int], :symbol "clang_getCursorPlatformAvailability", :name "clang_getCursorPlatformAvailability", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getCursorPlatformAvailability, :doc "/**\n * Determine the availability of the entity that this cursor refers to\n * on any platforms for which availability information is known.\n *\n * \\param cursor The cursor to query.\n *\n * \\param always_deprecated If non-NULL, will be set to indicate whether the\n * entity is deprecated on all platforms.\n *\n * \\param deprecated_message If non-NULL, will be set to the message text\n * provided along with the unconditional deprecation of this entity. The client\n * is responsible for deallocating this string.\n *\n * \\param always_unavailable If non-NULL, will be set to indicate whether the\n * entity is unavailable on all platforms.\n *\n * \\param unavailable_message If non-NULL, will be set to the message text\n * provided along with the unconditional unavailability of this entity. The\n * client is responsible for deallocating this string.\n *\n * \\param availability If non-NULL, an array of CXPlatformAvailability instances\n * that will be populated with platform availability information, up to either\n * the number of platforms for which availability information is available (as\n * returned by this function) or \\c availability_size, whichever is smaller.\n *\n * \\param availability_size The number of elements available in the\n * \\c availability array.\n *\n * \\returns The number of platforms (N) for which availability information is\n * available (which is unrelated to \\c availability_size).\n *\n * Note that the client is responsible for calling\n * \\c clang_disposeCXPlatformAvailability to free each of the\n * platform-availability structures returned. There are\n * \\c min(N, availability_size) such structures.\n */"} {:args ({:spelling "availability", :type "struct CXPlatformAvailability *"}), :ret {:spelling "void", :type "void"}, :function/args [[:coffi.mem/pointer :clang/CXPlatformAvailability]], :symbol "clang_disposeCXPlatformAvailability", :name "clang_disposeCXPlatformAvailability", :function/ret :coffi.mem/void, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_disposeCXPlatformAvailability, :doc "/**\n * Free the memory associated with a \\c CXPlatformAvailability structure.\n */"} {:args ({:spelling "cursor", :type "CXCursor"}), :ret {:spelling "CXCursor", :type "CXCursor"}, :function/args [:clang/CXCursor], :symbol "clang_Cursor_getVarDeclInitializer", :name "clang_Cursor_getVarDeclInitializer", :function/ret :clang/CXCursor, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_Cursor_getVarDeclInitializer, :doc "/**\n * If cursor refers to a variable declaration and it has initializer returns\n * cursor referring to the initializer otherwise return null cursor.\n */"} {:args ({:spelling "cursor", :type "CXCursor"}), :ret {:spelling "int", :type "int"}, :function/args [:clang/CXCursor], :symbol "clang_Cursor_hasVarDeclGlobalStorage", :name "clang_Cursor_hasVarDeclGlobalStorage", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_Cursor_hasVarDeclGlobalStorage, :doc "/**\n * If cursor refers to a variable declaration that has global storage returns 1.\n * If cursor refers to a variable declaration that doesn't have global storage\n * returns 0. Otherwise returns -1.\n */"} {:args ({:spelling "cursor", :type "CXCursor"}), :ret {:spelling "int", :type "int"}, :function/args [:clang/CXCursor], :symbol "clang_Cursor_hasVarDeclExternalStorage", :name "clang_Cursor_hasVarDeclExternalStorage", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_Cursor_hasVarDeclExternalStorage, :doc "/**\n * If cursor refers to a variable declaration that has external storage\n * returns 1. If cursor refers to a variable declaration that doesn't have\n * external storage returns 0. Otherwise returns -1.\n */"} {:args ({:spelling "cursor", :type "CXCursor"}), :ret {:spelling "enum CXLanguageKind", :type "enum CXLanguageKind"}, :function/args [:clang/CXCursor], :symbol "clang_getCursorLanguage", :name "clang_getCursorLanguage", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getCursorLanguage, :doc "/**\n * Determine the \"language\" of the entity referred to by a given cursor.\n */"} {:args ({:spelling "cursor", :type "CXCursor"}), :ret {:spelling "enum CXTLSKind", :type "enum CXTLSKind"}, :function/args [:clang/CXCursor], :symbol "clang_getCursorTLSKind", :name "clang_getCursorTLSKind", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getCursorTLSKind, :doc "/**\n * Determine the \"thread-local storage (TLS) kind\" of the declaration\n * referred to by a cursor.\n */"} {:args ({:spelling "", :type "CXCursor"}), :ret {:spelling "CXTranslationUnit", :type "struct CXTranslationUnitImpl *"}, :function/args [:clang/CXCursor], :symbol "clang_Cursor_getTranslationUnit", :name "clang_Cursor_getTranslationUnit", :function/ret [:coffi.mem/pointer :clang/CXTranslationUnitImpl], :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_Cursor_getTranslationUnit, :doc "/**\n * Returns the translation unit that a cursor originated from.\n */"} {:args (), :ret {:spelling "CXCursorSet", :type "struct CXCursorSetImpl *"}, :function/args [], :symbol "clang_createCXCursorSet", :name "clang_createCXCursorSet", :function/ret [:coffi.mem/pointer :clang/CXCursorSetImpl], :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_createCXCursorSet, :doc "/**\n * Creates an empty CXCursorSet.\n */"} {:args ({:spelling "cset", :type "struct CXCursorSetImpl *"}), :ret {:spelling "void", :type "void"}, :function/args [[:coffi.mem/pointer :clang/CXCursorSetImpl]], :symbol "clang_disposeCXCursorSet", :name "clang_disposeCXCursorSet", :function/ret :coffi.mem/void, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_disposeCXCursorSet, :doc "/**\n * Disposes a CXCursorSet and releases its associated memory.\n */"} {:args ({:spelling "cset", :type "struct CXCursorSetImpl *"} {:spelling "cursor", :type "CXCursor"}), :ret {:spelling "unsigned int", :type "unsigned int"}, :function/args [[:coffi.mem/pointer :clang/CXCursorSetImpl] :clang/CXCursor], :symbol "clang_CXCursorSet_contains", :name "clang_CXCursorSet_contains", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_CXCursorSet_contains, :doc "/**\n * Queries a CXCursorSet to see if it contains a specific CXCursor.\n *\n * \\returns non-zero if the set contains the specified cursor.\n */"} {:args ({:spelling "cset", :type "struct CXCursorSetImpl *"} {:spelling "cursor", :type "CXCursor"}), :ret {:spelling "unsigned int", :type "unsigned int"}, :function/args [[:coffi.mem/pointer :clang/CXCursorSetImpl] :clang/CXCursor], :symbol "clang_CXCursorSet_insert", :name "clang_CXCursorSet_insert", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_CXCursorSet_insert, :doc "/**\n * Inserts a CXCursor into a CXCursorSet.\n *\n * \\returns zero if the CXCursor was already in the set, and non-zero otherwise.\n */"} {:args ({:spelling "cursor", :type "CXCursor"}), :ret {:spelling "CXCursor", :type "CXCursor"}, :function/args [:clang/CXCursor], :symbol "clang_getCursorSemanticParent", :name "clang_getCursorSemanticParent", :function/ret :clang/CXCursor, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getCursorSemanticParent, :doc "/**\n * Determine the semantic parent of the given cursor.\n *\n * The semantic parent of a cursor is the cursor that semantically contains\n * the given \\p cursor. For many declarations, the lexical and semantic parents\n * are equivalent (the lexical parent is returned by\n * \\c clang_getCursorLexicalParent()). They diverge when declarations or\n * definitions are provided out-of-line. For example:\n *\n * \\code\n * class C {\n *  void f();\n * };\n *\n * void C::f() { }\n * \\endcode\n *\n * In the out-of-line definition of \\c C::f, the semantic parent is\n * the class \\c C, of which this function is a member. The lexical parent is\n * the place where the declaration actually occurs in the source code; in this\n * case, the definition occurs in the translation unit. In general, the\n * lexical parent for a given entity can change without affecting the semantics\n * of the program, and the lexical parent of different declarations of the\n * same entity may be different. Changing the semantic parent of a declaration,\n * on the other hand, can have a major impact on semantics, and redeclarations\n * of a particular entity should all have the same semantic context.\n *\n * In the example above, both declarations of \\c C::f have \\c C as their\n * semantic context, while the lexical context of the first \\c C::f is \\c C\n * and the lexical context of the second \\c C::f is the translation unit.\n *\n * For global declarations, the semantic parent is the translation unit.\n */"} {:args ({:spelling "cursor", :type "CXCursor"}), :ret {:spelling "CXCursor", :type "CXCursor"}, :function/args [:clang/CXCursor], :symbol "clang_getCursorLexicalParent", :name "clang_getCursorLexicalParent", :function/ret :clang/CXCursor, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getCursorLexicalParent, :doc "/**\n * Determine the lexical parent of the given cursor.\n *\n * The lexical parent of a cursor is the cursor in which the given \\p cursor\n * was actually written. For many declarations, the lexical and semantic parents\n * are equivalent (the semantic parent is returned by\n * \\c clang_getCursorSemanticParent()). They diverge when declarations or\n * definitions are provided out-of-line. For example:\n *\n * \\code\n * class C {\n *  void f();\n * };\n *\n * void C::f() { }\n * \\endcode\n *\n * In the out-of-line definition of \\c C::f, the semantic parent is\n * the class \\c C, of which this function is a member. The lexical parent is\n * the place where the declaration actually occurs in the source code; in this\n * case, the definition occurs in the translation unit. In general, the\n * lexical parent for a given entity can change without affecting the semantics\n * of the program, and the lexical parent of different declarations of the\n * same entity may be different. Changing the semantic parent of a declaration,\n * on the other hand, can have a major impact on semantics, and redeclarations\n * of a particular entity should all have the same semantic context.\n *\n * In the example above, both declarations of \\c C::f have \\c C as their\n * semantic context, while the lexical context of the first \\c C::f is \\c C\n * and the lexical context of the second \\c C::f is the translation unit.\n *\n * For declarations written in the global scope, the lexical parent is\n * the translation unit.\n */"} {:args ({:spelling "cursor", :type "CXCursor"} {:spelling "overridden", :type "CXCursor **"} {:spelling "num_overridden", :type "unsigned int *"}), :ret {:spelling "void", :type "void"}, :function/args [:clang/CXCursor [:coffi.mem/pointer [:coffi.mem/pointer :clang/CXCursor]] [:coffi.mem/pointer :coffi.mem/int]], :symbol "clang_getOverriddenCursors", :name "clang_getOverriddenCursors", :function/ret :coffi.mem/void, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getOverriddenCursors, :doc "/**\n * Determine the set of methods that are overridden by the given\n * method.\n *\n * In both Objective-C and C++, a method (aka virtual member function,\n * in C++) can override a virtual method in a base class. For\n * Objective-C, a method is said to override any method in the class's\n * base class, its protocols, or its categories' protocols, that has the same\n * selector and is of the same kind (class or instance).\n * If no such method exists, the search continues to the class's superclass,\n * its protocols, and its categories, and so on. A method from an Objective-C\n * implementation is considered to override the same methods as its\n * corresponding method in the interface.\n *\n * For C++, a virtual member function overrides any virtual member\n * function with the same signature that occurs in its base\n * classes. With multiple inheritance, a virtual member function can\n * override several virtual member functions coming from different\n * base classes.\n *\n * In all cases, this function determines the immediate overridden\n * method, rather than all of the overridden methods. For example, if\n * a method is originally declared in a class A, then overridden in B\n * (which in inherits from A) and also in C (which inherited from B),\n * then the only overridden method returned from this function when\n * invoked on C's method will be B's method. The client may then\n * invoke this function again, given the previously-found overridden\n * methods, to map out the complete method-override set.\n *\n * \\param cursor A cursor representing an Objective-C or C++\n * method. This routine will compute the set of methods that this\n * method overrides.\n *\n * \\param overridden A pointer whose pointee will be replaced with a\n * pointer to an array of cursors, representing the set of overridden\n * methods. If there are no overridden methods, the pointee will be\n * set to NULL. The pointee must be freed via a call to\n * \\c clang_disposeOverriddenCursors().\n *\n * \\param num_overridden A pointer to the number of overridden\n * functions, will be set to the number of overridden functions in the\n * array pointed to by \\p overridden.\n */"} {:args ({:spelling "overridden", :type "CXCursor *"}), :ret {:spelling "void", :type "void"}, :function/args [[:coffi.mem/pointer :clang/CXCursor]], :symbol "clang_disposeOverriddenCursors", :name "clang_disposeOverriddenCursors", :function/ret :coffi.mem/void, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_disposeOverriddenCursors, :doc "/**\n * Free the set of overridden cursors returned by \\c\n * clang_getOverriddenCursors().\n */"} {:args ({:spelling "cursor", :type "CXCursor"}), :ret {:spelling "CXFile", :type "void *"}, :function/args [:clang/CXCursor], :symbol "clang_getIncludedFile", :name "clang_getIncludedFile", :function/ret :coffi.mem/pointer, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getIncludedFile, :doc "/**\n * Retrieve the file that is included by the given inclusion directive\n * cursor.\n */"} {:args ({:spelling "", :type "struct CXTranslationUnitImpl *"} {:spelling "", :type "CXSourceLocation"}), :ret {:spelling "CXCursor", :type "CXCursor"}, :function/args [[:coffi.mem/pointer :clang/CXTranslationUnitImpl] :clang/CXSourceLocation], :symbol "clang_getCursor", :name "clang_getCursor", :function/ret :clang/CXCursor, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getCursor, :doc "/**\n * Map a source location to the cursor that describes the entity at that\n * location in the source code.\n *\n * clang_getCursor() maps an arbitrary source location within a translation\n * unit down to the most specific cursor that describes the entity at that\n * location. For example, given an expression \\c x + y, invoking\n * clang_getCursor() with a source location pointing to \"x\" will return the\n * cursor for \"x\"; similarly for \"y\". If the cursor points anywhere between\n * \"x\" or \"y\" (e.g., on the + or the whitespace around it), clang_getCursor()\n * will return a cursor referring to the \"+\" expression.\n *\n * \\returns a cursor representing the entity at the given source location, or\n * a NULL cursor if no such entity can be found.\n */"} {:args ({:spelling "", :type "CXCursor"}), :ret {:spelling "CXSourceLocation", :type "CXSourceLocation"}, :function/args [:clang/CXCursor], :symbol "clang_getCursorLocation", :name "clang_getCursorLocation", :function/ret :clang/CXSourceLocation, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getCursorLocation, :doc "/**\n * Retrieve the physical location of the source constructor referenced\n * by the given cursor.\n *\n * The location of a declaration is typically the location of the name of that\n * declaration, where the name of that declaration would occur if it is\n * unnamed, or some keyword that introduces that particular declaration.\n * The location of a reference is where that reference occurs within the\n * source code.\n */"} {:args ({:spelling "", :type "CXCursor"}), :ret {:spelling "CXSourceRange", :type "CXSourceRange"}, :function/args [:clang/CXCursor], :symbol "clang_getCursorExtent", :name "clang_getCursorExtent", :function/ret :clang/CXSourceRange, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getCursorExtent, :doc "/**\n * Retrieve the physical extent of the source construct referenced by\n * the given cursor.\n *\n * The extent of a cursor starts with the file/line/column pointing at the\n * first character within the source construct that the cursor refers to and\n * ends with the last character within that source construct. For a\n * declaration, the extent covers the declaration itself. For a reference,\n * the extent covers the location of the reference (e.g., where the referenced\n * entity was actually used).\n */"} {:args ({:spelling "C", :type "CXCursor"}), :ret {:spelling "CXType", :type "CXType"}, :function/args [:clang/CXCursor], :symbol "clang_getCursorType", :name "clang_getCursorType", :function/ret :clang/CXType, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getCursorType, :doc "/**\n * Retrieve the type of a CXCursor (if any).\n */"} {:args ({:spelling "CT", :type "CXType"}), :ret {:spelling "CXString", :type "CXString"}, :function/args [:clang/CXType], :symbol "clang_getTypeSpelling", :name "clang_getTypeSpelling", :function/ret :clang/CXString, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getTypeSpelling, :doc "/**\n * Pretty-print the underlying type using the rules of the\n * language of the translation unit from which it came.\n *\n * If the type is invalid, an empty string is returned.\n */"} {:args ({:spelling "C", :type "CXCursor"}), :ret {:spelling "CXType", :type "CXType"}, :function/args [:clang/CXCursor], :symbol "clang_getTypedefDeclUnderlyingType", :name "clang_getTypedefDeclUnderlyingType", :function/ret :clang/CXType, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getTypedefDeclUnderlyingType, :doc "/**\n * Retrieve the underlying type of a typedef declaration.\n *\n * If the cursor does not reference a typedef declaration, an invalid type is\n * returned.\n */"} {:args ({:spelling "C", :type "CXCursor"}), :ret {:spelling "CXType", :type "CXType"}, :function/args [:clang/CXCursor], :symbol "clang_getEnumDeclIntegerType", :name "clang_getEnumDeclIntegerType", :function/ret :clang/CXType, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getEnumDeclIntegerType, :doc "/**\n * Retrieve the integer type of an enum declaration.\n *\n * If the cursor does not reference an enum declaration, an invalid type is\n * returned.\n */"} {:args ({:spelling "C", :type "CXCursor"}), :ret {:spelling "long long", :type "long long"}, :function/args [:clang/CXCursor], :symbol "clang_getEnumConstantDeclValue", :name "clang_getEnumConstantDeclValue", :function/ret :coffi.mem/long, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getEnumConstantDeclValue, :doc "/**\n * Retrieve the integer value of an enum constant declaration as a signed\n *  long long.\n *\n * If the cursor does not reference an enum constant declaration, LLONG_MIN is\n * returned. Since this is also potentially a valid constant value, the kind of\n * the cursor must be verified before calling this function.\n */"} {:args ({:spelling "C", :type "CXCursor"}), :ret {:spelling "unsigned long long", :type "unsigned long long"}, :function/args [:clang/CXCursor], :symbol "clang_getEnumConstantDeclUnsignedValue", :name "clang_getEnumConstantDeclUnsignedValue", :function/ret :coffi.mem/long, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getEnumConstantDeclUnsignedValue, :doc "/**\n * Retrieve the integer value of an enum constant declaration as an unsigned\n *  long long.\n *\n * If the cursor does not reference an enum constant declaration, ULLONG_MAX is\n * returned. Since this is also potentially a valid constant value, the kind of\n * the cursor must be verified before calling this function.\n */"} {:args ({:spelling "C", :type "CXCursor"}), :ret {:spelling "int", :type "int"}, :function/args [:clang/CXCursor], :symbol "clang_getFieldDeclBitWidth", :name "clang_getFieldDeclBitWidth", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getFieldDeclBitWidth, :doc "/**\n * Retrieve the bit width of a bit field declaration as an integer.\n *\n * If a cursor that is not a bit field declaration is passed in, -1 is returned.\n */"} {:args ({:spelling "C", :type "CXCursor"}), :ret {:spelling "int", :type "int"}, :function/args [:clang/CXCursor], :symbol "clang_Cursor_getNumArguments", :name "clang_Cursor_getNumArguments", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_Cursor_getNumArguments, :doc "/**\n * Retrieve the number of non-variadic arguments associated with a given\n * cursor.\n *\n * The number of arguments can be determined for calls as well as for\n * declarations of functions or methods. For other cursors -1 is returned.\n */"} {:args ({:spelling "C", :type "CXCursor"} {:spelling "i", :type "unsigned int"}), :ret {:spelling "CXCursor", :type "CXCursor"}, :function/args [:clang/CXCursor :coffi.mem/int], :symbol "clang_Cursor_getArgument", :name "clang_Cursor_getArgument", :function/ret :clang/CXCursor, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_Cursor_getArgument, :doc "/**\n * Retrieve the argument cursor of a function or method.\n *\n * The argument cursor can be determined for calls as well as for declarations\n * of functions or methods. For other cursors and for invalid indices, an\n * invalid cursor is returned.\n */"} {:args ({:spelling "C", :type "CXCursor"}), :ret {:spelling "int", :type "int"}, :function/args [:clang/CXCursor], :symbol "clang_Cursor_getNumTemplateArguments", :name "clang_Cursor_getNumTemplateArguments", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_Cursor_getNumTemplateArguments, :doc "/**\n *Returns the number of template args of a function decl representing a\n * template specialization.\n *\n * If the argument cursor cannot be converted into a template function\n * declaration, -1 is returned.\n *\n * For example, for the following declaration and specialization:\n *   template <typename T, int kInt, bool kBool>\n *   void foo() { ... }\n *\n *   template <>\n *   void foo<float, -7, true>();\n *\n * The value 3 would be returned from this call.\n */"} {:args ({:spelling "C", :type "CXCursor"} {:spelling "I", :type "unsigned int"}), :ret {:spelling "enum CXTemplateArgumentKind", :type "enum CXTemplateArgumentKind"}, :function/args [:clang/CXCursor :coffi.mem/int], :symbol "clang_Cursor_getTemplateArgumentKind", :name "clang_Cursor_getTemplateArgumentKind", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_Cursor_getTemplateArgumentKind, :doc "/**\n * Retrieve the kind of the I'th template argument of the CXCursor C.\n *\n * If the argument CXCursor does not represent a FunctionDecl, an invalid\n * template argument kind is returned.\n *\n * For example, for the following declaration and specialization:\n *   template <typename T, int kInt, bool kBool>\n *   void foo() { ... }\n *\n *   template <>\n *   void foo<float, -7, true>();\n *\n * For I = 0, 1, and 2, Type, Integral, and Integral will be returned,\n * respectively.\n */"} {:args ({:spelling "C", :type "CXCursor"} {:spelling "I", :type "unsigned int"}), :ret {:spelling "CXType", :type "CXType"}, :function/args [:clang/CXCursor :coffi.mem/int], :symbol "clang_Cursor_getTemplateArgumentType", :name "clang_Cursor_getTemplateArgumentType", :function/ret :clang/CXType, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_Cursor_getTemplateArgumentType, :doc "/**\n * Retrieve a CXType representing the type of a TemplateArgument of a\n *  function decl representing a template specialization.\n *\n * If the argument CXCursor does not represent a FunctionDecl whose I'th\n * template argument has a kind of CXTemplateArgKind_Integral, an invalid type\n * is returned.\n *\n * For example, for the following declaration and specialization:\n *   template <typename T, int kInt, bool kBool>\n *   void foo() { ... }\n *\n *   template <>\n *   void foo<float, -7, true>();\n *\n * If called with I = 0, \"float\", will be returned.\n * Invalid types will be returned for I == 1 or 2.\n */"} {:args ({:spelling "C", :type "CXCursor"} {:spelling "I", :type "unsigned int"}), :ret {:spelling "long long", :type "long long"}, :function/args [:clang/CXCursor :coffi.mem/int], :symbol "clang_Cursor_getTemplateArgumentValue", :name "clang_Cursor_getTemplateArgumentValue", :function/ret :coffi.mem/long, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_Cursor_getTemplateArgumentValue, :doc "/**\n * Retrieve the value of an Integral TemplateArgument (of a function\n *  decl representing a template specialization) as a signed long long.\n *\n * It is undefined to call this function on a CXCursor that does not represent a\n * FunctionDecl or whose I'th template argument is not an integral value.\n *\n * For example, for the following declaration and specialization:\n *   template <typename T, int kInt, bool kBool>\n *   void foo() { ... }\n *\n *   template <>\n *   void foo<float, -7, true>();\n *\n * If called with I = 1 or 2, -7 or true will be returned, respectively.\n * For I == 0, this function's behavior is undefined.\n */"} {:args ({:spelling "C", :type "CXCursor"} {:spelling "I", :type "unsigned int"}), :ret {:spelling "unsigned long long", :type "unsigned long long"}, :function/args [:clang/CXCursor :coffi.mem/int], :symbol "clang_Cursor_getTemplateArgumentUnsignedValue", :name "clang_Cursor_getTemplateArgumentUnsignedValue", :function/ret :coffi.mem/long, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_Cursor_getTemplateArgumentUnsignedValue, :doc "/**\n * Retrieve the value of an Integral TemplateArgument (of a function\n *  decl representing a template specialization) as an unsigned long long.\n *\n * It is undefined to call this function on a CXCursor that does not represent a\n * FunctionDecl or whose I'th template argument is not an integral value.\n *\n * For example, for the following declaration and specialization:\n *   template <typename T, int kInt, bool kBool>\n *   void foo() { ... }\n *\n *   template <>\n *   void foo<float, 2147483649, true>();\n *\n * If called with I = 1 or 2, 2147483649 or true will be returned, respectively.\n * For I == 0, this function's behavior is undefined.\n */"} {:args ({:spelling "A", :type "CXType"} {:spelling "B", :type "CXType"}), :ret {:spelling "unsigned int", :type "unsigned int"}, :function/args [:clang/CXType :clang/CXType], :symbol "clang_equalTypes", :name "clang_equalTypes", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_equalTypes, :doc "/**\n * Determine whether two CXTypes represent the same type.\n *\n * \\returns non-zero if the CXTypes represent the same type and\n *          zero otherwise.\n */"} {:args ({:spelling "T", :type "CXType"}), :ret {:spelling "CXType", :type "CXType"}, :function/args [:clang/CXType], :symbol "clang_getCanonicalType", :name "clang_getCanonicalType", :function/ret :clang/CXType, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getCanonicalType, :doc "/**\n * Return the canonical type for a CXType.\n *\n * Clang's type system explicitly models typedefs and all the ways\n * a specific type can be represented.  The canonical type is the underlying\n * type with all the \"sugar\" removed.  For example, if 'T' is a typedef\n * for 'int', the canonical type for 'T' would be 'int'.\n */"} {:args ({:spelling "T", :type "CXType"}), :ret {:spelling "unsigned int", :type "unsigned int"}, :function/args [:clang/CXType], :symbol "clang_isConstQualifiedType", :name "clang_isConstQualifiedType", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_isConstQualifiedType, :doc "/**\n * Determine whether a CXType has the \"const\" qualifier set,\n * without looking through typedefs that may have added \"const\" at a\n * different level.\n */"} {:args ({:spelling "C", :type "CXCursor"}), :ret {:spelling "unsigned int", :type "unsigned int"}, :function/args [:clang/CXCursor], :symbol "clang_Cursor_isMacroFunctionLike", :name "clang_Cursor_isMacroFunctionLike", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_Cursor_isMacroFunctionLike, :doc "/**\n * Determine whether a  CXCursor that is a macro, is\n * function like.\n */"} {:args ({:spelling "C", :type "CXCursor"}), :ret {:spelling "unsigned int", :type "unsigned int"}, :function/args [:clang/CXCursor], :symbol "clang_Cursor_isMacroBuiltin", :name "clang_Cursor_isMacroBuiltin", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_Cursor_isMacroBuiltin, :doc "/**\n * Determine whether a  CXCursor that is a macro, is a\n * builtin one.\n */"} {:args ({:spelling "C", :type "CXCursor"}), :ret {:spelling "unsigned int", :type "unsigned int"}, :function/args [:clang/CXCursor], :symbol "clang_Cursor_isFunctionInlined", :name "clang_Cursor_isFunctionInlined", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_Cursor_isFunctionInlined, :doc "/**\n * Determine whether a  CXCursor that is a function declaration, is an\n * inline declaration.\n */"} {:args ({:spelling "T", :type "CXType"}), :ret {:spelling "unsigned int", :type "unsigned int"}, :function/args [:clang/CXType], :symbol "clang_isVolatileQualifiedType", :name "clang_isVolatileQualifiedType", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_isVolatileQualifiedType, :doc "/**\n * Determine whether a CXType has the \"volatile\" qualifier set,\n * without looking through typedefs that may have added \"volatile\" at\n * a different level.\n */"} {:args ({:spelling "T", :type "CXType"}), :ret {:spelling "unsigned int", :type "unsigned int"}, :function/args [:clang/CXType], :symbol "clang_isRestrictQualifiedType", :name "clang_isRestrictQualifiedType", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_isRestrictQualifiedType, :doc "/**\n * Determine whether a CXType has the \"restrict\" qualifier set,\n * without looking through typedefs that may have added \"restrict\" at a\n * different level.\n */"} {:args ({:spelling "T", :type "CXType"}), :ret {:spelling "unsigned int", :type "unsigned int"}, :function/args [:clang/CXType], :symbol "clang_getAddressSpace", :name "clang_getAddressSpace", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getAddressSpace, :doc "/**\n * Returns the address space of the given type.\n */"} {:args ({:spelling "CT", :type "CXType"}), :ret {:spelling "CXString", :type "CXString"}, :function/args [:clang/CXType], :symbol "clang_getTypedefName", :name "clang_getTypedefName", :function/ret :clang/CXString, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getTypedefName, :doc "/**\n * Returns the typedef name of the given type.\n */"} {:args ({:spelling "T", :type "CXType"}), :ret {:spelling "CXType", :type "CXType"}, :function/args [:clang/CXType], :symbol "clang_getPointeeType", :name "clang_getPointeeType", :function/ret :clang/CXType, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getPointeeType, :doc "/**\n * For pointer types, returns the type of the pointee.\n */"} {:args ({:spelling "T", :type "CXType"}), :ret {:spelling "CXCursor", :type "CXCursor"}, :function/args [:clang/CXType], :symbol "clang_getTypeDeclaration", :name "clang_getTypeDeclaration", :function/ret :clang/CXCursor, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getTypeDeclaration, :doc "/**\n * Return the cursor for the declaration of the given type.\n */"} {:args ({:spelling "C", :type "CXCursor"}), :ret {:spelling "CXString", :type "CXString"}, :function/args [:clang/CXCursor], :symbol "clang_getDeclObjCTypeEncoding", :name "clang_getDeclObjCTypeEncoding", :function/ret :clang/CXString, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getDeclObjCTypeEncoding, :doc "/**\n * Returns the Objective-C type encoding for the specified declaration.\n */"} {:args ({:spelling "type", :type "CXType"}), :ret {:spelling "CXString", :type "CXString"}, :function/args [:clang/CXType], :symbol "clang_Type_getObjCEncoding", :name "clang_Type_getObjCEncoding", :function/ret :clang/CXString, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_Type_getObjCEncoding, :doc "/**\n * Returns the Objective-C type encoding for the specified CXType.\n */"} {:args ({:spelling "K", :type "enum CXTypeKind"}), :ret {:spelling "CXString", :type "CXString"}, :function/args [:coffi.mem/int], :symbol "clang_getTypeKindSpelling", :name "clang_getTypeKindSpelling", :function/ret :clang/CXString, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getTypeKindSpelling, :doc "/**\n * Retrieve the spelling of a given CXTypeKind.\n */"} {:args ({:spelling "T", :type "CXType"}), :ret {:spelling "enum CXCallingConv", :type "enum CXCallingConv"}, :function/args [:clang/CXType], :symbol "clang_getFunctionTypeCallingConv", :name "clang_getFunctionTypeCallingConv", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getFunctionTypeCallingConv, :doc "/**\n * Retrieve the calling convention associated with a function type.\n *\n * If a non-function type is passed in, CXCallingConv_Invalid is returned.\n */"} {:args ({:spelling "T", :type "CXType"}), :ret {:spelling "CXType", :type "CXType"}, :function/args [:clang/CXType], :symbol "clang_getResultType", :name "clang_getResultType", :function/ret :clang/CXType, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getResultType, :doc "/**\n * Retrieve the return type associated with a function type.\n *\n * If a non-function type is passed in, an invalid type is returned.\n */"} {:args ({:spelling "T", :type "CXType"}), :ret {:spelling "int", :type "int"}, :function/args [:clang/CXType], :symbol "clang_getExceptionSpecificationType", :name "clang_getExceptionSpecificationType", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getExceptionSpecificationType, :doc "/**\n * Retrieve the exception specification type associated with a function type.\n * This is a value of type CXCursor_ExceptionSpecificationKind.\n *\n * If a non-function type is passed in, an error code of -1 is returned.\n */"} {:args ({:spelling "T", :type "CXType"}), :ret {:spelling "int", :type "int"}, :function/args [:clang/CXType], :symbol "clang_getNumArgTypes", :name "clang_getNumArgTypes", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getNumArgTypes, :doc "/**\n * Retrieve the number of non-variadic parameters associated with a\n * function type.\n *\n * If a non-function type is passed in, -1 is returned.\n */"} {:args ({:spelling "T", :type "CXType"} {:spelling "i", :type "unsigned int"}), :ret {:spelling "CXType", :type "CXType"}, :function/args [:clang/CXType :coffi.mem/int], :symbol "clang_getArgType", :name "clang_getArgType", :function/ret :clang/CXType, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getArgType, :doc "/**\n * Retrieve the type of a parameter of a function type.\n *\n * If a non-function type is passed in or the function does not have enough\n * parameters, an invalid type is returned.\n */"} {:args ({:spelling "T", :type "CXType"}), :ret {:spelling "CXType", :type "CXType"}, :function/args [:clang/CXType], :symbol "clang_Type_getObjCObjectBaseType", :name "clang_Type_getObjCObjectBaseType", :function/ret :clang/CXType, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_Type_getObjCObjectBaseType, :doc "/**\n * Retrieves the base type of the ObjCObjectType.\n *\n * If the type is not an ObjC object, an invalid type is returned.\n */"} {:args ({:spelling "T", :type "CXType"}), :ret {:spelling "unsigned int", :type "unsigned int"}, :function/args [:clang/CXType], :symbol "clang_Type_getNumObjCProtocolRefs", :name "clang_Type_getNumObjCProtocolRefs", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_Type_getNumObjCProtocolRefs, :doc "/**\n * Retrieve the number of protocol references associated with an ObjC object/id.\n *\n * If the type is not an ObjC object, 0 is returned.\n */"} {:args ({:spelling "T", :type "CXType"} {:spelling "i", :type "unsigned int"}), :ret {:spelling "CXCursor", :type "CXCursor"}, :function/args [:clang/CXType :coffi.mem/int], :symbol "clang_Type_getObjCProtocolDecl", :name "clang_Type_getObjCProtocolDecl", :function/ret :clang/CXCursor, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_Type_getObjCProtocolDecl, :doc "/**\n * Retrieve the decl for a protocol reference for an ObjC object/id.\n *\n * If the type is not an ObjC object or there are not enough protocol\n * references, an invalid cursor is returned.\n */"} {:args ({:spelling "T", :type "CXType"}), :ret {:spelling "unsigned int", :type "unsigned int"}, :function/args [:clang/CXType], :symbol "clang_Type_getNumObjCTypeArgs", :name "clang_Type_getNumObjCTypeArgs", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_Type_getNumObjCTypeArgs, :doc "/**\n * Retrieve the number of type arguments associated with an ObjC object.\n *\n * If the type is not an ObjC object, 0 is returned.\n */"} {:args ({:spelling "T", :type "CXType"} {:spelling "i", :type "unsigned int"}), :ret {:spelling "CXType", :type "CXType"}, :function/args [:clang/CXType :coffi.mem/int], :symbol "clang_Type_getObjCTypeArg", :name "clang_Type_getObjCTypeArg", :function/ret :clang/CXType, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_Type_getObjCTypeArg, :doc "/**\n * Retrieve a type argument associated with an ObjC object.\n *\n * If the type is not an ObjC or the index is not valid,\n * an invalid type is returned.\n */"} {:args ({:spelling "T", :type "CXType"}), :ret {:spelling "unsigned int", :type "unsigned int"}, :function/args [:clang/CXType], :symbol "clang_isFunctionTypeVariadic", :name "clang_isFunctionTypeVariadic", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_isFunctionTypeVariadic, :doc "/**\n * Return 1 if the CXType is a variadic function type, and 0 otherwise.\n */"} {:args ({:spelling "C", :type "CXCursor"}), :ret {:spelling "CXType", :type "CXType"}, :function/args [:clang/CXCursor], :symbol "clang_getCursorResultType", :name "clang_getCursorResultType", :function/ret :clang/CXType, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getCursorResultType, :doc "/**\n * Retrieve the return type associated with a given cursor.\n *\n * This only returns a valid type if the cursor refers to a function or method.\n */"} {:args ({:spelling "C", :type "CXCursor"}), :ret {:spelling "int", :type "int"}, :function/args [:clang/CXCursor], :symbol "clang_getCursorExceptionSpecificationType", :name "clang_getCursorExceptionSpecificationType", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getCursorExceptionSpecificationType, :doc "/**\n * Retrieve the exception specification type associated with a given cursor.\n * This is a value of type CXCursor_ExceptionSpecificationKind.\n *\n * This only returns a valid result if the cursor refers to a function or\n * method.\n */"} {:args ({:spelling "T", :type "CXType"}), :ret {:spelling "unsigned int", :type "unsigned int"}, :function/args [:clang/CXType], :symbol "clang_isPODType", :name "clang_isPODType", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_isPODType, :doc "/**\n * Return 1 if the CXType is a POD (plain old data) type, and 0\n *  otherwise.\n */"} {:args ({:spelling "T", :type "CXType"}), :ret {:spelling "CXType", :type "CXType"}, :function/args [:clang/CXType], :symbol "clang_getElementType", :name "clang_getElementType", :function/ret :clang/CXType, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getElementType, :doc "/**\n * Return the element type of an array, complex, or vector type.\n *\n * If a type is passed in that is not an array, complex, or vector type,\n * an invalid type is returned.\n */"} {:args ({:spelling "T", :type "CXType"}), :ret {:spelling "long long", :type "long long"}, :function/args [:clang/CXType], :symbol "clang_getNumElements", :name "clang_getNumElements", :function/ret :coffi.mem/long, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getNumElements, :doc "/**\n * Return the number of elements of an array or vector type.\n *\n * If a type is passed in that is not an array or vector type,\n * -1 is returned.\n */"} {:args ({:spelling "T", :type "CXType"}), :ret {:spelling "CXType", :type "CXType"}, :function/args [:clang/CXType], :symbol "clang_getArrayElementType", :name "clang_getArrayElementType", :function/ret :clang/CXType, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getArrayElementType, :doc "/**\n * Return the element type of an array type.\n *\n * If a non-array type is passed in, an invalid type is returned.\n */"} {:args ({:spelling "T", :type "CXType"}), :ret {:spelling "long long", :type "long long"}, :function/args [:clang/CXType], :symbol "clang_getArraySize", :name "clang_getArraySize", :function/ret :coffi.mem/long, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getArraySize, :doc "/**\n * Return the array size of a constant array.\n *\n * If a non-array type is passed in, -1 is returned.\n */"} {:args ({:spelling "T", :type "CXType"}), :ret {:spelling "CXType", :type "CXType"}, :function/args [:clang/CXType], :symbol "clang_Type_getNamedType", :name "clang_Type_getNamedType", :function/ret :clang/CXType, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_Type_getNamedType, :doc "/**\n * Retrieve the type named by the qualified-id.\n *\n * If a non-elaborated type is passed in, an invalid type is returned.\n */"} {:args ({:spelling "T", :type "CXType"}), :ret {:spelling "unsigned int", :type "unsigned int"}, :function/args [:clang/CXType], :symbol "clang_Type_isTransparentTagTypedef", :name "clang_Type_isTransparentTagTypedef", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_Type_isTransparentTagTypedef, :doc "/**\n * Determine if a typedef is 'transparent' tag.\n *\n * A typedef is considered 'transparent' if it shares a name and spelling\n * location with its underlying tag type, as is the case with the NS_ENUM macro.\n *\n * \\returns non-zero if transparent and zero otherwise.\n */"} {:args ({:spelling "T", :type "CXType"}), :ret {:spelling "enum CXTypeNullabilityKind", :type "enum CXTypeNullabilityKind"}, :function/args [:clang/CXType], :symbol "clang_Type_getNullability", :name "clang_Type_getNullability", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_Type_getNullability, :doc "/**\n * Retrieve the nullability kind of a pointer type.\n */"} {:args ({:spelling "T", :type "CXType"}), :ret {:spelling "long long", :type "long long"}, :function/args [:clang/CXType], :symbol "clang_Type_getAlignOf", :name "clang_Type_getAlignOf", :function/ret :coffi.mem/long, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_Type_getAlignOf, :doc "/**\n * Return the alignment of a type in bytes as per C++[expr.alignof]\n *   standard.\n *\n * If the type declaration is invalid, CXTypeLayoutError_Invalid is returned.\n * If the type declaration is an incomplete type, CXTypeLayoutError_Incomplete\n *   is returned.\n * If the type declaration is a dependent type, CXTypeLayoutError_Dependent is\n *   returned.\n * If the type declaration is not a constant size type,\n *   CXTypeLayoutError_NotConstantSize is returned.\n */"} {:args ({:spelling "T", :type "CXType"}), :ret {:spelling "CXType", :type "CXType"}, :function/args [:clang/CXType], :symbol "clang_Type_getClassType", :name "clang_Type_getClassType", :function/ret :clang/CXType, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_Type_getClassType, :doc "/**\n * Return the class type of an member pointer type.\n *\n * If a non-member-pointer type is passed in, an invalid type is returned.\n */"} {:args ({:spelling "T", :type "CXType"}), :ret {:spelling "long long", :type "long long"}, :function/args [:clang/CXType], :symbol "clang_Type_getSizeOf", :name "clang_Type_getSizeOf", :function/ret :coffi.mem/long, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_Type_getSizeOf, :doc "/**\n * Return the size of a type in bytes as per C++[expr.sizeof] standard.\n *\n * If the type declaration is invalid, CXTypeLayoutError_Invalid is returned.\n * If the type declaration is an incomplete type, CXTypeLayoutError_Incomplete\n *   is returned.\n * If the type declaration is a dependent type, CXTypeLayoutError_Dependent is\n *   returned.\n */"} {:args ({:spelling "T", :type "CXType"} {:spelling "S", :type "const char *"}), :ret {:spelling "long long", :type "long long"}, :function/args [:clang/CXType [:coffi.mem/pointer :coffi.mem/char]], :symbol "clang_Type_getOffsetOf", :name "clang_Type_getOffsetOf", :function/ret :coffi.mem/long, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_Type_getOffsetOf, :doc "/**\n * Return the offset of a field named S in a record of type T in bits\n *   as it would be returned by __offsetof__ as per C++11[18.2p4]\n *\n * If the cursor is not a record field declaration, CXTypeLayoutError_Invalid\n *   is returned.\n * If the field's type declaration is an incomplete type,\n *   CXTypeLayoutError_Incomplete is returned.\n * If the field's type declaration is a dependent type,\n *   CXTypeLayoutError_Dependent is returned.\n * If the field's name S is not found,\n *   CXTypeLayoutError_InvalidFieldName is returned.\n */"} {:args ({:spelling "T", :type "CXType"}), :ret {:spelling "CXType", :type "CXType"}, :function/args [:clang/CXType], :symbol "clang_Type_getModifiedType", :name "clang_Type_getModifiedType", :function/ret :clang/CXType, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_Type_getModifiedType, :doc "/**\n * Return the type that was modified by this attributed type.\n *\n * If the type is not an attributed type, an invalid type is returned.\n */"} {:args ({:spelling "CT", :type "CXType"}), :ret {:spelling "CXType", :type "CXType"}, :function/args [:clang/CXType], :symbol "clang_Type_getValueType", :name "clang_Type_getValueType", :function/ret :clang/CXType, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_Type_getValueType, :doc "/**\n * Gets the type contained by this atomic type.\n *\n * If a non-atomic type is passed in, an invalid type is returned.\n */"} {:args ({:spelling "C", :type "CXCursor"}), :ret {:spelling "long long", :type "long long"}, :function/args [:clang/CXCursor], :symbol "clang_Cursor_getOffsetOfField", :name "clang_Cursor_getOffsetOfField", :function/ret :coffi.mem/long, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_Cursor_getOffsetOfField, :doc "/**\n * Return the offset of the field represented by the Cursor.\n *\n * If the cursor is not a field declaration, -1 is returned.\n * If the cursor semantic parent is not a record field declaration,\n *   CXTypeLayoutError_Invalid is returned.\n * If the field's type declaration is an incomplete type,\n *   CXTypeLayoutError_Incomplete is returned.\n * If the field's type declaration is a dependent type,\n *   CXTypeLayoutError_Dependent is returned.\n * If the field's name S is not found,\n *   CXTypeLayoutError_InvalidFieldName is returned.\n */"} {:args ({:spelling "C", :type "CXCursor"}), :ret {:spelling "unsigned int", :type "unsigned int"}, :function/args [:clang/CXCursor], :symbol "clang_Cursor_isAnonymous", :name "clang_Cursor_isAnonymous", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_Cursor_isAnonymous, :doc "/**\n * Determine whether the given cursor represents an anonymous\n * tag or namespace\n */"} {:args ({:spelling "C", :type "CXCursor"}), :ret {:spelling "unsigned int", :type "unsigned int"}, :function/args [:clang/CXCursor], :symbol "clang_Cursor_isAnonymousRecordDecl", :name "clang_Cursor_isAnonymousRecordDecl", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_Cursor_isAnonymousRecordDecl, :doc "/**\n * Determine whether the given cursor represents an anonymous record\n * declaration.\n */"} {:args ({:spelling "C", :type "CXCursor"}), :ret {:spelling "unsigned int", :type "unsigned int"}, :function/args [:clang/CXCursor], :symbol "clang_Cursor_isInlineNamespace", :name "clang_Cursor_isInlineNamespace", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_Cursor_isInlineNamespace, :doc "/**\n * Determine whether the given cursor represents an inline namespace\n * declaration.\n */"} {:args ({:spelling "T", :type "CXType"}), :ret {:spelling "int", :type "int"}, :function/args [:clang/CXType], :symbol "clang_Type_getNumTemplateArguments", :name "clang_Type_getNumTemplateArguments", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_Type_getNumTemplateArguments, :doc "/**\n * Returns the number of template arguments for given template\n * specialization, or -1 if type \\c T is not a template specialization.\n */"} {:args ({:spelling "T", :type "CXType"} {:spelling "i", :type "unsigned int"}), :ret {:spelling "CXType", :type "CXType"}, :function/args [:clang/CXType :coffi.mem/int], :symbol "clang_Type_getTemplateArgumentAsType", :name "clang_Type_getTemplateArgumentAsType", :function/ret :clang/CXType, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_Type_getTemplateArgumentAsType, :doc "/**\n * Returns the type template argument of a template class specialization\n * at given index.\n *\n * This function only returns template type arguments and does not handle\n * template template arguments or variadic packs.\n */"} {:args ({:spelling "T", :type "CXType"}), :ret {:spelling "enum CXRefQualifierKind", :type "enum CXRefQualifierKind"}, :function/args [:clang/CXType], :symbol "clang_Type_getCXXRefQualifier", :name "clang_Type_getCXXRefQualifier", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_Type_getCXXRefQualifier, :doc "/**\n * Retrieve the ref-qualifier kind of a function or method.\n *\n * The ref-qualifier is returned for C++ functions or methods. For other types\n * or non-C++ declarations, CXRefQualifier_None is returned.\n */"} {:args ({:spelling "C", :type "CXCursor"}), :ret {:spelling "unsigned int", :type "unsigned int"}, :function/args [:clang/CXCursor], :symbol "clang_Cursor_isBitField", :name "clang_Cursor_isBitField", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_Cursor_isBitField, :doc "/**\n * Returns non-zero if the cursor specifies a Record member that is a\n *   bitfield.\n */"} {:args ({:spelling "", :type "CXCursor"}), :ret {:spelling "unsigned int", :type "unsigned int"}, :function/args [:clang/CXCursor], :symbol "clang_isVirtualBase", :name "clang_isVirtualBase", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_isVirtualBase, :doc "/**\n * Returns 1 if the base class specified by the cursor with kind\n *   CX_CXXBaseSpecifier is virtual.\n */"} {:args ({:spelling "", :type "CXCursor"}), :ret {:spelling "enum CX_CXXAccessSpecifier", :type "enum CX_CXXAccessSpecifier"}, :function/args [:clang/CXCursor], :symbol "clang_getCXXAccessSpecifier", :name "clang_getCXXAccessSpecifier", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getCXXAccessSpecifier, :doc "/**\n * Returns the access control level for the referenced object.\n *\n * If the cursor refers to a C++ declaration, its access control level within\n * its parent scope is returned. Otherwise, if the cursor refers to a base\n * specifier or access specifier, the specifier itself is returned.\n */"} {:args ({:spelling "", :type "CXCursor"}), :ret {:spelling "enum CX_StorageClass", :type "enum CX_StorageClass"}, :function/args [:clang/CXCursor], :symbol "clang_Cursor_getStorageClass", :name "clang_Cursor_getStorageClass", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_Cursor_getStorageClass, :doc "/**\n * Returns the storage class for a function or variable declaration.\n *\n * If the passed in Cursor is not a function or variable declaration,\n * CX_SC_Invalid is returned else the storage class.\n */"} {:args ({:spelling "cursor", :type "CXCursor"}), :ret {:spelling "unsigned int", :type "unsigned int"}, :function/args [:clang/CXCursor], :symbol "clang_getNumOverloadedDecls", :name "clang_getNumOverloadedDecls", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getNumOverloadedDecls, :doc "/**\n * Determine the number of overloaded declarations referenced by a\n * \\c CXCursor_OverloadedDeclRef cursor.\n *\n * \\param cursor The cursor whose overloaded declarations are being queried.\n *\n * \\returns The number of overloaded declarations referenced by \\c cursor. If it\n * is not a \\c CXCursor_OverloadedDeclRef cursor, returns 0.\n */"} {:args ({:spelling "cursor", :type "CXCursor"} {:spelling "index", :type "unsigned int"}), :ret {:spelling "CXCursor", :type "CXCursor"}, :function/args [:clang/CXCursor :coffi.mem/int], :symbol "clang_getOverloadedDecl", :name "clang_getOverloadedDecl", :function/ret :clang/CXCursor, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getOverloadedDecl, :doc "/**\n * Retrieve a cursor for one of the overloaded declarations referenced\n * by a \\c CXCursor_OverloadedDeclRef cursor.\n *\n * \\param cursor The cursor whose overloaded declarations are being queried.\n *\n * \\param index The zero-based index into the set of overloaded declarations in\n * the cursor.\n *\n * \\returns A cursor representing the declaration referenced by the given\n * \\c cursor at the specified \\c index. If the cursor does not have an\n * associated set of overloaded declarations, or if the index is out of bounds,\n * returns \\c clang_getNullCursor();\n */"} {:args ({:spelling "", :type "CXCursor"}), :ret {:spelling "CXType", :type "CXType"}, :function/args [:clang/CXCursor], :symbol "clang_getIBOutletCollectionType", :name "clang_getIBOutletCollectionType", :function/ret :clang/CXType, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getIBOutletCollectionType, :doc "/**\n * For cursors representing an iboutletcollection attribute,\n *  this function returns the collection element type.\n *\n */"} {:args ({:spelling "parent", :type "CXCursor"} {:spelling "visitor", :type "enum CXChildVisitResult (*)(CXCursor, CXCursor, void *)"} {:spelling "client_data", :type "void *"}), :ret {:spelling "unsigned int", :type "unsigned int"}, :function/args [:clang/CXCursor [:coffi.ffi/fn [:clang/CXCursor :clang/CXCursor :coffi.mem/pointer] :coffi.mem/int] :coffi.mem/pointer], :symbol "clang_visitChildren", :name "clang_visitChildren", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_visitChildren, :doc "/**\n * Visit the children of a particular cursor.\n *\n * This function visits all the direct children of the given cursor,\n * invoking the given \\p visitor function with the cursors of each\n * visited child. The traversal may be recursive, if the visitor returns\n * \\c CXChildVisit_Recurse. The traversal may also be ended prematurely, if\n * the visitor returns \\c CXChildVisit_Break.\n *\n * \\param parent the cursor whose child may be visited. All kinds of\n * cursors can be visited, including invalid cursors (which, by\n * definition, have no children).\n *\n * \\param visitor the visitor function that will be invoked for each\n * child of \\p parent.\n *\n * \\param client_data pointer data supplied by the client, which will\n * be passed to the visitor each time it is invoked.\n *\n * \\returns a non-zero value if the traversal was terminated\n * prematurely by the visitor returning \\c CXChildVisit_Break.\n */"} {:args ({:spelling "parent", :type "CXCursor"} {:spelling "block", :type "enum CXChildVisitResult (^)(CXCursor, CXCursor)"}), :ret {:spelling "unsigned int", :type "unsigned int"}, :function/args [:clang/CXCursor [:coffi.mem/pointer]], :symbol "clang_visitChildrenWithBlock", :name "clang_visitChildrenWithBlock", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_visitChildrenWithBlock, :doc "/**\n * Visits the children of a cursor using the specified block.  Behaves\n * identically to clang_visitChildren() in all other respects.\n */"} {:args ({:spelling "", :type "CXCursor"}), :ret {:spelling "CXString", :type "CXString"}, :function/args [:clang/CXCursor], :symbol "clang_getCursorUSR", :name "clang_getCursorUSR", :function/ret :clang/CXString, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getCursorUSR, :doc "/**\n * Retrieve a Unified Symbol Resolution (USR) for the entity referenced\n * by the given cursor.\n *\n * A Unified Symbol Resolution (USR) is a string that identifies a particular\n * entity (function, class, variable, etc.) within a program. USRs can be\n * compared across translation units to determine, e.g., when references in\n * one translation refer to an entity defined in another translation unit.\n */"} {:args ({:spelling "class_name", :type "const char *"}), :ret {:spelling "CXString", :type "CXString"}, :function/args [[:coffi.mem/pointer :coffi.mem/char]], :symbol "clang_constructUSR_ObjCClass", :name "clang_constructUSR_ObjCClass", :function/ret :clang/CXString, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_constructUSR_ObjCClass, :doc "/**\n * Construct a USR for a specified Objective-C class.\n */"} {:args ({:spelling "class_name", :type "const char *"} {:spelling "category_name", :type "const char *"}), :ret {:spelling "CXString", :type "CXString"}, :function/args [[:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer :coffi.mem/char]], :symbol "clang_constructUSR_ObjCCategory", :name "clang_constructUSR_ObjCCategory", :function/ret :clang/CXString, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_constructUSR_ObjCCategory, :doc "/**\n * Construct a USR for a specified Objective-C category.\n */"} {:args ({:spelling "protocol_name", :type "const char *"}), :ret {:spelling "CXString", :type "CXString"}, :function/args [[:coffi.mem/pointer :coffi.mem/char]], :symbol "clang_constructUSR_ObjCProtocol", :name "clang_constructUSR_ObjCProtocol", :function/ret :clang/CXString, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_constructUSR_ObjCProtocol, :doc "/**\n * Construct a USR for a specified Objective-C protocol.\n */"} {:args ({:spelling "name", :type "const char *"} {:spelling "classUSR", :type "CXString"}), :ret {:spelling "CXString", :type "CXString"}, :function/args [[:coffi.mem/pointer :coffi.mem/char] :clang/CXString], :symbol "clang_constructUSR_ObjCIvar", :name "clang_constructUSR_ObjCIvar", :function/ret :clang/CXString, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_constructUSR_ObjCIvar, :doc "/**\n * Construct a USR for a specified Objective-C instance variable and\n *   the USR for its containing class.\n */"} {:args ({:spelling "name", :type "const char *"} {:spelling "isInstanceMethod", :type "unsigned int"} {:spelling "classUSR", :type "CXString"}), :ret {:spelling "CXString", :type "CXString"}, :function/args [[:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int :clang/CXString], :symbol "clang_constructUSR_ObjCMethod", :name "clang_constructUSR_ObjCMethod", :function/ret :clang/CXString, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_constructUSR_ObjCMethod, :doc "/**\n * Construct a USR for a specified Objective-C method and\n *   the USR for its containing class.\n */"} {:args ({:spelling "property", :type "const char *"} {:spelling "classUSR", :type "CXString"}), :ret {:spelling "CXString", :type "CXString"}, :function/args [[:coffi.mem/pointer :coffi.mem/char] :clang/CXString], :symbol "clang_constructUSR_ObjCProperty", :name "clang_constructUSR_ObjCProperty", :function/ret :clang/CXString, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_constructUSR_ObjCProperty, :doc "/**\n * Construct a USR for a specified Objective-C property and the USR\n *  for its containing class.\n */"} {:args ({:spelling "", :type "CXCursor"}), :ret {:spelling "CXString", :type "CXString"}, :function/args [:clang/CXCursor], :symbol "clang_getCursorSpelling", :name "clang_getCursorSpelling", :function/ret :clang/CXString, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getCursorSpelling, :doc "/**\n * Retrieve a name for the entity referenced by this cursor.\n */"} {:args ({:spelling "", :type "CXCursor"} {:spelling "pieceIndex", :type "unsigned int"} {:spelling "options", :type "unsigned int"}), :ret {:spelling "CXSourceRange", :type "CXSourceRange"}, :function/args [:clang/CXCursor :coffi.mem/int :coffi.mem/int], :symbol "clang_Cursor_getSpellingNameRange", :name "clang_Cursor_getSpellingNameRange", :function/ret :clang/CXSourceRange, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_Cursor_getSpellingNameRange, :doc "/**\n * Retrieve a range for a piece that forms the cursors spelling name.\n * Most of the times there is only one range for the complete spelling but for\n * Objective-C methods and Objective-C message expressions, there are multiple\n * pieces for each selector identifier.\n *\n * \\param pieceIndex the index of the spelling name piece. If this is greater\n * than the actual number of pieces, it will return a NULL (invalid) range.\n *\n * \\param options Reserved.\n */"} {:args ({:spelling "Policy", :type "void *"} {:spelling "Property", :type "enum CXPrintingPolicyProperty"}), :ret {:spelling "unsigned int", :type "unsigned int"}, :function/args [:coffi.mem/pointer :coffi.mem/int], :symbol "clang_PrintingPolicy_getProperty", :name "clang_PrintingPolicy_getProperty", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_PrintingPolicy_getProperty, :doc "/**\n * Get a property value for the given printing policy.\n */"} {:args ({:spelling "Policy", :type "void *"} {:spelling "Property", :type "enum CXPrintingPolicyProperty"} {:spelling "Value", :type "unsigned int"}), :ret {:spelling "void", :type "void"}, :function/args [:coffi.mem/pointer :coffi.mem/int :coffi.mem/int], :symbol "clang_PrintingPolicy_setProperty", :name "clang_PrintingPolicy_setProperty", :function/ret :coffi.mem/void, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_PrintingPolicy_setProperty, :doc "/**\n * Set a property value for the given printing policy.\n */"} {:args ({:spelling "", :type "CXCursor"}), :ret {:spelling "CXPrintingPolicy", :type "void *"}, :function/args [:clang/CXCursor], :symbol "clang_getCursorPrintingPolicy", :name "clang_getCursorPrintingPolicy", :function/ret :coffi.mem/pointer, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getCursorPrintingPolicy, :doc "/**\n * Retrieve the default policy for the cursor.\n *\n * The policy should be released after use with \\c\n * clang_PrintingPolicy_dispose.\n */"} {:args ({:spelling "Policy", :type "void *"}), :ret {:spelling "void", :type "void"}, :function/args [:coffi.mem/pointer], :symbol "clang_PrintingPolicy_dispose", :name "clang_PrintingPolicy_dispose", :function/ret :coffi.mem/void, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_PrintingPolicy_dispose, :doc "/**\n * Release a printing policy.\n */"} {:args ({:spelling "Cursor", :type "CXCursor"} {:spelling "Policy", :type "void *"}), :ret {:spelling "CXString", :type "CXString"}, :function/args [:clang/CXCursor :coffi.mem/pointer], :symbol "clang_getCursorPrettyPrinted", :name "clang_getCursorPrettyPrinted", :function/ret :clang/CXString, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getCursorPrettyPrinted, :doc "/**\n * Pretty print declarations.\n *\n * \\param Cursor The cursor representing a declaration.\n *\n * \\param Policy The policy to control the entities being printed. If\n * NULL, a default policy is used.\n *\n * \\returns The pretty printed declaration or the empty string for\n * other cursors.\n */"} {:args ({:spelling "", :type "CXCursor"}), :ret {:spelling "CXString", :type "CXString"}, :function/args [:clang/CXCursor], :symbol "clang_getCursorDisplayName", :name "clang_getCursorDisplayName", :function/ret :clang/CXString, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getCursorDisplayName, :doc "/**\n * Retrieve the display name for the entity referenced by this cursor.\n *\n * The display name contains extra information that helps identify the cursor,\n * such as the parameters of a function or template or the arguments of a\n * class template specialization.\n */"} {:args ({:spelling "", :type "CXCursor"}), :ret {:spelling "CXCursor", :type "CXCursor"}, :function/args [:clang/CXCursor], :symbol "clang_getCursorReferenced", :name "clang_getCursorReferenced", :function/ret :clang/CXCursor, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getCursorReferenced, :doc "/** For a cursor that is a reference, retrieve a cursor representing the\n * entity that it references.\n *\n * Reference cursors refer to other entities in the AST. For example, an\n * Objective-C superclass reference cursor refers to an Objective-C class.\n * This function produces the cursor for the Objective-C class from the\n * cursor for the superclass reference. If the input cursor is a declaration or\n * definition, it returns that declaration or definition unchanged.\n * Otherwise, returns the NULL cursor.\n */"} {:args ({:spelling "", :type "CXCursor"}), :ret {:spelling "CXCursor", :type "CXCursor"}, :function/args [:clang/CXCursor], :symbol "clang_getCursorDefinition", :name "clang_getCursorDefinition", :function/ret :clang/CXCursor, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getCursorDefinition, :doc "/**\n *  For a cursor that is either a reference to or a declaration\n *  of some entity, retrieve a cursor that describes the definition of\n *  that entity.\n *\n *  Some entities can be declared multiple times within a translation\n *  unit, but only one of those declarations can also be a\n *  definition. For example, given:\n *\n *  \\code\n *  int f(int, int);\n *  int g(int x, int y) { return f(x, y); }\n *  int f(int a, int b) { return a + b; }\n *  int f(int, int);\n *  \\endcode\n *\n *  there are three declarations of the function \"f\", but only the\n *  second one is a definition. The clang_getCursorDefinition()\n *  function will take any cursor pointing to a declaration of \"f\"\n *  (the first or fourth lines of the example) or a cursor referenced\n *  that uses \"f\" (the call to \"f' inside \"g\") and will return a\n *  declaration cursor pointing to the definition (the second \"f\"\n *  declaration).\n *\n *  If given a cursor for which there is no corresponding definition,\n *  e.g., because there is no definition of that entity within this\n *  translation unit, returns a NULL cursor.\n */"} {:args ({:spelling "", :type "CXCursor"}), :ret {:spelling "unsigned int", :type "unsigned int"}, :function/args [:clang/CXCursor], :symbol "clang_isCursorDefinition", :name "clang_isCursorDefinition", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_isCursorDefinition, :doc "/**\n * Determine whether the declaration pointed to by this cursor\n * is also a definition of that entity.\n */"} {:args ({:spelling "", :type "CXCursor"}), :ret {:spelling "CXCursor", :type "CXCursor"}, :function/args [:clang/CXCursor], :symbol "clang_getCanonicalCursor", :name "clang_getCanonicalCursor", :function/ret :clang/CXCursor, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getCanonicalCursor, :doc "/**\n * Retrieve the canonical cursor corresponding to the given cursor.\n *\n * In the C family of languages, many kinds of entities can be declared several\n * times within a single translation unit. For example, a structure type can\n * be forward-declared (possibly multiple times) and later defined:\n *\n * \\code\n * struct X;\n * struct X;\n * struct X {\n *   int member;\n * };\n * \\endcode\n *\n * The declarations and the definition of \\c X are represented by three\n * different cursors, all of which are declarations of the same underlying\n * entity. One of these cursor is considered the \"canonical\" cursor, which\n * is effectively the representative for the underlying entity. One can\n * determine if two cursors are declarations of the same underlying entity by\n * comparing their canonical cursors.\n *\n * \\returns The canonical cursor for the entity referred to by the given cursor.\n */"} {:args ({:spelling "", :type "CXCursor"}), :ret {:spelling "int", :type "int"}, :function/args [:clang/CXCursor], :symbol "clang_Cursor_getObjCSelectorIndex", :name "clang_Cursor_getObjCSelectorIndex", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_Cursor_getObjCSelectorIndex, :doc "/**\n * If the cursor points to a selector identifier in an Objective-C\n * method or message expression, this returns the selector index.\n *\n * After getting a cursor with #clang_getCursor, this can be called to\n * determine if the location points to a selector identifier.\n *\n * \\returns The selector index if the cursor is an Objective-C method or message\n * expression and the cursor is pointing to a selector identifier, or -1\n * otherwise.\n */"} {:args ({:spelling "C", :type "CXCursor"}), :ret {:spelling "int", :type "int"}, :function/args [:clang/CXCursor], :symbol "clang_Cursor_isDynamicCall", :name "clang_Cursor_isDynamicCall", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_Cursor_isDynamicCall, :doc "/**\n * Given a cursor pointing to a C++ method call or an Objective-C\n * message, returns non-zero if the method/message is \"dynamic\", meaning:\n *\n * For a C++ method: the call is virtual.\n * For an Objective-C message: the receiver is an object instance, not 'super'\n * or a specific class.\n *\n * If the method/message is \"static\" or the cursor does not point to a\n * method/message, it will return zero.\n */"} {:args ({:spelling "C", :type "CXCursor"}), :ret {:spelling "CXType", :type "CXType"}, :function/args [:clang/CXCursor], :symbol "clang_Cursor_getReceiverType", :name "clang_Cursor_getReceiverType", :function/ret :clang/CXType, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_Cursor_getReceiverType, :doc "/**\n * Given a cursor pointing to an Objective-C message or property\n * reference, or C++ method call, returns the CXType of the receiver.\n */"} {:args ({:spelling "C", :type "CXCursor"} {:spelling "reserved", :type "unsigned int"}), :ret {:spelling "unsigned int", :type "unsigned int"}, :function/args [:clang/CXCursor :coffi.mem/int], :symbol "clang_Cursor_getObjCPropertyAttributes", :name "clang_Cursor_getObjCPropertyAttributes", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_Cursor_getObjCPropertyAttributes, :doc "/**\n * Given a cursor that represents a property declaration, return the\n * associated property attributes. The bits are formed from\n * \\c CXObjCPropertyAttrKind.\n *\n * \\param reserved Reserved for future use, pass 0.\n */"} {:args ({:spelling "C", :type "CXCursor"}), :ret {:spelling "CXString", :type "CXString"}, :function/args [:clang/CXCursor], :symbol "clang_Cursor_getObjCPropertyGetterName", :name "clang_Cursor_getObjCPropertyGetterName", :function/ret :clang/CXString, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_Cursor_getObjCPropertyGetterName, :doc "/**\n * Given a cursor that represents a property declaration, return the\n * name of the method that implements the getter.\n */"} {:args ({:spelling "C", :type "CXCursor"}), :ret {:spelling "CXString", :type "CXString"}, :function/args [:clang/CXCursor], :symbol "clang_Cursor_getObjCPropertySetterName", :name "clang_Cursor_getObjCPropertySetterName", :function/ret :clang/CXString, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_Cursor_getObjCPropertySetterName, :doc "/**\n * Given a cursor that represents a property declaration, return the\n * name of the method that implements the setter, if any.\n */"} {:args ({:spelling "C", :type "CXCursor"}), :ret {:spelling "unsigned int", :type "unsigned int"}, :function/args [:clang/CXCursor], :symbol "clang_Cursor_getObjCDeclQualifiers", :name "clang_Cursor_getObjCDeclQualifiers", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_Cursor_getObjCDeclQualifiers, :doc "/**\n * Given a cursor that represents an Objective-C method or parameter\n * declaration, return the associated Objective-C qualifiers for the return\n * type or the parameter respectively. The bits are formed from\n * CXObjCDeclQualifierKind.\n */"} {:args ({:spelling "C", :type "CXCursor"}), :ret {:spelling "unsigned int", :type "unsigned int"}, :function/args [:clang/CXCursor], :symbol "clang_Cursor_isObjCOptional", :name "clang_Cursor_isObjCOptional", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_Cursor_isObjCOptional, :doc "/**\n * Given a cursor that represents an Objective-C method or property\n * declaration, return non-zero if the declaration was affected by \"\\@optional\".\n * Returns zero if the cursor is not such a declaration or it is \"\\@required\".\n */"} {:args ({:spelling "C", :type "CXCursor"}), :ret {:spelling "unsigned int", :type "unsigned int"}, :function/args [:clang/CXCursor], :symbol "clang_Cursor_isVariadic", :name "clang_Cursor_isVariadic", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_Cursor_isVariadic, :doc "/**\n * Returns non-zero if the given cursor is a variadic function or method.\n */"} {:args ({:spelling "C", :type "CXCursor"} {:spelling "language", :type "CXString *"} {:spelling "definedIn", :type "CXString *"} {:spelling "isGenerated", :type "unsigned int *"}), :ret {:spelling "unsigned int", :type "unsigned int"}, :function/args [:clang/CXCursor [:coffi.mem/pointer :clang/CXString] [:coffi.mem/pointer :clang/CXString] [:coffi.mem/pointer :coffi.mem/int]], :symbol "clang_Cursor_isExternalSymbol", :name "clang_Cursor_isExternalSymbol", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_Cursor_isExternalSymbol, :doc "/**\n * Returns non-zero if the given cursor points to a symbol marked with\n * external_source_symbol attribute.\n *\n * \\param language If non-NULL, and the attribute is present, will be set to\n * the 'language' string from the attribute.\n *\n * \\param definedIn If non-NULL, and the attribute is present, will be set to\n * the 'definedIn' string from the attribute.\n *\n * \\param isGenerated If non-NULL, and the attribute is present, will be set to\n * non-zero if the 'generated_declaration' is set in the attribute.\n */"} {:args ({:spelling "C", :type "CXCursor"}), :ret {:spelling "CXSourceRange", :type "CXSourceRange"}, :function/args [:clang/CXCursor], :symbol "clang_Cursor_getCommentRange", :name "clang_Cursor_getCommentRange", :function/ret :clang/CXSourceRange, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_Cursor_getCommentRange, :doc "/**\n * Given a cursor that represents a declaration, return the associated\n * comment's source range.  The range may include multiple consecutive comments\n * with whitespace in between.\n */"} {:args ({:spelling "C", :type "CXCursor"}), :ret {:spelling "CXString", :type "CXString"}, :function/args [:clang/CXCursor], :symbol "clang_Cursor_getRawCommentText", :name "clang_Cursor_getRawCommentText", :function/ret :clang/CXString, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_Cursor_getRawCommentText, :doc "/**\n * Given a cursor that represents a declaration, return the associated\n * comment text, including comment markers.\n */"} {:args ({:spelling "C", :type "CXCursor"}), :ret {:spelling "CXString", :type "CXString"}, :function/args [:clang/CXCursor], :symbol "clang_Cursor_getBriefCommentText", :name "clang_Cursor_getBriefCommentText", :function/ret :clang/CXString, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_Cursor_getBriefCommentText, :doc "/**\n * Given a cursor that represents a documentable entity (e.g.,\n * declaration), return the associated \\paragraph; otherwise return the\n * first paragraph.\n */"} {:args ({:spelling "", :type "CXCursor"}), :ret {:spelling "CXString", :type "CXString"}, :function/args [:clang/CXCursor], :symbol "clang_Cursor_getMangling", :name "clang_Cursor_getMangling", :function/ret :clang/CXString, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_Cursor_getMangling, :doc "/**\n * Retrieve the CXString representing the mangled name of the cursor.\n */"} {:args ({:spelling "", :type "CXCursor"}), :ret {:spelling "CXStringSet *", :type "CXStringSet *"}, :function/args [:clang/CXCursor], :symbol "clang_Cursor_getCXXManglings", :name "clang_Cursor_getCXXManglings", :function/ret [:coffi.mem/pointer :clang/CXStringSet], :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_Cursor_getCXXManglings, :doc "/**\n * Retrieve the CXStrings representing the mangled symbols of the C++\n * constructor or destructor at the cursor.\n */"} {:args ({:spelling "", :type "CXCursor"}), :ret {:spelling "CXStringSet *", :type "CXStringSet *"}, :function/args [:clang/CXCursor], :symbol "clang_Cursor_getObjCManglings", :name "clang_Cursor_getObjCManglings", :function/ret [:coffi.mem/pointer :clang/CXStringSet], :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_Cursor_getObjCManglings, :doc "/**\n * Retrieve the CXStrings representing the mangled symbols of the ObjC\n * class interface or implementation at the cursor.\n */"} {:args ({:spelling "C", :type "CXCursor"}), :ret {:spelling "CXModule", :type "void *"}, :function/args [:clang/CXCursor], :symbol "clang_Cursor_getModule", :name "clang_Cursor_getModule", :function/ret :coffi.mem/pointer, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_Cursor_getModule, :doc "/**\n * Given a CXCursor_ModuleImportDecl cursor, return the associated module.\n */"} {:args ({:spelling "", :type "struct CXTranslationUnitImpl *"} {:spelling "", :type "void *"}), :ret {:spelling "CXModule", :type "void *"}, :function/args [[:coffi.mem/pointer :clang/CXTranslationUnitImpl] :coffi.mem/pointer], :symbol "clang_getModuleForFile", :name "clang_getModuleForFile", :function/ret :coffi.mem/pointer, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getModuleForFile, :doc "/**\n * Given a CXFile header file, return the module that contains it, if one\n * exists.\n */"} {:args ({:spelling "Module", :type "void *"}), :ret {:spelling "CXFile", :type "void *"}, :function/args [:coffi.mem/pointer], :symbol "clang_Module_getASTFile", :name "clang_Module_getASTFile", :function/ret :coffi.mem/pointer, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_Module_getASTFile, :doc "/**\n * \\param Module a module object.\n *\n * \\returns the module file where the provided module object came from.\n */"} {:args ({:spelling "Module", :type "void *"}), :ret {:spelling "CXModule", :type "void *"}, :function/args [:coffi.mem/pointer], :symbol "clang_Module_getParent", :name "clang_Module_getParent", :function/ret :coffi.mem/pointer, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_Module_getParent, :doc "/**\n * \\param Module a module object.\n *\n * \\returns the parent of a sub-module or NULL if the given module is top-level,\n * e.g. for 'std.vector' it will return the 'std' module.\n */"} {:args ({:spelling "Module", :type "void *"}), :ret {:spelling "CXString", :type "CXString"}, :function/args [:coffi.mem/pointer], :symbol "clang_Module_getName", :name "clang_Module_getName", :function/ret :clang/CXString, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_Module_getName, :doc "/**\n * \\param Module a module object.\n *\n * \\returns the name of the module, e.g. for the 'std.vector' sub-module it\n * will return \"vector\".\n */"} {:args ({:spelling "Module", :type "void *"}), :ret {:spelling "CXString", :type "CXString"}, :function/args [:coffi.mem/pointer], :symbol "clang_Module_getFullName", :name "clang_Module_getFullName", :function/ret :clang/CXString, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_Module_getFullName, :doc "/**\n * \\param Module a module object.\n *\n * \\returns the full name of the module, e.g. \"std.vector\".\n */"} {:args ({:spelling "Module", :type "void *"}), :ret {:spelling "int", :type "int"}, :function/args [:coffi.mem/pointer], :symbol "clang_Module_isSystem", :name "clang_Module_isSystem", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_Module_isSystem, :doc "/**\n * \\param Module a module object.\n *\n * \\returns non-zero if the module is a system one.\n */"} {:args ({:spelling "", :type "struct CXTranslationUnitImpl *"} {:spelling "Module", :type "void *"}), :ret {:spelling "unsigned int", :type "unsigned int"}, :function/args [[:coffi.mem/pointer :clang/CXTranslationUnitImpl] :coffi.mem/pointer], :symbol "clang_Module_getNumTopLevelHeaders", :name "clang_Module_getNumTopLevelHeaders", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_Module_getNumTopLevelHeaders, :doc "/**\n * \\param Module a module object.\n *\n * \\returns the number of top level headers associated with this module.\n */"} {:args ({:spelling "", :type "struct CXTranslationUnitImpl *"} {:spelling "Module", :type "void *"} {:spelling "Index", :type "unsigned int"}), :ret {:spelling "CXFile", :type "void *"}, :function/args [[:coffi.mem/pointer :clang/CXTranslationUnitImpl] :coffi.mem/pointer :coffi.mem/int], :symbol "clang_Module_getTopLevelHeader", :name "clang_Module_getTopLevelHeader", :function/ret :coffi.mem/pointer, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_Module_getTopLevelHeader, :doc "/**\n * \\param Module a module object.\n *\n * \\param Index top level header index (zero-based).\n *\n * \\returns the specified top level header associated with the module.\n */"} {:args ({:spelling "C", :type "CXCursor"}), :ret {:spelling "unsigned int", :type "unsigned int"}, :function/args [:clang/CXCursor], :symbol "clang_CXXConstructor_isConvertingConstructor", :name "clang_CXXConstructor_isConvertingConstructor", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_CXXConstructor_isConvertingConstructor, :doc "/**\n * Determine if a C++ constructor is a converting constructor.\n */"} {:args ({:spelling "C", :type "CXCursor"}), :ret {:spelling "unsigned int", :type "unsigned int"}, :function/args [:clang/CXCursor], :symbol "clang_CXXConstructor_isCopyConstructor", :name "clang_CXXConstructor_isCopyConstructor", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_CXXConstructor_isCopyConstructor, :doc "/**\n * Determine if a C++ constructor is a copy constructor.\n */"} {:args ({:spelling "C", :type "CXCursor"}), :ret {:spelling "unsigned int", :type "unsigned int"}, :function/args [:clang/CXCursor], :symbol "clang_CXXConstructor_isDefaultConstructor", :name "clang_CXXConstructor_isDefaultConstructor", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_CXXConstructor_isDefaultConstructor, :doc "/**\n * Determine if a C++ constructor is the default constructor.\n */"} {:args ({:spelling "C", :type "CXCursor"}), :ret {:spelling "unsigned int", :type "unsigned int"}, :function/args [:clang/CXCursor], :symbol "clang_CXXConstructor_isMoveConstructor", :name "clang_CXXConstructor_isMoveConstructor", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_CXXConstructor_isMoveConstructor, :doc "/**\n * Determine if a C++ constructor is a move constructor.\n */"} {:args ({:spelling "C", :type "CXCursor"}), :ret {:spelling "unsigned int", :type "unsigned int"}, :function/args [:clang/CXCursor], :symbol "clang_CXXField_isMutable", :name "clang_CXXField_isMutable", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_CXXField_isMutable, :doc "/**\n * Determine if a C++ field is declared 'mutable'.\n */"} {:args ({:spelling "C", :type "CXCursor"}), :ret {:spelling "unsigned int", :type "unsigned int"}, :function/args [:clang/CXCursor], :symbol "clang_CXXMethod_isDefaulted", :name "clang_CXXMethod_isDefaulted", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_CXXMethod_isDefaulted, :doc "/**\n * Determine if a C++ method is declared '= default'.\n */"} {:args ({:spelling "C", :type "CXCursor"}), :ret {:spelling "unsigned int", :type "unsigned int"}, :function/args [:clang/CXCursor], :symbol "clang_CXXMethod_isPureVirtual", :name "clang_CXXMethod_isPureVirtual", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_CXXMethod_isPureVirtual, :doc "/**\n * Determine if a C++ member function or member function template is\n * pure virtual.\n */"} {:args ({:spelling "C", :type "CXCursor"}), :ret {:spelling "unsigned int", :type "unsigned int"}, :function/args [:clang/CXCursor], :symbol "clang_CXXMethod_isStatic", :name "clang_CXXMethod_isStatic", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_CXXMethod_isStatic, :doc "/**\n * Determine if a C++ member function or member function template is\n * declared 'static'.\n */"} {:args ({:spelling "C", :type "CXCursor"}), :ret {:spelling "unsigned int", :type "unsigned int"}, :function/args [:clang/CXCursor], :symbol "clang_CXXMethod_isVirtual", :name "clang_CXXMethod_isVirtual", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_CXXMethod_isVirtual, :doc "/**\n * Determine if a C++ member function or member function template is\n * explicitly declared 'virtual' or if it overrides a virtual method from\n * one of the base classes.\n */"} {:args ({:spelling "C", :type "CXCursor"}), :ret {:spelling "unsigned int", :type "unsigned int"}, :function/args [:clang/CXCursor], :symbol "clang_CXXRecord_isAbstract", :name "clang_CXXRecord_isAbstract", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_CXXRecord_isAbstract, :doc "/**\n * Determine if a C++ record is abstract, i.e. whether a class or struct\n * has a pure virtual member function.\n */"} {:args ({:spelling "C", :type "CXCursor"}), :ret {:spelling "unsigned int", :type "unsigned int"}, :function/args [:clang/CXCursor], :symbol "clang_EnumDecl_isScoped", :name "clang_EnumDecl_isScoped", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_EnumDecl_isScoped, :doc "/**\n * Determine if an enum declaration refers to a scoped enum.\n */"} {:args ({:spelling "C", :type "CXCursor"}), :ret {:spelling "unsigned int", :type "unsigned int"}, :function/args [:clang/CXCursor], :symbol "clang_CXXMethod_isConst", :name "clang_CXXMethod_isConst", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_CXXMethod_isConst, :doc "/**\n * Determine if a C++ member function or member function template is\n * declared 'const'.\n */"} {:args ({:spelling "C", :type "CXCursor"}), :ret {:spelling "enum CXCursorKind", :type "enum CXCursorKind"}, :function/args [:clang/CXCursor], :symbol "clang_getTemplateCursorKind", :name "clang_getTemplateCursorKind", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getTemplateCursorKind, :doc "/**\n * Given a cursor that represents a template, determine\n * the cursor kind of the specializations would be generated by instantiating\n * the template.\n *\n * This routine can be used to determine what flavor of function template,\n * class template, or class template partial specialization is stored in the\n * cursor. For example, it can describe whether a class template cursor is\n * declared with \"struct\", \"class\" or \"union\".\n *\n * \\param C The cursor to query. This cursor should represent a template\n * declaration.\n *\n * \\returns The cursor kind of the specializations that would be generated\n * by instantiating the template \\p C. If \\p C is not a template, returns\n * \\c CXCursor_NoDeclFound.\n */"} {:args ({:spelling "C", :type "CXCursor"}), :ret {:spelling "CXCursor", :type "CXCursor"}, :function/args [:clang/CXCursor], :symbol "clang_getSpecializedCursorTemplate", :name "clang_getSpecializedCursorTemplate", :function/ret :clang/CXCursor, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getSpecializedCursorTemplate, :doc "/**\n * Given a cursor that may represent a specialization or instantiation\n * of a template, retrieve the cursor that represents the template that it\n * specializes or from which it was instantiated.\n *\n * This routine determines the template involved both for explicit\n * specializations of templates and for implicit instantiations of the template,\n * both of which are referred to as \"specializations\". For a class template\n * specialization (e.g., \\c std::vector<bool>), this routine will return\n * either the primary template (\\c std::vector) or, if the specialization was\n * instantiated from a class template partial specialization, the class template\n * partial specialization. For a class template partial specialization and a\n * function template specialization (including instantiations), this\n * this routine will return the specialized template.\n *\n * For members of a class template (e.g., member functions, member classes, or\n * static data members), returns the specialized or instantiated member.\n * Although not strictly \"templates\" in the C++ language, members of class\n * templates have the same notions of specializations and instantiations that\n * templates do, so this routine treats them similarly.\n *\n * \\param C A cursor that may be a specialization of a template or a member\n * of a template.\n *\n * \\returns If the given cursor is a specialization or instantiation of a\n * template or a member thereof, the template or member that it specializes or\n * from which it was instantiated. Otherwise, returns a NULL cursor.\n */"} {:args ({:spelling "C", :type "CXCursor"} {:spelling "NameFlags", :type "unsigned int"} {:spelling "PieceIndex", :type "unsigned int"}), :ret {:spelling "CXSourceRange", :type "CXSourceRange"}, :function/args [:clang/CXCursor :coffi.mem/int :coffi.mem/int], :symbol "clang_getCursorReferenceNameRange", :name "clang_getCursorReferenceNameRange", :function/ret :clang/CXSourceRange, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getCursorReferenceNameRange, :doc "/**\n * Given a cursor that references something else, return the source range\n * covering that reference.\n *\n * \\param C A cursor pointing to a member reference, a declaration reference, or\n * an operator call.\n * \\param NameFlags A bitset with three independent flags:\n * CXNameRange_WantQualifier, CXNameRange_WantTemplateArgs, and\n * CXNameRange_WantSinglePiece.\n * \\param PieceIndex For contiguous names or when passing the flag\n * CXNameRange_WantSinglePiece, only one piece with index 0 is\n * available. When the CXNameRange_WantSinglePiece flag is not passed for a\n * non-contiguous names, this index can be used to retrieve the individual\n * pieces of the name. See also CXNameRange_WantSinglePiece.\n *\n * \\returns The piece of the name pointed to by the given cursor. If there is no\n * name, or if the PieceIndex is out-of-range, a null-cursor will be returned.\n */"} {:args ({:spelling "TU", :type "struct CXTranslationUnitImpl *"} {:spelling "Location", :type "CXSourceLocation"}), :ret {:spelling "CXToken *", :type "CXToken *"}, :function/args [[:coffi.mem/pointer :clang/CXTranslationUnitImpl] :clang/CXSourceLocation], :symbol "clang_getToken", :name "clang_getToken", :function/ret [:coffi.mem/pointer :clang/CXToken], :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getToken, :doc "/**\n * Get the raw lexical token starting with the given location.\n *\n * \\param TU the translation unit whose text is being tokenized.\n *\n * \\param Location the source location with which the token starts.\n *\n * \\returns The token starting with the given location or NULL if no such token\n * exist. The returned pointer must be freed with clang_disposeTokens before the\n * translation unit is destroyed.\n */"} {:args ({:spelling "", :type "CXToken"}), :ret {:spelling "CXTokenKind", :type "enum CXTokenKind"}, :function/args [:clang/CXToken], :symbol "clang_getTokenKind", :name "clang_getTokenKind", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getTokenKind, :doc "/**\n * Determine the kind of the given token.\n */"} {:args ({:spelling "", :type "struct CXTranslationUnitImpl *"} {:spelling "", :type "CXToken"}), :ret {:spelling "CXString", :type "CXString"}, :function/args [[:coffi.mem/pointer :clang/CXTranslationUnitImpl] :clang/CXToken], :symbol "clang_getTokenSpelling", :name "clang_getTokenSpelling", :function/ret :clang/CXString, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getTokenSpelling, :doc "/**\n * Determine the spelling of the given token.\n *\n * The spelling of a token is the textual representation of that token, e.g.,\n * the text of an identifier or keyword.\n */"} {:args ({:spelling "", :type "struct CXTranslationUnitImpl *"} {:spelling "", :type "CXToken"}), :ret {:spelling "CXSourceLocation", :type "CXSourceLocation"}, :function/args [[:coffi.mem/pointer :clang/CXTranslationUnitImpl] :clang/CXToken], :symbol "clang_getTokenLocation", :name "clang_getTokenLocation", :function/ret :clang/CXSourceLocation, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getTokenLocation, :doc "/**\n * Retrieve the source location of the given token.\n */"} {:args ({:spelling "", :type "struct CXTranslationUnitImpl *"} {:spelling "", :type "CXToken"}), :ret {:spelling "CXSourceRange", :type "CXSourceRange"}, :function/args [[:coffi.mem/pointer :clang/CXTranslationUnitImpl] :clang/CXToken], :symbol "clang_getTokenExtent", :name "clang_getTokenExtent", :function/ret :clang/CXSourceRange, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getTokenExtent, :doc "/**\n * Retrieve a source range that covers the given token.\n */"} {:args ({:spelling "TU", :type "struct CXTranslationUnitImpl *"} {:spelling "Range", :type "CXSourceRange"} {:spelling "Tokens", :type "CXToken **"} {:spelling "NumTokens", :type "unsigned int *"}), :ret {:spelling "void", :type "void"}, :function/args [[:coffi.mem/pointer :clang/CXTranslationUnitImpl] :clang/CXSourceRange [:coffi.mem/pointer [:coffi.mem/pointer :clang/CXToken]] [:coffi.mem/pointer :coffi.mem/int]], :symbol "clang_tokenize", :name "clang_tokenize", :function/ret :coffi.mem/void, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_tokenize, :doc "/**\n * Tokenize the source code described by the given range into raw\n * lexical tokens.\n *\n * \\param TU the translation unit whose text is being tokenized.\n *\n * \\param Range the source range in which text should be tokenized. All of the\n * tokens produced by tokenization will fall within this source range,\n *\n * \\param Tokens this pointer will be set to point to the array of tokens\n * that occur within the given source range. The returned pointer must be\n * freed with clang_disposeTokens() before the translation unit is destroyed.\n *\n * \\param NumTokens will be set to the number of tokens in the \\c *Tokens\n * array.\n *\n */"} {:args ({:spelling "TU", :type "struct CXTranslationUnitImpl *"} {:spelling "Tokens", :type "CXToken *"} {:spelling "NumTokens", :type "unsigned int"} {:spelling "Cursors", :type "CXCursor *"}), :ret {:spelling "void", :type "void"}, :function/args [[:coffi.mem/pointer :clang/CXTranslationUnitImpl] [:coffi.mem/pointer :clang/CXToken] :coffi.mem/int [:coffi.mem/pointer :clang/CXCursor]], :symbol "clang_annotateTokens", :name "clang_annotateTokens", :function/ret :coffi.mem/void, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_annotateTokens, :doc "/**\n * Annotate the given set of tokens by providing cursors for each token\n * that can be mapped to a specific entity within the abstract syntax tree.\n *\n * This token-annotation routine is equivalent to invoking\n * clang_getCursor() for the source locations of each of the\n * tokens. The cursors provided are filtered, so that only those\n * cursors that have a direct correspondence to the token are\n * accepted. For example, given a function call \\c f(x),\n * clang_getCursor() would provide the following cursors:\n *\n *   * when the cursor is over the 'f', a DeclRefExpr cursor referring to 'f'.\n *   * when the cursor is over the '(' or the ')', a CallExpr referring to 'f'.\n *   * when the cursor is over the 'x', a DeclRefExpr cursor referring to 'x'.\n *\n * Only the first and last of these cursors will occur within the\n * annotate, since the tokens \"f\" and \"x' directly refer to a function\n * and a variable, respectively, but the parentheses are just a small\n * part of the full syntax of the function call expression, which is\n * not provided as an annotation.\n *\n * \\param TU the translation unit that owns the given tokens.\n *\n * \\param Tokens the set of tokens to annotate.\n *\n * \\param NumTokens the number of tokens in \\p Tokens.\n *\n * \\param Cursors an array of \\p NumTokens cursors, whose contents will be\n * replaced with the cursors corresponding to each token.\n */"} {:args ({:spelling "TU", :type "struct CXTranslationUnitImpl *"} {:spelling "Tokens", :type "CXToken *"} {:spelling "NumTokens", :type "unsigned int"}), :ret {:spelling "void", :type "void"}, :function/args [[:coffi.mem/pointer :clang/CXTranslationUnitImpl] [:coffi.mem/pointer :clang/CXToken] :coffi.mem/int], :symbol "clang_disposeTokens", :name "clang_disposeTokens", :function/ret :coffi.mem/void, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_disposeTokens, :doc "/**\n * Free the given set of tokens.\n */"} {:args ({:spelling "Kind", :type "enum CXCursorKind"}), :ret {:spelling "CXString", :type "CXString"}, :function/args [:coffi.mem/int], :symbol "clang_getCursorKindSpelling", :name "clang_getCursorKindSpelling", :function/ret :clang/CXString, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getCursorKindSpelling, :doc "/**\n * \\defgroup CINDEX_DEBUG Debugging facilities\n *\n * These routines are used for testing and debugging, only, and should not\n * be relied upon.\n *\n * @{\n */"} {:args ({:spelling "", :type "CXCursor"} {:spelling "startBuf", :type "const char **"} {:spelling "endBuf", :type "const char **"} {:spelling "startLine", :type "unsigned int *"} {:spelling "startColumn", :type "unsigned int *"} {:spelling "endLine", :type "unsigned int *"} {:spelling "endColumn", :type "unsigned int *"}), :ret {:spelling "void", :type "void"}, :function/args [:clang/CXCursor [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]] [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]] [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :coffi.mem/int]], :symbol "clang_getDefinitionSpellingAndExtent", :name "clang_getDefinitionSpellingAndExtent", :function/ret :coffi.mem/void, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getDefinitionSpellingAndExtent, :doc nil} {:args (), :ret {:spelling "void", :type "void"}, :function/args [], :symbol "clang_enableStackTraces", :name "clang_enableStackTraces", :function/ret :coffi.mem/void, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_enableStackTraces, :doc nil} {:args ({:spelling "fn", :type "void (*)(void *)"} {:spelling "user_data", :type "void *"} {:spelling "stack_size", :type "unsigned int"}), :ret {:spelling "void", :type "void"}, :function/args [[:coffi.ffi/fn [:coffi.mem/pointer] :coffi.mem/void] :coffi.mem/pointer :coffi.mem/int], :symbol "clang_executeOnThread", :name "clang_executeOnThread", :function/ret :coffi.mem/void, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_executeOnThread, :doc nil} {:args ({:spelling "completion_string", :type "void *"} {:spelling "chunk_number", :type "unsigned int"}), :ret {:spelling "enum CXCompletionChunkKind", :type "enum CXCompletionChunkKind"}, :function/args [:coffi.mem/pointer :coffi.mem/int], :symbol "clang_getCompletionChunkKind", :name "clang_getCompletionChunkKind", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getCompletionChunkKind, :doc "/**\n * Determine the kind of a particular chunk within a completion string.\n *\n * \\param completion_string the completion string to query.\n *\n * \\param chunk_number the 0-based index of the chunk in the completion string.\n *\n * \\returns the kind of the chunk at the index \\c chunk_number.\n */"} {:args ({:spelling "completion_string", :type "void *"} {:spelling "chunk_number", :type "unsigned int"}), :ret {:spelling "CXString", :type "CXString"}, :function/args [:coffi.mem/pointer :coffi.mem/int], :symbol "clang_getCompletionChunkText", :name "clang_getCompletionChunkText", :function/ret :clang/CXString, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getCompletionChunkText, :doc "/**\n * Retrieve the text associated with a particular chunk within a\n * completion string.\n *\n * \\param completion_string the completion string to query.\n *\n * \\param chunk_number the 0-based index of the chunk in the completion string.\n *\n * \\returns the text associated with the chunk at index \\c chunk_number.\n */"} {:args ({:spelling "completion_string", :type "void *"} {:spelling "chunk_number", :type "unsigned int"}), :ret {:spelling "CXCompletionString", :type "void *"}, :function/args [:coffi.mem/pointer :coffi.mem/int], :symbol "clang_getCompletionChunkCompletionString", :name "clang_getCompletionChunkCompletionString", :function/ret :coffi.mem/pointer, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getCompletionChunkCompletionString, :doc "/**\n * Retrieve the completion string associated with a particular chunk\n * within a completion string.\n *\n * \\param completion_string the completion string to query.\n *\n * \\param chunk_number the 0-based index of the chunk in the completion string.\n *\n * \\returns the completion string associated with the chunk at index\n * \\c chunk_number.\n */"} {:args ({:spelling "completion_string", :type "void *"}), :ret {:spelling "unsigned int", :type "unsigned int"}, :function/args [:coffi.mem/pointer], :symbol "clang_getNumCompletionChunks", :name "clang_getNumCompletionChunks", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getNumCompletionChunks, :doc "/**\n * Retrieve the number of chunks in the given code-completion string.\n */"} {:args ({:spelling "completion_string", :type "void *"}), :ret {:spelling "unsigned int", :type "unsigned int"}, :function/args [:coffi.mem/pointer], :symbol "clang_getCompletionPriority", :name "clang_getCompletionPriority", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getCompletionPriority, :doc "/**\n * Determine the priority of this code completion.\n *\n * The priority of a code completion indicates how likely it is that this\n * particular completion is the completion that the user will select. The\n * priority is selected by various internal heuristics.\n *\n * \\param completion_string The completion string to query.\n *\n * \\returns The priority of this completion string. Smaller values indicate\n * higher-priority (more likely) completions.\n */"} {:args ({:spelling "completion_string", :type "void *"}), :ret {:spelling "enum CXAvailabilityKind", :type "enum CXAvailabilityKind"}, :function/args [:coffi.mem/pointer], :symbol "clang_getCompletionAvailability", :name "clang_getCompletionAvailability", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getCompletionAvailability, :doc "/**\n * Determine the availability of the entity that this code-completion\n * string refers to.\n *\n * \\param completion_string The completion string to query.\n *\n * \\returns The availability of the completion string.\n */"} {:args ({:spelling "completion_string", :type "void *"}), :ret {:spelling "unsigned int", :type "unsigned int"}, :function/args [:coffi.mem/pointer], :symbol "clang_getCompletionNumAnnotations", :name "clang_getCompletionNumAnnotations", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getCompletionNumAnnotations, :doc "/**\n * Retrieve the number of annotations associated with the given\n * completion string.\n *\n * \\param completion_string the completion string to query.\n *\n * \\returns the number of annotations associated with the given completion\n * string.\n */"} {:args ({:spelling "completion_string", :type "void *"} {:spelling "annotation_number", :type "unsigned int"}), :ret {:spelling "CXString", :type "CXString"}, :function/args [:coffi.mem/pointer :coffi.mem/int], :symbol "clang_getCompletionAnnotation", :name "clang_getCompletionAnnotation", :function/ret :clang/CXString, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getCompletionAnnotation, :doc "/**\n * Retrieve the annotation associated with the given completion string.\n *\n * \\param completion_string the completion string to query.\n *\n * \\param annotation_number the 0-based index of the annotation of the\n * completion string.\n *\n * \\returns annotation string associated with the completion at index\n * \\c annotation_number, or a NULL string if that annotation is not available.\n */"} {:args ({:spelling "completion_string", :type "void *"} {:spelling "kind", :type "enum CXCursorKind *"}), :ret {:spelling "CXString", :type "CXString"}, :function/args [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/int]], :symbol "clang_getCompletionParent", :name "clang_getCompletionParent", :function/ret :clang/CXString, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getCompletionParent, :doc "/**\n * Retrieve the parent context of the given completion string.\n *\n * The parent context of a completion string is the semantic parent of\n * the declaration (if any) that the code completion represents. For example,\n * a code completion for an Objective-C method would have the method's class\n * or protocol as its context.\n *\n * \\param completion_string The code completion string whose parent is\n * being queried.\n *\n * \\param kind DEPRECATED: always set to CXCursor_NotImplemented if non-NULL.\n *\n * \\returns The name of the completion parent, e.g., \"NSObject\" if\n * the completion string represents a method in the NSObject class.\n */"} {:args ({:spelling "completion_string", :type "void *"}), :ret {:spelling "CXString", :type "CXString"}, :function/args [:coffi.mem/pointer], :symbol "clang_getCompletionBriefComment", :name "clang_getCompletionBriefComment", :function/ret :clang/CXString, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getCompletionBriefComment, :doc "/**\n * Retrieve the brief documentation comment attached to the declaration\n * that corresponds to the given completion string.\n */"} {:args ({:spelling "cursor", :type "CXCursor"}), :ret {:spelling "CXCompletionString", :type "void *"}, :function/args [:clang/CXCursor], :symbol "clang_getCursorCompletionString", :name "clang_getCursorCompletionString", :function/ret :coffi.mem/pointer, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getCursorCompletionString, :doc "/**\n * Retrieve a completion string for an arbitrary declaration or macro\n * definition cursor.\n *\n * \\param cursor The cursor to query.\n *\n * \\returns A non-context-sensitive completion string for declaration and macro\n * definition cursors, or NULL for other kinds of cursors.\n */"} {:args ({:spelling "results", :type "CXCodeCompleteResults *"} {:spelling "completion_index", :type "unsigned int"}), :ret {:spelling "unsigned int", :type "unsigned int"}, :function/args [[:coffi.mem/pointer :clang/CXCodeCompleteResults] :coffi.mem/int], :symbol "clang_getCompletionNumFixIts", :name "clang_getCompletionNumFixIts", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getCompletionNumFixIts, :doc "/**\n * Retrieve the number of fix-its for the given completion index.\n *\n * Calling this makes sense only if CXCodeComplete_IncludeCompletionsWithFixIts\n * option was set.\n *\n * \\param results The structure keeping all completion results\n *\n * \\param completion_index The index of the completion\n *\n * \\return The number of fix-its which must be applied before the completion at\n * completion_index can be applied\n */"} {:args ({:spelling "results", :type "CXCodeCompleteResults *"} {:spelling "completion_index", :type "unsigned int"} {:spelling "fixit_index", :type "unsigned int"} {:spelling "replacement_range", :type "CXSourceRange *"}), :ret {:spelling "CXString", :type "CXString"}, :function/args [[:coffi.mem/pointer :clang/CXCodeCompleteResults] :coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :clang/CXSourceRange]], :symbol "clang_getCompletionFixIt", :name "clang_getCompletionFixIt", :function/ret :clang/CXString, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getCompletionFixIt, :doc "/**\n * Fix-its that *must* be applied before inserting the text for the\n * corresponding completion.\n *\n * By default, clang_codeCompleteAt() only returns completions with empty\n * fix-its. Extra completions with non-empty fix-its should be explicitly\n * requested by setting CXCodeComplete_IncludeCompletionsWithFixIts.\n *\n * For the clients to be able to compute position of the cursor after applying\n * fix-its, the following conditions are guaranteed to hold for\n * replacement_range of the stored fix-its:\n *  - Ranges in the fix-its are guaranteed to never contain the completion\n *  point (or identifier under completion point, if any) inside them, except\n *  at the start or at the end of the range.\n *  - If a fix-it range starts or ends with completion point (or starts or\n *  ends after the identifier under completion point), it will contain at\n *  least one character. It allows to unambiguously recompute completion\n *  point after applying the fix-it.\n *\n * The intuition is that provided fix-its change code around the identifier we\n * complete, but are not allowed to touch the identifier itself or the\n * completion point. One example of completions with corrections are the ones\n * replacing '.' with '->' and vice versa:\n *\n * std::unique_ptr<std::vector<int>> vec_ptr;\n * In 'vec_ptr.^', one of the completions is 'push_back', it requires\n * replacing '.' with '->'.\n * In 'vec_ptr->^', one of the completions is 'release', it requires\n * replacing '->' with '.'.\n *\n * \\param results The structure keeping all completion results\n *\n * \\param completion_index The index of the completion\n *\n * \\param fixit_index The index of the fix-it for the completion at\n * completion_index\n *\n * \\param replacement_range The fix-it range that must be replaced before the\n * completion at completion_index can be applied\n *\n * \\returns The fix-it string that must replace the code at replacement_range\n * before the completion at completion_index can be applied\n */"} {:args (), :ret {:spelling "unsigned int", :type "unsigned int"}, :function/args [], :symbol "clang_defaultCodeCompleteOptions", :name "clang_defaultCodeCompleteOptions", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_defaultCodeCompleteOptions, :doc "/**\n * Returns a default set of code-completion options that can be\n * passed to\\c clang_codeCompleteAt().\n */"} {:args ({:spelling "TU", :type "struct CXTranslationUnitImpl *"} {:spelling "complete_filename", :type "const char *"} {:spelling "complete_line", :type "unsigned int"} {:spelling "complete_column", :type "unsigned int"} {:spelling "unsaved_files", :type "struct CXUnsavedFile *"} {:spelling "num_unsaved_files", :type "unsigned int"} {:spelling "options", :type "unsigned int"}), :ret {:spelling "CXCodeCompleteResults *", :type "CXCodeCompleteResults *"}, :function/args [[:coffi.mem/pointer :clang/CXTranslationUnitImpl] [:coffi.mem/pointer :coffi.mem/char] :coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :clang/CXUnsavedFile] :coffi.mem/int :coffi.mem/int], :symbol "clang_codeCompleteAt", :name "clang_codeCompleteAt", :function/ret [:coffi.mem/pointer :clang/CXCodeCompleteResults], :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_codeCompleteAt, :doc "/**\n * Perform code completion at a given location in a translation unit.\n *\n * This function performs code completion at a particular file, line, and\n * column within source code, providing results that suggest potential\n * code snippets based on the context of the completion. The basic model\n * for code completion is that Clang will parse a complete source file,\n * performing syntax checking up to the location where code-completion has\n * been requested. At that point, a special code-completion token is passed\n * to the parser, which recognizes this token and determines, based on the\n * current location in the C/Objective-C/C++ grammar and the state of\n * semantic analysis, what completions to provide. These completions are\n * returned via a new \\c CXCodeCompleteResults structure.\n *\n * Code completion itself is meant to be triggered by the client when the\n * user types punctuation characters or whitespace, at which point the\n * code-completion location will coincide with the cursor. For example, if \\c p\n * is a pointer, code-completion might be triggered after the \"-\" and then\n * after the \">\" in \\c p->. When the code-completion location is after the \">\",\n * the completion results will provide, e.g., the members of the struct that\n * \"p\" points to. The client is responsible for placing the cursor at the\n * beginning of the token currently being typed, then filtering the results\n * based on the contents of the token. For example, when code-completing for\n * the expression \\c p->get, the client should provide the location just after\n * the \">\" (e.g., pointing at the \"g\") to this code-completion hook. Then, the\n * client can filter the results based on the current token text (\"get\"), only\n * showing those results that start with \"get\". The intent of this interface\n * is to separate the relatively high-latency acquisition of code-completion\n * results from the filtering of results on a per-character basis, which must\n * have a lower latency.\n *\n * \\param TU The translation unit in which code-completion should\n * occur. The source files for this translation unit need not be\n * completely up-to-date (and the contents of those source files may\n * be overridden via \\p unsaved_files). Cursors referring into the\n * translation unit may be invalidated by this invocation.\n *\n * \\param complete_filename The name of the source file where code\n * completion should be performed. This filename may be any file\n * included in the translation unit.\n *\n * \\param complete_line The line at which code-completion should occur.\n *\n * \\param complete_column The column at which code-completion should occur.\n * Note that the column should point just after the syntactic construct that\n * initiated code completion, and not in the middle of a lexical token.\n *\n * \\param unsaved_files the Files that have not yet been saved to disk\n * but may be required for parsing or code completion, including the\n * contents of those files.  The contents and name of these files (as\n * specified by CXUnsavedFile) are copied when necessary, so the\n * client only needs to guarantee their validity until the call to\n * this function returns.\n *\n * \\param num_unsaved_files The number of unsaved file entries in \\p\n * unsaved_files.\n *\n * \\param options Extra options that control the behavior of code\n * completion, expressed as a bitwise OR of the enumerators of the\n * CXCodeComplete_Flags enumeration. The\n * \\c clang_defaultCodeCompleteOptions() function returns a default set\n * of code-completion options.\n *\n * \\returns If successful, a new \\c CXCodeCompleteResults structure\n * containing code-completion results, which should eventually be\n * freed with \\c clang_disposeCodeCompleteResults(). If code\n * completion fails, returns NULL.\n */"} {:args ({:spelling "Results", :type "CXCompletionResult *"} {:spelling "NumResults", :type "unsigned int"}), :ret {:spelling "void", :type "void"}, :function/args [[:coffi.mem/pointer :clang/CXCompletionResult] :coffi.mem/int], :symbol "clang_sortCodeCompletionResults", :name "clang_sortCodeCompletionResults", :function/ret :coffi.mem/void, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_sortCodeCompletionResults, :doc "/**\n * Sort the code-completion results in case-insensitive alphabetical\n * order.\n *\n * \\param Results The set of results to sort.\n * \\param NumResults The number of results in \\p Results.\n */"} {:args ({:spelling "Results", :type "CXCodeCompleteResults *"}), :ret {:spelling "void", :type "void"}, :function/args [[:coffi.mem/pointer :clang/CXCodeCompleteResults]], :symbol "clang_disposeCodeCompleteResults", :name "clang_disposeCodeCompleteResults", :function/ret :coffi.mem/void, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_disposeCodeCompleteResults, :doc "/**\n * Free the given set of code-completion results.\n */"} {:args ({:spelling "Results", :type "CXCodeCompleteResults *"}), :ret {:spelling "unsigned int", :type "unsigned int"}, :function/args [[:coffi.mem/pointer :clang/CXCodeCompleteResults]], :symbol "clang_codeCompleteGetNumDiagnostics", :name "clang_codeCompleteGetNumDiagnostics", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_codeCompleteGetNumDiagnostics, :doc "/**\n * Determine the number of diagnostics produced prior to the\n * location where code completion was performed.\n */"} {:args ({:spelling "Results", :type "CXCodeCompleteResults *"} {:spelling "Index", :type "unsigned int"}), :ret {:spelling "CXDiagnostic", :type "void *"}, :function/args [[:coffi.mem/pointer :clang/CXCodeCompleteResults] :coffi.mem/int], :symbol "clang_codeCompleteGetDiagnostic", :name "clang_codeCompleteGetDiagnostic", :function/ret :coffi.mem/pointer, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_codeCompleteGetDiagnostic, :doc "/**\n * Retrieve a diagnostic associated with the given code completion.\n *\n * \\param Results the code completion results to query.\n * \\param Index the zero-based diagnostic number to retrieve.\n *\n * \\returns the requested diagnostic. This diagnostic must be freed\n * via a call to \\c clang_disposeDiagnostic().\n */"} {:args ({:spelling "Results", :type "CXCodeCompleteResults *"}), :ret {:spelling "unsigned long long", :type "unsigned long long"}, :function/args [[:coffi.mem/pointer :clang/CXCodeCompleteResults]], :symbol "clang_codeCompleteGetContexts", :name "clang_codeCompleteGetContexts", :function/ret :coffi.mem/long, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_codeCompleteGetContexts, :doc "/**\n * Determines what completions are appropriate for the context\n * the given code completion.\n *\n * \\param Results the code completion results to query\n *\n * \\returns the kinds of completions that are appropriate for use\n * along with the given code completion results.\n */"} {:args ({:spelling "Results", :type "CXCodeCompleteResults *"} {:spelling "IsIncomplete", :type "unsigned int *"}), :ret {:spelling "enum CXCursorKind", :type "enum CXCursorKind"}, :function/args [[:coffi.mem/pointer :clang/CXCodeCompleteResults] [:coffi.mem/pointer :coffi.mem/int]], :symbol "clang_codeCompleteGetContainerKind", :name "clang_codeCompleteGetContainerKind", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_codeCompleteGetContainerKind, :doc "/**\n * Returns the cursor kind for the container for the current code\n * completion context. The container is only guaranteed to be set for\n * contexts where a container exists (i.e. member accesses or Objective-C\n * message sends); if there is not a container, this function will return\n * CXCursor_InvalidCode.\n *\n * \\param Results the code completion results to query\n *\n * \\param IsIncomplete on return, this value will be false if Clang has complete\n * information about the container. If Clang does not have complete\n * information, this value will be true.\n *\n * \\returns the container kind, or CXCursor_InvalidCode if there is not a\n * container\n */"} {:args ({:spelling "Results", :type "CXCodeCompleteResults *"}), :ret {:spelling "CXString", :type "CXString"}, :function/args [[:coffi.mem/pointer :clang/CXCodeCompleteResults]], :symbol "clang_codeCompleteGetContainerUSR", :name "clang_codeCompleteGetContainerUSR", :function/ret :clang/CXString, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_codeCompleteGetContainerUSR, :doc "/**\n * Returns the USR for the container for the current code completion\n * context. If there is not a container for the current context, this\n * function will return the empty string.\n *\n * \\param Results the code completion results to query\n *\n * \\returns the USR for the container\n */"} {:args ({:spelling "Results", :type "CXCodeCompleteResults *"}), :ret {:spelling "CXString", :type "CXString"}, :function/args [[:coffi.mem/pointer :clang/CXCodeCompleteResults]], :symbol "clang_codeCompleteGetObjCSelector", :name "clang_codeCompleteGetObjCSelector", :function/ret :clang/CXString, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_codeCompleteGetObjCSelector, :doc "/**\n * Returns the currently-entered selector for an Objective-C message\n * send, formatted like \"initWithFoo:bar:\". Only guaranteed to return a\n * non-empty string for CXCompletionContext_ObjCInstanceMessage and\n * CXCompletionContext_ObjCClassMessage.\n *\n * \\param Results the code completion results to query\n *\n * \\returns the selector (or partial selector) that has been entered thus far\n * for an Objective-C message send.\n */"} {:args (), :ret {:spelling "CXString", :type "CXString"}, :function/args [], :symbol "clang_getClangVersion", :name "clang_getClangVersion", :function/ret :clang/CXString, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getClangVersion, :doc "/**\n * Return a version string, suitable for showing to a user, but not\n *        intended to be parsed (the format is not guaranteed to be stable).\n */"} {:args ({:spelling "isEnabled", :type "unsigned int"}), :ret {:spelling "void", :type "void"}, :function/args [:coffi.mem/int], :symbol "clang_toggleCrashRecovery", :name "clang_toggleCrashRecovery", :function/ret :coffi.mem/void, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_toggleCrashRecovery, :doc "/**\n * Enable/disable crash recovery.\n *\n * \\param isEnabled Flag to indicate if crash recovery is enabled.  A non-zero\n *        value enables crash recovery, while 0 disables it.\n */"} {:args ({:spelling "tu", :type "struct CXTranslationUnitImpl *"} {:spelling "visitor", :type "void (*)(void *, CXSourceLocation *, unsigned int, void *)"} {:spelling "client_data", :type "void *"}), :ret {:spelling "void", :type "void"}, :function/args [[:coffi.mem/pointer :clang/CXTranslationUnitImpl] [:coffi.ffi/fn [:coffi.mem/pointer [:coffi.mem/pointer :clang/CXSourceLocation] :coffi.mem/int :coffi.mem/pointer] :coffi.mem/void] :coffi.mem/pointer], :symbol "clang_getInclusions", :name "clang_getInclusions", :function/ret :coffi.mem/void, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getInclusions, :doc "/**\n * Visit the set of preprocessor inclusions in a translation unit.\n *   The visitor function is called with the provided data for every included\n *   file.  This does not include headers included by the PCH file (unless one\n *   is inspecting the inclusions in the PCH file itself).\n */"} {:args ({:spelling "C", :type "CXCursor"}), :ret {:spelling "CXEvalResult", :type "void *"}, :function/args [:clang/CXCursor], :symbol "clang_Cursor_Evaluate", :name "clang_Cursor_Evaluate", :function/ret :coffi.mem/pointer, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_Cursor_Evaluate, :doc "/**\n * If cursor is a statement declaration tries to evaluate the\n * statement and if its variable, tries to evaluate its initializer,\n * into its corresponding type.\n * If it's an expression, tries to evaluate the expression.\n */"} {:args ({:spelling "E", :type "void *"}), :ret {:spelling "CXEvalResultKind", :type "CXEvalResultKind"}, :function/args [:coffi.mem/pointer], :symbol "clang_EvalResult_getKind", :name "clang_EvalResult_getKind", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_EvalResult_getKind, :doc "/**\n * Returns the kind of the evaluated result.\n */"} {:args ({:spelling "E", :type "void *"}), :ret {:spelling "int", :type "int"}, :function/args [:coffi.mem/pointer], :symbol "clang_EvalResult_getAsInt", :name "clang_EvalResult_getAsInt", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_EvalResult_getAsInt, :doc "/**\n * Returns the evaluation result as integer if the\n * kind is Int.\n */"} {:args ({:spelling "E", :type "void *"}), :ret {:spelling "long long", :type "long long"}, :function/args [:coffi.mem/pointer], :symbol "clang_EvalResult_getAsLongLong", :name "clang_EvalResult_getAsLongLong", :function/ret :coffi.mem/long, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_EvalResult_getAsLongLong, :doc "/**\n * Returns the evaluation result as a long long integer if the\n * kind is Int. This prevents overflows that may happen if the result is\n * returned with clang_EvalResult_getAsInt.\n */"} {:args ({:spelling "E", :type "void *"}), :ret {:spelling "unsigned int", :type "unsigned int"}, :function/args [:coffi.mem/pointer], :symbol "clang_EvalResult_isUnsignedInt", :name "clang_EvalResult_isUnsignedInt", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_EvalResult_isUnsignedInt, :doc "/**\n * Returns a non-zero value if the kind is Int and the evaluation\n * result resulted in an unsigned integer.\n */"} {:args ({:spelling "E", :type "void *"}), :ret {:spelling "unsigned long long", :type "unsigned long long"}, :function/args [:coffi.mem/pointer], :symbol "clang_EvalResult_getAsUnsigned", :name "clang_EvalResult_getAsUnsigned", :function/ret :coffi.mem/long, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_EvalResult_getAsUnsigned, :doc "/**\n * Returns the evaluation result as an unsigned integer if\n * the kind is Int and clang_EvalResult_isUnsignedInt is non-zero.\n */"} {:args ({:spelling "E", :type "void *"}), :ret {:spelling "double", :type "double"}, :function/args [:coffi.mem/pointer], :symbol "clang_EvalResult_getAsDouble", :name "clang_EvalResult_getAsDouble", :function/ret :coffi.mem/double, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_EvalResult_getAsDouble, :doc "/**\n * Returns the evaluation result as double if the\n * kind is double.\n */"} {:args ({:spelling "E", :type "void *"}), :ret {:spelling "const char *", :type "const char *"}, :function/args [:coffi.mem/pointer], :symbol "clang_EvalResult_getAsStr", :name "clang_EvalResult_getAsStr", :function/ret [:coffi.mem/pointer :coffi.mem/char], :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_EvalResult_getAsStr, :doc "/**\n * Returns the evaluation result as a constant string if the\n * kind is other than Int or float. User must not free this pointer,\n * instead call clang_EvalResult_dispose on the CXEvalResult returned\n * by clang_Cursor_Evaluate.\n */"} {:args ({:spelling "E", :type "void *"}), :ret {:spelling "void", :type "void"}, :function/args [:coffi.mem/pointer], :symbol "clang_EvalResult_dispose", :name "clang_EvalResult_dispose", :function/ret :coffi.mem/void, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_EvalResult_dispose, :doc "/**\n * Disposes the created Eval memory.\n */"} {:args ({:spelling "path", :type "const char *"}), :ret {:spelling "CXRemapping", :type "void *"}, :function/args [[:coffi.mem/pointer :coffi.mem/char]], :symbol "clang_getRemappings", :name "clang_getRemappings", :function/ret :coffi.mem/pointer, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getRemappings, :doc "/**\n * Retrieve a remapping.\n *\n * \\param path the path that contains metadata about remappings.\n *\n * \\returns the requested remapping. This remapping must be freed\n * via a call to \\c clang_remap_dispose(). Can return NULL if an error occurred.\n */"} {:args ({:spelling "filePaths", :type "const char **"} {:spelling "numFiles", :type "unsigned int"}), :ret {:spelling "CXRemapping", :type "void *"}, :function/args [[:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]] :coffi.mem/int], :symbol "clang_getRemappingsFromFileList", :name "clang_getRemappingsFromFileList", :function/ret :coffi.mem/pointer, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_getRemappingsFromFileList, :doc "/**\n * Retrieve a remapping.\n *\n * \\param filePaths pointer to an array of file paths containing remapping info.\n *\n * \\param numFiles number of file paths.\n *\n * \\returns the requested remapping. This remapping must be freed\n * via a call to \\c clang_remap_dispose(). Can return NULL if an error occurred.\n */"} {:args ({:spelling "", :type "void *"}), :ret {:spelling "unsigned int", :type "unsigned int"}, :function/args [:coffi.mem/pointer], :symbol "clang_remap_getNumFiles", :name "clang_remap_getNumFiles", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_remap_getNumFiles, :doc "/**\n * Determine the number of remappings.\n */"} {:args ({:spelling "", :type "void *"} {:spelling "index", :type "unsigned int"} {:spelling "original", :type "CXString *"} {:spelling "transformed", :type "CXString *"}), :ret {:spelling "void", :type "void"}, :function/args [:coffi.mem/pointer :coffi.mem/int [:coffi.mem/pointer :clang/CXString] [:coffi.mem/pointer :clang/CXString]], :symbol "clang_remap_getFilenames", :name "clang_remap_getFilenames", :function/ret :coffi.mem/void, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_remap_getFilenames, :doc "/**\n * Get the original and the associated filename from the remapping.\n *\n * \\param original If non-NULL, will be set to the original filename.\n *\n * \\param transformed If non-NULL, will be set to the filename that the original\n * is associated with.\n */"} {:args ({:spelling "", :type "void *"}), :ret {:spelling "void", :type "void"}, :function/args [:coffi.mem/pointer], :symbol "clang_remap_dispose", :name "clang_remap_dispose", :function/ret :coffi.mem/void, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_remap_dispose, :doc "/**\n * Dispose the remapping.\n */"} {:args ({:spelling "cursor", :type "CXCursor"} {:spelling "file", :type "void *"} {:spelling "visitor", :type "struct CXCursorAndRangeVisitor"}), :ret {:spelling "CXResult", :type "CXResult"}, :function/args [:clang/CXCursor :coffi.mem/pointer :clang/CXCursorAndRangeVisitor], :symbol "clang_findReferencesInFile", :name "clang_findReferencesInFile", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_findReferencesInFile, :doc "/**\n * Find references of a declaration in a specific file.\n *\n * \\param cursor pointing to a declaration or a reference of one.\n *\n * \\param file to search for references.\n *\n * \\param visitor callback that will receive pairs of CXCursor/CXSourceRange for\n * each reference found.\n * The CXSourceRange will point inside the file; if the reference is inside\n * a macro (and not a macro argument) the CXSourceRange will be invalid.\n *\n * \\returns one of the CXResult enumerators.\n */"} {:args ({:spelling "TU", :type "struct CXTranslationUnitImpl *"} {:spelling "file", :type "void *"} {:spelling "visitor", :type "struct CXCursorAndRangeVisitor"}), :ret {:spelling "CXResult", :type "CXResult"}, :function/args [[:coffi.mem/pointer :clang/CXTranslationUnitImpl] :coffi.mem/pointer :clang/CXCursorAndRangeVisitor], :symbol "clang_findIncludesInFile", :name "clang_findIncludesInFile", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_findIncludesInFile, :doc "/**\n * Find #import/#include directives in a specific file.\n *\n * \\param TU translation unit containing the file to query.\n *\n * \\param file to search for #import/#include directives.\n *\n * \\param visitor callback that will receive pairs of CXCursor/CXSourceRange for\n * each directive found.\n *\n * \\returns one of the CXResult enumerators.\n */"} {:args ({:spelling "", :type "CXCursor"} {:spelling "", :type "void *"} {:spelling "", :type "enum CXVisitorResult (^)(CXCursor, CXSourceRange)"}), :ret {:spelling "CXResult", :type "CXResult"}, :function/args [:clang/CXCursor :coffi.mem/pointer [:coffi.mem/pointer]], :symbol "clang_findReferencesInFileWithBlock", :name "clang_findReferencesInFileWithBlock", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_findReferencesInFileWithBlock, :doc nil} {:args ({:spelling "", :type "struct CXTranslationUnitImpl *"} {:spelling "", :type "void *"} {:spelling "", :type "enum CXVisitorResult (^)(CXCursor, CXSourceRange)"}), :ret {:spelling "CXResult", :type "CXResult"}, :function/args [[:coffi.mem/pointer :clang/CXTranslationUnitImpl] :coffi.mem/pointer [:coffi.mem/pointer]], :symbol "clang_findIncludesInFileWithBlock", :name "clang_findIncludesInFileWithBlock", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_findIncludesInFileWithBlock, :doc nil} {:args ({:spelling "", :type "CXIdxEntityKind"}), :ret {:spelling "int", :type "int"}, :function/args [:coffi.mem/int], :symbol "clang_index_isEntityObjCContainerKind", :name "clang_index_isEntityObjCContainerKind", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_index_isEntityObjCContainerKind, :doc nil} {:args ({:spelling "", :type "const CXIdxDeclInfo *"}), :ret {:spelling "const CXIdxObjCContainerDeclInfo *", :type "const CXIdxObjCContainerDeclInfo *"}, :function/args [[:coffi.mem/pointer :clang/CXIdxDeclInfo]], :symbol "clang_index_getObjCContainerDeclInfo", :name "clang_index_getObjCContainerDeclInfo", :function/ret [:coffi.mem/pointer :clang/CXIdxObjCContainerDeclInfo], :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_index_getObjCContainerDeclInfo, :doc nil} {:args ({:spelling "", :type "const CXIdxDeclInfo *"}), :ret {:spelling "const CXIdxObjCInterfaceDeclInfo *", :type "const CXIdxObjCInterfaceDeclInfo *"}, :function/args [[:coffi.mem/pointer :clang/CXIdxDeclInfo]], :symbol "clang_index_getObjCInterfaceDeclInfo", :name "clang_index_getObjCInterfaceDeclInfo", :function/ret [:coffi.mem/pointer :clang/CXIdxObjCInterfaceDeclInfo], :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_index_getObjCInterfaceDeclInfo, :doc nil} {:args ({:spelling "", :type "const CXIdxDeclInfo *"}), :ret {:spelling "const CXIdxObjCCategoryDeclInfo *", :type "const CXIdxObjCCategoryDeclInfo *"}, :function/args [[:coffi.mem/pointer :clang/CXIdxDeclInfo]], :symbol "clang_index_getObjCCategoryDeclInfo", :name "clang_index_getObjCCategoryDeclInfo", :function/ret [:coffi.mem/pointer :clang/CXIdxObjCCategoryDeclInfo], :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_index_getObjCCategoryDeclInfo, :doc nil} {:args ({:spelling "", :type "const CXIdxDeclInfo *"}), :ret {:spelling "const CXIdxObjCProtocolRefListInfo *", :type "const CXIdxObjCProtocolRefListInfo *"}, :function/args [[:coffi.mem/pointer :clang/CXIdxDeclInfo]], :symbol "clang_index_getObjCProtocolRefListInfo", :name "clang_index_getObjCProtocolRefListInfo", :function/ret [:coffi.mem/pointer :clang/CXIdxObjCProtocolRefListInfo], :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_index_getObjCProtocolRefListInfo, :doc nil} {:args ({:spelling "", :type "const CXIdxDeclInfo *"}), :ret {:spelling "const CXIdxObjCPropertyDeclInfo *", :type "const CXIdxObjCPropertyDeclInfo *"}, :function/args [[:coffi.mem/pointer :clang/CXIdxDeclInfo]], :symbol "clang_index_getObjCPropertyDeclInfo", :name "clang_index_getObjCPropertyDeclInfo", :function/ret [:coffi.mem/pointer :clang/CXIdxObjCPropertyDeclInfo], :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_index_getObjCPropertyDeclInfo, :doc nil} {:args ({:spelling "", :type "const CXIdxAttrInfo *"}), :ret {:spelling "const CXIdxIBOutletCollectionAttrInfo *", :type "const CXIdxIBOutletCollectionAttrInfo *"}, :function/args [[:coffi.mem/pointer :clang/CXIdxAttrInfo]], :symbol "clang_index_getIBOutletCollectionAttrInfo", :name "clang_index_getIBOutletCollectionAttrInfo", :function/ret [:coffi.mem/pointer :clang/CXIdxIBOutletCollectionAttrInfo], :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_index_getIBOutletCollectionAttrInfo, :doc nil} {:args ({:spelling "", :type "const CXIdxDeclInfo *"}), :ret {:spelling "const CXIdxCXXClassDeclInfo *", :type "const CXIdxCXXClassDeclInfo *"}, :function/args [[:coffi.mem/pointer :clang/CXIdxDeclInfo]], :symbol "clang_index_getCXXClassDeclInfo", :name "clang_index_getCXXClassDeclInfo", :function/ret [:coffi.mem/pointer :clang/CXIdxCXXClassDeclInfo], :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_index_getCXXClassDeclInfo, :doc nil} {:args ({:spelling "", :type "const CXIdxContainerInfo *"}), :ret {:spelling "CXIdxClientContainer", :type "void *"}, :function/args [[:coffi.mem/pointer :clang/CXIdxContainerInfo]], :symbol "clang_index_getClientContainer", :name "clang_index_getClientContainer", :function/ret :coffi.mem/pointer, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_index_getClientContainer, :doc "/**\n * For retrieving a custom CXIdxClientContainer attached to a\n * container.\n */"} {:args ({:spelling "", :type "const CXIdxContainerInfo *"} {:spelling "", :type "void *"}), :ret {:spelling "void", :type "void"}, :function/args [[:coffi.mem/pointer :clang/CXIdxContainerInfo] :coffi.mem/pointer], :symbol "clang_index_setClientContainer", :name "clang_index_setClientContainer", :function/ret :coffi.mem/void, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_index_setClientContainer, :doc "/**\n * For setting a custom CXIdxClientContainer attached to a\n * container.\n */"} {:args ({:spelling "", :type "const CXIdxEntityInfo *"}), :ret {:spelling "CXIdxClientEntity", :type "void *"}, :function/args [[:coffi.mem/pointer :clang/CXIdxEntityInfo]], :symbol "clang_index_getClientEntity", :name "clang_index_getClientEntity", :function/ret :coffi.mem/pointer, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_index_getClientEntity, :doc "/**\n * For retrieving a custom CXIdxClientEntity attached to an entity.\n */"} {:args ({:spelling "", :type "const CXIdxEntityInfo *"} {:spelling "", :type "void *"}), :ret {:spelling "void", :type "void"}, :function/args [[:coffi.mem/pointer :clang/CXIdxEntityInfo] :coffi.mem/pointer], :symbol "clang_index_setClientEntity", :name "clang_index_setClientEntity", :function/ret :coffi.mem/void, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_index_setClientEntity, :doc "/**\n * For setting a custom CXIdxClientEntity attached to an entity.\n */"} {:args ({:spelling "CIdx", :type "void *"}), :ret {:spelling "CXIndexAction", :type "void *"}, :function/args [:coffi.mem/pointer], :symbol "clang_IndexAction_create", :name "clang_IndexAction_create", :function/ret :coffi.mem/pointer, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_IndexAction_create, :doc "/**\n * An indexing action/session, to be applied to one or multiple\n * translation units.\n *\n * \\param CIdx The index object with which the index action will be associated.\n */"} {:args ({:spelling "", :type "void *"}), :ret {:spelling "void", :type "void"}, :function/args [:coffi.mem/pointer], :symbol "clang_IndexAction_dispose", :name "clang_IndexAction_dispose", :function/ret :coffi.mem/void, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_IndexAction_dispose, :doc "/**\n * Destroy the given index action.\n *\n * The index action must not be destroyed until all of the translation units\n * created within that index action have been destroyed.\n */"} {:args ({:spelling "", :type "void *"} {:spelling "client_data", :type "void *"} {:spelling "index_callbacks", :type "IndexerCallbacks *"} {:spelling "index_callbacks_size", :type "unsigned int"} {:spelling "index_options", :type "unsigned int"} {:spelling "source_filename", :type "const char *"} {:spelling "command_line_args", :type "const char *const *"} {:spelling "num_command_line_args", :type "int"} {:spelling "unsaved_files", :type "struct CXUnsavedFile *"} {:spelling "num_unsaved_files", :type "unsigned int"} {:spelling "out_TU", :type "struct CXTranslationUnitImpl **"} {:spelling "TU_options", :type "unsigned int"}), :ret {:spelling "int", :type "int"}, :function/args [:coffi.mem/pointer :coffi.mem/pointer [:coffi.mem/pointer :clang/IndexerCallbacks] :coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]] :coffi.mem/int [:coffi.mem/pointer :clang/CXUnsavedFile] :coffi.mem/int [:coffi.mem/pointer [:coffi.mem/pointer :clang/CXTranslationUnitImpl]] :coffi.mem/int], :symbol "clang_indexSourceFile", :name "clang_indexSourceFile", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_indexSourceFile, :doc "/**\n * Index the given source file and the translation unit corresponding\n * to that file via callbacks implemented through #IndexerCallbacks.\n *\n * \\param client_data pointer data supplied by the client, which will\n * be passed to the invoked callbacks.\n *\n * \\param index_callbacks Pointer to indexing callbacks that the client\n * implements.\n *\n * \\param index_callbacks_size Size of #IndexerCallbacks structure that gets\n * passed in index_callbacks.\n *\n * \\param index_options A bitmask of options that affects how indexing is\n * performed. This should be a bitwise OR of the CXIndexOpt_XXX flags.\n *\n * \\param[out] out_TU pointer to store a \\c CXTranslationUnit that can be\n * reused after indexing is finished. Set to \\c NULL if you do not require it.\n *\n * \\returns 0 on success or if there were errors from which the compiler could\n * recover.  If there is a failure from which there is no recovery, returns\n * a non-zero \\c CXErrorCode.\n *\n * The rest of the parameters are the same as #clang_parseTranslationUnit.\n */"} {:args ({:spelling "", :type "void *"} {:spelling "client_data", :type "void *"} {:spelling "index_callbacks", :type "IndexerCallbacks *"} {:spelling "index_callbacks_size", :type "unsigned int"} {:spelling "index_options", :type "unsigned int"} {:spelling "source_filename", :type "const char *"} {:spelling "command_line_args", :type "const char *const *"} {:spelling "num_command_line_args", :type "int"} {:spelling "unsaved_files", :type "struct CXUnsavedFile *"} {:spelling "num_unsaved_files", :type "unsigned int"} {:spelling "out_TU", :type "struct CXTranslationUnitImpl **"} {:spelling "TU_options", :type "unsigned int"}), :ret {:spelling "int", :type "int"}, :function/args [:coffi.mem/pointer :coffi.mem/pointer [:coffi.mem/pointer :clang/IndexerCallbacks] :coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :coffi.mem/char] [:coffi.mem/pointer [:coffi.mem/pointer :coffi.mem/char]] :coffi.mem/int [:coffi.mem/pointer :clang/CXUnsavedFile] :coffi.mem/int [:coffi.mem/pointer [:coffi.mem/pointer :clang/CXTranslationUnitImpl]] :coffi.mem/int], :symbol "clang_indexSourceFileFullArgv", :name "clang_indexSourceFileFullArgv", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_indexSourceFileFullArgv, :doc "/**\n * Same as clang_indexSourceFile but requires a full command line\n * for \\c command_line_args including argv[0]. This is useful if the standard\n * library paths are relative to the binary.\n */"} {:args ({:spelling "", :type "void *"} {:spelling "client_data", :type "void *"} {:spelling "index_callbacks", :type "IndexerCallbacks *"} {:spelling "index_callbacks_size", :type "unsigned int"} {:spelling "index_options", :type "unsigned int"} {:spelling "", :type "struct CXTranslationUnitImpl *"}), :ret {:spelling "int", :type "int"}, :function/args [:coffi.mem/pointer :coffi.mem/pointer [:coffi.mem/pointer :clang/IndexerCallbacks] :coffi.mem/int :coffi.mem/int [:coffi.mem/pointer :clang/CXTranslationUnitImpl]], :symbol "clang_indexTranslationUnit", :name "clang_indexTranslationUnit", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_indexTranslationUnit, :doc "/**\n * Index the given translation unit via callbacks implemented through\n * #IndexerCallbacks.\n *\n * The order of callback invocations is not guaranteed to be the same as\n * when indexing a source file. The high level order will be:\n *\n *   -Preprocessor callbacks invocations\n *   -Declaration/reference callbacks invocations\n *   -Diagnostic callback invocations\n *\n * The parameters are the same as #clang_indexSourceFile.\n *\n * \\returns If there is a failure from which there is no recovery, returns\n * non-zero, otherwise returns 0.\n */"} {:args ({:spelling "loc", :type "CXIdxLoc"} {:spelling "indexFile", :type "void **"} {:spelling "file", :type "void **"} {:spelling "line", :type "unsigned int *"} {:spelling "column", :type "unsigned int *"} {:spelling "offset", :type "unsigned int *"}), :ret {:spelling "void", :type "void"}, :function/args [:clang/CXIdxLoc [:coffi.mem/pointer :coffi.mem/pointer] [:coffi.mem/pointer :coffi.mem/pointer] [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :coffi.mem/int] [:coffi.mem/pointer :coffi.mem/int]], :symbol "clang_indexLoc_getFileLocation", :name "clang_indexLoc_getFileLocation", :function/ret :coffi.mem/void, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_indexLoc_getFileLocation, :doc "/**\n * Retrieve the CXIdxFile, file, line, column, and offset represented by\n * the given CXIdxLoc.\n *\n * If the location refers into a macro expansion, retrieves the\n * location of the macro expansion and if it refers into a macro argument\n * retrieves the location of the argument.\n */"} {:args ({:spelling "loc", :type "CXIdxLoc"}), :ret {:spelling "CXSourceLocation", :type "CXSourceLocation"}, :function/args [:clang/CXIdxLoc], :symbol "clang_indexLoc_getCXSourceLocation", :name "clang_indexLoc_getCXSourceLocation", :function/ret :clang/CXSourceLocation, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_indexLoc_getCXSourceLocation, :doc "/**\n * Retrieve the CXSourceLocation represented by the given CXIdxLoc.\n */"} {:args ({:spelling "T", :type "CXType"} {:spelling "visitor", :type "enum CXVisitorResult (*)(CXCursor, void *)"} {:spelling "client_data", :type "void *"}), :ret {:spelling "unsigned int", :type "unsigned int"}, :function/args [:clang/CXType [:coffi.ffi/fn [:clang/CXCursor :coffi.mem/pointer] :coffi.mem/int] :coffi.mem/pointer], :symbol "clang_Type_visitFields", :name "clang_Type_visitFields", :function/ret :coffi.mem/int, :type :function, :linkage LinkageKind.EXTERNAL, :id :clang_Type_visitFields, :doc "/**\n * Visit the fields of a particular type.\n *\n * This function visits all the direct fields of the given cursor,\n * invoking the given \\p visitor function with the cursors of each\n * visited field. The traversal may be ended prematurely, if\n * the visitor returns \\c CXFieldVisit_Break.\n *\n * \\param T the record type whose field may be visited.\n *\n * \\param visitor the visitor function that will be invoked for each\n * field of \\p T.\n *\n * \\param client_data pointer data supplied by the client, which will\n * be passed to the visitor each time it is invoked.\n *\n * \\returns a non-zero value if the traversal was terminated\n * prematurely by the visitor returning \\c CXFieldVisit_Break.\n */"}), :structs ({:id :clang/CXToken, :size-in-bytes 24, :fields ({:name "int_data", :datatype [:coffi.mem/array :coffi.mem/int 4], :n-elems 4, :calculated-offset 0} {:name "ptr_data", :datatype :coffi.mem/pointer, :n-elems 1, :calculated-offset 128})} {:id :clang/CXCursorAndRangeVisitor, :size-in-bytes 16, :fields ({:name "context", :datatype :coffi.mem/pointer, :n-elems 1, :calculated-offset 0} {:name "visit", :datatype [:coffi.ffi/fn [:coffi.mem/pointer :clang/CXCursor :clang/CXSourceRange] :coffi.mem/int], :n-elems 1, :calculated-offset 64})} {:id :clang/CXUnsavedFile, :size-in-bytes 24, :fields ({:name "Filename", :datatype [:coffi.mem/pointer :coffi.mem/char], :n-elems 1, :calculated-offset 0} {:name "Contents", :datatype [:coffi.mem/pointer :coffi.mem/char], :n-elems 1, :calculated-offset 64} {:name "Length", :datatype :coffi.mem/long, :n-elems 1, :calculated-offset 128})} {:id :clang/CXFileUniqueID, :size-in-bytes 24, :fields ({:name "data", :datatype [:coffi.mem/array :coffi.mem/long 3], :n-elems 3, :calculated-offset 0})} {:id :clang/CXIdxObjCPropertyDeclInfo, :size-in-bytes 24, :fields ({:name "declInfo", :datatype [:coffi.mem/pointer :clang/CXIdxDeclInfo], :n-elems 1, :calculated-offset 0} {:name "getter", :datatype [:coffi.mem/pointer :clang/CXIdxEntityInfo], :n-elems 1, :calculated-offset 64} {:name "setter", :datatype [:coffi.mem/pointer :clang/CXIdxEntityInfo], :n-elems 1, :calculated-offset 128})} {:id :clang/CXIdxObjCInterfaceDeclInfo, :size-in-bytes 24, :fields ({:name "containerInfo", :datatype [:coffi.mem/pointer :clang/CXIdxObjCContainerDeclInfo], :n-elems 1, :calculated-offset 0} {:name "superInfo", :datatype [:coffi.mem/pointer :clang/CXIdxBaseClassInfo], :n-elems 1, :calculated-offset 64} {:name "protocols", :datatype [:coffi.mem/pointer :clang/CXIdxObjCProtocolRefListInfo], :n-elems 1, :calculated-offset 128})} {:id :clang/CXIdxObjCContainerDeclInfo, :size-in-bytes 16, :fields ({:name "declInfo", :datatype [:coffi.mem/pointer :clang/CXIdxDeclInfo], :n-elems 1, :calculated-offset 0} {:name "kind", :datatype :coffi.mem/int, :n-elems 1, :calculated-offset 64})} {:id :clang/CXVersion, :size-in-bytes 12, :fields ({:name "Major", :datatype :coffi.mem/int, :n-elems 1, :calculated-offset 0} {:name "Minor", :datatype :coffi.mem/int, :n-elems 1, :calculated-offset 32} {:name "Subminor", :datatype :coffi.mem/int, :n-elems 1, :calculated-offset 64})} {:id :clang/CXSourceRangeList, :size-in-bytes 16, :fields ({:name "count", :datatype :coffi.mem/int, :n-elems 1, :calculated-offset 0} {:name "ranges", :datatype [:coffi.mem/pointer :clang/CXSourceRange], :n-elems 1, :calculated-offset 64})} {:id :clang/CXTUResourceUsage, :size-in-bytes 24, :fields ({:name "data", :datatype :coffi.mem/pointer, :n-elems 1, :calculated-offset 0} {:name "numEntries", :datatype :coffi.mem/int, :n-elems 1, :calculated-offset 64} {:name "entries", :datatype [:coffi.mem/pointer :clang/CXTUResourceUsageEntry], :n-elems 1, :calculated-offset 128})} {:id :clang/CXSourceRange, :size-in-bytes 24, :fields ({:name "ptr_data", :datatype [:coffi.mem/array :coffi.mem/pointer 2], :n-elems 2, :calculated-offset 0} {:name "begin_int_data", :datatype :coffi.mem/int, :n-elems 1, :calculated-offset 128} {:name "end_int_data", :datatype :coffi.mem/int, :n-elems 1, :calculated-offset 160})} {:id :clang/CXString, :size-in-bytes 16, :fields ({:name "data", :datatype :coffi.mem/pointer, :n-elems 1, :calculated-offset 0} {:name "private_flags", :datatype :coffi.mem/int, :n-elems 1, :calculated-offset 64})} {:id :clang/CXPlatformAvailability, :size-in-bytes 72, :fields ({:name "Platform", :datatype :clang/CXString, :n-elems 1, :calculated-offset 0} {:name "Introduced", :datatype :clang/CXVersion, :n-elems 1, :calculated-offset 128} {:name "Deprecated", :datatype :clang/CXVersion, :n-elems 1, :calculated-offset 224} {:name "Obsoleted", :datatype :clang/CXVersion, :n-elems 1, :calculated-offset 320} {:name "Unavailable", :datatype :coffi.mem/int, :n-elems 1, :calculated-offset 416} {:name "Message", :datatype :clang/CXString, :n-elems 1, :calculated-offset 448})} {:id :clang/CXIdxObjCProtocolRefListInfo, :size-in-bytes 16, :fields ({:name "protocols", :datatype [:coffi.mem/pointer [:coffi.mem/pointer :clang/CXIdxObjCProtocolRefInfo]], :n-elems 1, :calculated-offset 0} {:name "numProtocols", :datatype :coffi.mem/int, :n-elems 1, :calculated-offset 64})} {:id :clang/CXStringSet, :size-in-bytes 16, :fields ({:name "Strings", :datatype [:coffi.mem/pointer :clang/CXString], :n-elems 1, :calculated-offset 0} {:name "Count", :datatype :coffi.mem/int, :n-elems 1, :calculated-offset 64})} {:id :clang/CXTUResourceUsageEntry, :size-in-bytes 16, :fields ({:name "kind", :datatype :coffi.mem/int, :n-elems 1, :calculated-offset 0} {:name "amount", :datatype :coffi.mem/long, :n-elems 1, :calculated-offset 64})} {:id :clang/CXIdxLoc, :size-in-bytes 24, :fields ({:name "ptr_data", :datatype [:coffi.mem/array :coffi.mem/pointer 2], :n-elems 2, :calculated-offset 0} {:name "int_data", :datatype :coffi.mem/int, :n-elems 1, :calculated-offset 128})} {:id :clang/CXIdxImportedASTFileInfo, :size-in-bytes 48, :fields ({:name "file", :datatype :coffi.mem/pointer, :n-elems 1, :calculated-offset 0} {:name "module", :datatype :coffi.mem/pointer, :n-elems 1, :calculated-offset 64} {:name "loc", :datatype :clang/CXIdxLoc, :n-elems 1, :calculated-offset 128} {:name "isImplicit", :datatype :coffi.mem/int, :n-elems 1, :calculated-offset 320})} {:id :clang/CXType, :size-in-bytes 24, :fields ({:name "kind", :datatype :coffi.mem/int, :n-elems 1, :calculated-offset 0} {:name "data", :datatype [:coffi.mem/array :coffi.mem/pointer 2], :n-elems 2, :calculated-offset 64})} {:id :clang/CXCodeCompleteResults, :size-in-bytes 16, :fields ({:name "Results", :datatype [:coffi.mem/pointer :clang/CXCompletionResult], :n-elems 1, :calculated-offset 0} {:name "NumResults", :datatype :coffi.mem/int, :n-elems 1, :calculated-offset 64})} {:id :clang/CXCursor, :size-in-bytes 32, :fields ({:name "kind", :datatype :coffi.mem/int, :n-elems 1, :calculated-offset 0} {:name "xdata", :datatype :coffi.mem/int, :n-elems 1, :calculated-offset 32} {:name "data", :datatype [:coffi.mem/array :coffi.mem/pointer 3], :n-elems 3, :calculated-offset 64})} {:id :clang/CXIdxEntityInfo, :size-in-bytes 80, :fields ({:name "kind", :datatype :coffi.mem/int, :n-elems 1, :calculated-offset 0} {:name "templateKind", :datatype :coffi.mem/int, :n-elems 1, :calculated-offset 32} {:name "lang", :datatype :coffi.mem/int, :n-elems 1, :calculated-offset 64} {:name "name", :datatype [:coffi.mem/pointer :coffi.mem/char], :n-elems 1, :calculated-offset 128} {:name "USR", :datatype [:coffi.mem/pointer :coffi.mem/char], :n-elems 1, :calculated-offset 192} {:name "cursor", :datatype :clang/CXCursor, :n-elems 1, :calculated-offset 256} {:name "attributes", :datatype [:coffi.mem/pointer [:coffi.mem/pointer :clang/CXIdxAttrInfo]], :n-elems 1, :calculated-offset 512} {:name "numAttributes", :datatype :coffi.mem/int, :n-elems 1, :calculated-offset 576})} {:id :clang/CXIdxContainerInfo, :size-in-bytes 32, :fields ({:name "cursor", :datatype :clang/CXCursor, :n-elems 1, :calculated-offset 0})} {:id :clang/CXIdxObjCCategoryDeclInfo, :size-in-bytes 80, :fields ({:name "containerInfo", :datatype [:coffi.mem/pointer :clang/CXIdxObjCContainerDeclInfo], :n-elems 1, :calculated-offset 0} {:name "objcClass", :datatype [:coffi.mem/pointer :clang/CXIdxEntityInfo], :n-elems 1, :calculated-offset 64} {:name "classCursor", :datatype :clang/CXCursor, :n-elems 1, :calculated-offset 128} {:name "classLoc", :datatype :clang/CXIdxLoc, :n-elems 1, :calculated-offset 384} {:name "protocols", :datatype [:coffi.mem/pointer :clang/CXIdxObjCProtocolRefListInfo], :n-elems 1, :calculated-offset 576})} {:id :clang/CXIdxDeclInfo, :size-in-bytes 128, :fields ({:name "entityInfo", :datatype [:coffi.mem/pointer :clang/CXIdxEntityInfo], :n-elems 1, :calculated-offset 0} {:name "cursor", :datatype :clang/CXCursor, :n-elems 1, :calculated-offset 64} {:name "loc", :datatype :clang/CXIdxLoc, :n-elems 1, :calculated-offset 320} {:name "semanticContainer", :datatype [:coffi.mem/pointer :clang/CXIdxContainerInfo], :n-elems 1, :calculated-offset 512} {:name "lexicalContainer", :datatype [:coffi.mem/pointer :clang/CXIdxContainerInfo], :n-elems 1, :calculated-offset 576} {:name "isRedeclaration", :datatype :coffi.mem/int, :n-elems 1, :calculated-offset 640} {:name "isDefinition", :datatype :coffi.mem/int, :n-elems 1, :calculated-offset 672} {:name "isContainer", :datatype :coffi.mem/int, :n-elems 1, :calculated-offset 704} {:name "declAsContainer", :datatype [:coffi.mem/pointer :clang/CXIdxContainerInfo], :n-elems 1, :calculated-offset 768} {:name "isImplicit", :datatype :coffi.mem/int, :n-elems 1, :calculated-offset 832} {:name "attributes", :datatype [:coffi.mem/pointer [:coffi.mem/pointer :clang/CXIdxAttrInfo]], :n-elems 1, :calculated-offset 896} {:name "numAttributes", :datatype :coffi.mem/int, :n-elems 1, :calculated-offset 960} {:name "flags", :datatype :coffi.mem/int, :n-elems 1, :calculated-offset 992})} {:id :clang/CXIdxEntityRefInfo, :size-in-bytes 96, :fields ({:name "kind", :datatype :coffi.mem/int, :n-elems 1, :calculated-offset 0} {:name "cursor", :datatype :clang/CXCursor, :n-elems 1, :calculated-offset 64} {:name "loc", :datatype :clang/CXIdxLoc, :n-elems 1, :calculated-offset 320} {:name "referencedEntity", :datatype [:coffi.mem/pointer :clang/CXIdxEntityInfo], :n-elems 1, :calculated-offset 512} {:name "parentEntity", :datatype [:coffi.mem/pointer :clang/CXIdxEntityInfo], :n-elems 1, :calculated-offset 576} {:name "container", :datatype [:coffi.mem/pointer :clang/CXIdxContainerInfo], :n-elems 1, :calculated-offset 640} {:name "role", :datatype :coffi.mem/int, :n-elems 1, :calculated-offset 704})} {:id :clang/CXIdxIBOutletCollectionAttrInfo, :size-in-bytes 72, :fields ({:name "attrInfo", :datatype [:coffi.mem/pointer :clang/CXIdxAttrInfo], :n-elems 1, :calculated-offset 0} {:name "objcClass", :datatype [:coffi.mem/pointer :clang/CXIdxEntityInfo], :n-elems 1, :calculated-offset 64} {:name "classCursor", :datatype :clang/CXCursor, :n-elems 1, :calculated-offset 128} {:name "classLoc", :datatype :clang/CXIdxLoc, :n-elems 1, :calculated-offset 384})} {:id :clang/CXIdxAttrInfo, :size-in-bytes 64, :fields ({:name "kind", :datatype :coffi.mem/int, :n-elems 1, :calculated-offset 0} {:name "cursor", :datatype :clang/CXCursor, :n-elems 1, :calculated-offset 64} {:name "loc", :datatype :clang/CXIdxLoc, :n-elems 1, :calculated-offset 320})} {:id :clang/CXIdxBaseClassInfo, :size-in-bytes 64, :fields ({:name "base", :datatype [:coffi.mem/pointer :clang/CXIdxEntityInfo], :n-elems 1, :calculated-offset 0} {:name "cursor", :datatype :clang/CXCursor, :n-elems 1, :calculated-offset 64} {:name "loc", :datatype :clang/CXIdxLoc, :n-elems 1, :calculated-offset 320})} {:id :clang/CXIdxObjCProtocolRefInfo, :size-in-bytes 64, :fields ({:name "protocol", :datatype [:coffi.mem/pointer :clang/CXIdxEntityInfo], :n-elems 1, :calculated-offset 0} {:name "cursor", :datatype :clang/CXCursor, :n-elems 1, :calculated-offset 64} {:name "loc", :datatype :clang/CXIdxLoc, :n-elems 1, :calculated-offset 320})} {:id :clang/CXIdxIncludedFileInfo, :size-in-bytes 56, :fields ({:name "hashLoc", :datatype :clang/CXIdxLoc, :n-elems 1, :calculated-offset 0} {:name "filename", :datatype [:coffi.mem/pointer :coffi.mem/char], :n-elems 1, :calculated-offset 192} {:name "file", :datatype :coffi.mem/pointer, :n-elems 1, :calculated-offset 256} {:name "isImport", :datatype :coffi.mem/int, :n-elems 1, :calculated-offset 320} {:name "isAngled", :datatype :coffi.mem/int, :n-elems 1, :calculated-offset 352} {:name "isModuleImport", :datatype :coffi.mem/int, :n-elems 1, :calculated-offset 384})} {:id :clang/CXIdxCXXClassDeclInfo, :size-in-bytes 24, :fields ({:name "declInfo", :datatype [:coffi.mem/pointer :clang/CXIdxDeclInfo], :n-elems 1, :calculated-offset 0} {:name "bases", :datatype [:coffi.mem/pointer [:coffi.mem/pointer :clang/CXIdxBaseClassInfo]], :n-elems 1, :calculated-offset 64} {:name "numBases", :datatype :coffi.mem/int, :n-elems 1, :calculated-offset 128})} {:id :clang/CXCompletionResult, :size-in-bytes 16, :fields ({:name "CursorKind", :datatype :coffi.mem/int, :n-elems 1, :calculated-offset 0} {:name "CompletionString", :datatype :coffi.mem/pointer, :n-elems 1, :calculated-offset 64})} {:id :clang/CXSourceLocation, :size-in-bytes 24, :fields ({:name "ptr_data", :datatype [:coffi.mem/array :coffi.mem/pointer 2], :n-elems 2, :calculated-offset 0} {:name "int_data", :datatype :coffi.mem/int, :n-elems 1, :calculated-offset 128})} {:id :clang/IndexerCallbacks, :size-in-bytes 64, :fields ({:name "abortQuery", :datatype [:coffi.ffi/fn [:coffi.mem/pointer :coffi.mem/pointer] :coffi.mem/int], :n-elems 1, :calculated-offset 0} {:name "diagnostic", :datatype [:coffi.ffi/fn [:coffi.mem/pointer :coffi.mem/pointer :coffi.mem/pointer] :coffi.mem/void], :n-elems 1, :calculated-offset 64} {:name "enteredMainFile", :datatype [:coffi.ffi/fn [:coffi.mem/pointer :coffi.mem/pointer :coffi.mem/pointer] :coffi.mem/pointer], :n-elems 1, :calculated-offset 128} {:name "ppIncludedFile", :datatype [:coffi.ffi/fn [:coffi.mem/pointer [:coffi.mem/pointer :clang/CXIdxIncludedFileInfo]] :coffi.mem/pointer], :n-elems 1, :calculated-offset 192} {:name "importedASTFile", :datatype [:coffi.ffi/fn [:coffi.mem/pointer [:coffi.mem/pointer :clang/CXIdxImportedASTFileInfo]] :coffi.mem/pointer], :n-elems 1, :calculated-offset 256} {:name "startedTranslationUnit", :datatype [:coffi.ffi/fn [:coffi.mem/pointer :coffi.mem/pointer] :coffi.mem/pointer], :n-elems 1, :calculated-offset 320} {:name "indexDeclaration", :datatype [:coffi.ffi/fn [:coffi.mem/pointer [:coffi.mem/pointer :clang/CXIdxDeclInfo]] :coffi.mem/void], :n-elems 1, :calculated-offset 384} {:name "indexEntityReference", :datatype [:coffi.ffi/fn [:coffi.mem/pointer [:coffi.mem/pointer :clang/CXIdxEntityRefInfo]] :coffi.mem/void], :n-elems 1, :calculated-offset 448})}), :enums ({:name "CXError_Success", :doc "/**\n   * No error.\n   */", :value 0} {:name "CXError_Failure", :doc "/**\n   * A generic error code, no further details are available.\n   *\n   * Errors of this kind can get their own specific error codes in future\n   * libclang versions.\n   */", :value 1} {:name "CXError_Crashed", :doc "/**\n   * libclang crashed while performing the requested operation.\n   */", :value 2} {:name "CXError_InvalidArguments", :doc "/**\n   * The function detected that the arguments violate the function\n   * contract.\n   */", :value 3} {:name "CXError_ASTReadError", :doc "/**\n   * An AST deserialization error has occurred.\n   */", :value 4} {:name "CXAvailability_Available", :doc "/**\n   * The entity is available.\n   */", :value 0} {:name "CXAvailability_Deprecated", :doc "/**\n   * The entity is available, but has been deprecated (and its use is\n   * not recommended).\n   */", :value 1} {:name "CXAvailability_NotAvailable", :doc "/**\n   * The entity is not available; any use of it will be an error.\n   */", :value 2} {:name "CXAvailability_NotAccessible", :doc "/**\n   * The entity is available, but not accessible; any use of it will be\n   * an error.\n   */", :value 3} {:name "CXCursor_ExceptionSpecificationKind_None", :doc "/**\n   * The cursor has no exception specification.\n   */", :value 0} {:name "CXCursor_ExceptionSpecificationKind_DynamicNone", :doc "/**\n   * The cursor has exception specification throw()\n   */", :value 1} {:name "CXCursor_ExceptionSpecificationKind_Dynamic", :doc "/**\n   * The cursor has exception specification throw(T1, T2)\n   */", :value 2} {:name "CXCursor_ExceptionSpecificationKind_MSAny", :doc "/**\n   * The cursor has exception specification throw(...).\n   */", :value 3} {:name "CXCursor_ExceptionSpecificationKind_BasicNoexcept", :doc "/**\n   * The cursor has exception specification basic noexcept.\n   */", :value 4} {:name "CXCursor_ExceptionSpecificationKind_ComputedNoexcept", :doc "/**\n   * The cursor has exception specification computed noexcept.\n   */", :value 5} {:name "CXCursor_ExceptionSpecificationKind_Unevaluated", :doc "/**\n   * The exception specification has not yet been evaluated.\n   */", :value 6} {:name "CXCursor_ExceptionSpecificationKind_Uninstantiated", :doc "/**\n   * The exception specification has not yet been instantiated.\n   */", :value 7} {:name "CXCursor_ExceptionSpecificationKind_Unparsed", :doc "/**\n   * The exception specification has not been parsed yet.\n   */", :value 8} {:name "CXCursor_ExceptionSpecificationKind_NoThrow", :doc "/**\n   * The cursor has a __declspec(nothrow) exception specification.\n   */", :value 9} {:name "CXGlobalOpt_None", :doc "/**\n   * Used to indicate that no special CXIndex options are needed.\n   */", :value 0} {:name "CXGlobalOpt_ThreadBackgroundPriorityForIndexing", :doc "/**\n   * Used to indicate that threads that libclang creates for indexing\n   * purposes should use background priority.\n   *\n   * Affects #clang_indexSourceFile, #clang_indexTranslationUnit,\n   * #clang_parseTranslationUnit, #clang_saveTranslationUnit.\n   */", :value 1} {:name "CXGlobalOpt_ThreadBackgroundPriorityForEditing", :doc "/**\n   * Used to indicate that threads that libclang creates for editing\n   * purposes should use background priority.\n   *\n   * Affects #clang_reparseTranslationUnit, #clang_codeCompleteAt,\n   * #clang_annotateTokens\n   */", :value 2} {:name "CXGlobalOpt_ThreadBackgroundPriorityForAll", :doc "/**\n   * Used to indicate that all threads that libclang creates should use\n   * background priority.\n   */", :value 3} {:name "CXGlobalOpt_None", :doc "/**\n   * Used to indicate that no special CXIndex options are needed.\n   */", :value 0} {:name "CXGlobalOpt_ThreadBackgroundPriorityForIndexing", :doc "/**\n   * Used to indicate that threads that libclang creates for indexing\n   * purposes should use background priority.\n   *\n   * Affects #clang_indexSourceFile, #clang_indexTranslationUnit,\n   * #clang_parseTranslationUnit, #clang_saveTranslationUnit.\n   */", :value 1} {:name "CXGlobalOpt_ThreadBackgroundPriorityForEditing", :doc "/**\n   * Used to indicate that threads that libclang creates for editing\n   * purposes should use background priority.\n   *\n   * Affects #clang_reparseTranslationUnit, #clang_codeCompleteAt,\n   * #clang_annotateTokens\n   */", :value 2} {:name "CXGlobalOpt_ThreadBackgroundPriorityForAll", :doc "/**\n   * Used to indicate that all threads that libclang creates should use\n   * background priority.\n   */", :value 3} {:name "CXDiagnostic_Ignored", :doc "/**\n   * A diagnostic that has been suppressed, e.g., by a command-line\n   * option.\n   */", :value 0} {:name "CXDiagnostic_Note", :doc "/**\n   * This diagnostic is a note that should be attached to the\n   * previous (non-note) diagnostic.\n   */", :value 1} {:name "CXDiagnostic_Warning", :doc "/**\n   * This diagnostic indicates suspicious code that may not be\n   * wrong.\n   */", :value 2} {:name "CXDiagnostic_Error", :doc "/**\n   * This diagnostic indicates that the code is ill-formed.\n   */", :value 3} {:name "CXDiagnostic_Fatal", :doc "/**\n   * This diagnostic indicates that the code is ill-formed such\n   * that future parser recovery is unlikely to produce useful\n   * results.\n   */", :value 4} {:name "CXLoadDiag_None", :doc "/**\n   * Indicates that no error occurred.\n   */", :value 0} {:name "CXLoadDiag_Unknown", :doc "/**\n   * Indicates that an unknown error occurred while attempting to\n   * deserialize diagnostics.\n   */", :value 1} {:name "CXLoadDiag_CannotLoad", :doc "/**\n   * Indicates that the file containing the serialized diagnostics\n   * could not be opened.\n   */", :value 2} {:name "CXLoadDiag_InvalidFile", :doc "/**\n   * Indicates that the serialized diagnostics file is invalid or\n   * corrupt.\n   */", :value 3} {:name "CXDiagnostic_DisplaySourceLocation", :doc "/**\n   * Display the source-location information where the\n   * diagnostic was located.\n   *\n   * When set, diagnostics will be prefixed by the file, line, and\n   * (optionally) column to which the diagnostic refers. For example,\n   *\n   * \\code\n   * test.c:28: warning: extra tokens at end of #endif directive\n   * \\endcode\n   *\n   * This option corresponds to the clang flag \\c -fshow-source-location.\n   */", :value 1} {:name "CXDiagnostic_DisplayColumn", :doc "/**\n   * If displaying the source-location information of the\n   * diagnostic, also include the column number.\n   *\n   * This option corresponds to the clang flag \\c -fshow-column.\n   */", :value 2} {:name "CXDiagnostic_DisplaySourceRanges", :doc "/**\n   * If displaying the source-location information of the\n   * diagnostic, also include information about source ranges in a\n   * machine-parsable format.\n   *\n   * This option corresponds to the clang flag\n   * \\c -fdiagnostics-print-source-range-info.\n   */", :value 4} {:name "CXDiagnostic_DisplayOption", :doc "/**\n   * Display the option name associated with this diagnostic, if any.\n   *\n   * The option name displayed (e.g., -Wconversion) will be placed in brackets\n   * after the diagnostic text. This option corresponds to the clang flag\n   * \\c -fdiagnostics-show-option.\n   */", :value 8} {:name "CXDiagnostic_DisplayCategoryId", :doc "/**\n   * Display the category number associated with this diagnostic, if any.\n   *\n   * The category number is displayed within brackets after the diagnostic text.\n   * This option corresponds to the clang flag\n   * \\c -fdiagnostics-show-category=id.\n   */", :value 16} {:name "CXDiagnostic_DisplayCategoryName", :doc "/**\n   * Display the category name associated with this diagnostic, if any.\n   *\n   * The category name is displayed within brackets after the diagnostic text.\n   * This option corresponds to the clang flag\n   * \\c -fdiagnostics-show-category=name.\n   */", :value 32} {:name "CXTranslationUnit_None", :doc "/**\n   * Used to indicate that no special translation-unit options are\n   * needed.\n   */", :value 0} {:name "CXTranslationUnit_DetailedPreprocessingRecord", :doc "/**\n   * Used to indicate that the parser should construct a \"detailed\"\n   * preprocessing record, including all macro definitions and instantiations.\n   *\n   * Constructing a detailed preprocessing record requires more memory\n   * and time to parse, since the information contained in the record\n   * is usually not retained. However, it can be useful for\n   * applications that require more detailed information about the\n   * behavior of the preprocessor.\n   */", :value 1} {:name "CXTranslationUnit_Incomplete", :doc "/**\n   * Used to indicate that the translation unit is incomplete.\n   *\n   * When a translation unit is considered \"incomplete\", semantic\n   * analysis that is typically performed at the end of the\n   * translation unit will be suppressed. For example, this suppresses\n   * the completion of tentative declarations in C and of\n   * instantiation of implicitly-instantiation function templates in\n   * C++. This option is typically used when parsing a header with the\n   * intent of producing a precompiled header.\n   */", :value 2} {:name "CXTranslationUnit_PrecompiledPreamble", :doc "/**\n   * Used to indicate that the translation unit should be built with an\n   * implicit precompiled header for the preamble.\n   *\n   * An implicit precompiled header is used as an optimization when a\n   * particular translation unit is likely to be reparsed many times\n   * when the sources aren't changing that often. In this case, an\n   * implicit precompiled header will be built containing all of the\n   * initial includes at the top of the main file (what we refer to as\n   * the \"preamble\" of the file). In subsequent parses, if the\n   * preamble or the files in it have not changed, \\c\n   * clang_reparseTranslationUnit() will re-use the implicit\n   * precompiled header to improve parsing performance.\n   */", :value 4} {:name "CXTranslationUnit_CacheCompletionResults", :doc "/**\n   * Used to indicate that the translation unit should cache some\n   * code-completion results with each reparse of the source file.\n   *\n   * Caching of code-completion results is a performance optimization that\n   * introduces some overhead to reparsing but improves the performance of\n   * code-completion operations.\n   */", :value 8} {:name "CXTranslationUnit_ForSerialization", :doc "/**\n   * Used to indicate that the translation unit will be serialized with\n   * \\c clang_saveTranslationUnit.\n   *\n   * This option is typically used when parsing a header with the intent of\n   * producing a precompiled header.\n   */", :value 16} {:name "CXTranslationUnit_CXXChainedPCH", :doc "/**\n   * DEPRECATED: Enabled chained precompiled preambles in C++.\n   *\n   * Note: this is a *temporary* option that is available only while\n   * we are testing C++ precompiled preamble support. It is deprecated.\n   */", :value 32} {:name "CXTranslationUnit_SkipFunctionBodies", :doc "/**\n   * Used to indicate that function/method bodies should be skipped while\n   * parsing.\n   *\n   * This option can be used to search for declarations/definitions while\n   * ignoring the usages.\n   */", :value 64} {:name "CXTranslationUnit_IncludeBriefCommentsInCodeCompletion", :doc "/**\n   * Used to indicate that brief documentation comments should be\n   * included into the set of code completions returned from this translation\n   * unit.\n   */", :value 128} {:name "CXTranslationUnit_CreatePreambleOnFirstParse", :doc "/**\n   * Used to indicate that the precompiled preamble should be created on\n   * the first parse. Otherwise it will be created on the first reparse. This\n   * trades runtime on the first parse (serializing the preamble takes time) for\n   * reduced runtime on the second parse (can now reuse the preamble).\n   */", :value 256} {:name "CXTranslationUnit_KeepGoing", :doc "/**\n   * Do not stop processing when fatal errors are encountered.\n   *\n   * When fatal errors are encountered while parsing a translation unit,\n   * semantic analysis is typically stopped early when compiling code. A common\n   * source for fatal errors are unresolvable include files. For the\n   * purposes of an IDE, this is undesirable behavior and as much information\n   * as possible should be reported. Use this flag to enable this behavior.\n   */", :value 512} {:name "CXTranslationUnit_SingleFileParse", :doc "/**\n   * Sets the preprocessor in a mode for parsing a single file only.\n   */", :value 1024} {:name "CXTranslationUnit_LimitSkipFunctionBodiesToPreamble", :doc "/**\n   * Used in combination with CXTranslationUnit_SkipFunctionBodies to\n   * constrain the skipping of function bodies to the preamble.\n   *\n   * The function bodies of the main file are not skipped.\n   */", :value 2048} {:name "CXTranslationUnit_IncludeAttributedTypes", :doc "/**\n   * Used to indicate that attributed types should be included in CXType.\n   */", :value 4096} {:name "CXTranslationUnit_VisitImplicitAttributes", :doc "/**\n   * Used to indicate that implicit attributes should be visited.\n   */", :value 8192} {:name "CXTranslationUnit_IgnoreNonErrorsFromIncludedFiles", :doc "/**\n   * Used to indicate that non-errors from included files should be ignored.\n   *\n   * If set, clang_getDiagnosticSetFromTU() will not report e.g. warnings from\n   * included files anymore. This speeds up clang_getDiagnosticSetFromTU() for\n   * the case where these warnings are not of interest, as for an IDE for\n   * example, which typically shows only the diagnostics in the main file.\n   */", :value 16384} {:name "CXTranslationUnit_RetainExcludedConditionalBlocks", :doc "/**\n   * Tells the preprocessor not to skip excluded conditional blocks.\n   */", :value 32768} {:name "CXSaveTranslationUnit_None", :doc "/**\n   * Used to indicate that no special saving options are needed.\n   */", :value 0} {:name "CXSaveError_None", :doc "/**\n   * Indicates that no error occurred while saving a translation unit.\n   */", :value 0} {:name "CXSaveError_Unknown", :doc "/**\n   * Indicates that an unknown error occurred while attempting to save\n   * the file.\n   *\n   * This error typically indicates that file I/O failed when attempting to\n   * write the file.\n   */", :value 1} {:name "CXSaveError_TranslationErrors", :doc "/**\n   * Indicates that errors during translation prevented this attempt\n   * to save the translation unit.\n   *\n   * Errors that prevent the translation unit from being saved can be\n   * extracted using \\c clang_getNumDiagnostics() and \\c clang_getDiagnostic().\n   */", :value 2} {:name "CXSaveError_InvalidTU", :doc "/**\n   * Indicates that the translation unit to be saved was somehow\n   * invalid (e.g., NULL).\n   */", :value 3} {:name "CXReparse_None", :doc "/**\n   * Used to indicate that no special reparsing options are needed.\n   */", :value 0} {:name "CXTUResourceUsage_AST", :doc nil, :value 1} {:name "CXTUResourceUsage_Identifiers", :doc nil, :value 2} {:name "CXTUResourceUsage_Selectors", :doc nil, :value 3} {:name "CXTUResourceUsage_GlobalCompletionResults", :doc nil, :value 4} {:name "CXTUResourceUsage_SourceManagerContentCache", :doc nil, :value 5} {:name "CXTUResourceUsage_AST_SideTables", :doc nil, :value 6} {:name "CXTUResourceUsage_SourceManager_Membuffer_Malloc", :doc nil, :value 7} {:name "CXTUResourceUsage_SourceManager_Membuffer_MMap", :doc nil, :value 8} {:name "CXTUResourceUsage_ExternalASTSource_Membuffer_Malloc", :doc nil, :value 9} {:name "CXTUResourceUsage_ExternalASTSource_Membuffer_MMap", :doc nil, :value 10} {:name "CXTUResourceUsage_Preprocessor", :doc nil, :value 11} {:name "CXTUResourceUsage_PreprocessingRecord", :doc nil, :value 12} {:name "CXTUResourceUsage_SourceManager_DataStructures", :doc nil, :value 13} {:name "CXTUResourceUsage_Preprocessor_HeaderSearch", :doc nil, :value 14} {:name "CXTUResourceUsage_MEMORY_IN_BYTES_BEGIN", :doc nil, :value 1} {:name "CXTUResourceUsage_MEMORY_IN_BYTES_END", :doc nil, :value 14} {:name "CXTUResourceUsage_First", :doc nil, :value 1} {:name "CXTUResourceUsage_Last", :doc nil, :value 14} {:name "CXCursor_UnexposedDecl", :doc "/**\n   * A declaration whose specific kind is not exposed via this\n   * interface.\n   *\n   * Unexposed declarations have the same operations as any other kind\n   * of declaration; one can extract their location information,\n   * spelling, find their definitions, etc. However, the specific kind\n   * of the declaration is not reported.\n   */", :value 1} {:name "CXCursor_StructDecl", :doc "/** A C or C++ struct. */", :value 2} {:name "CXCursor_UnionDecl", :doc "/** A C or C++ union. */", :value 3} {:name "CXCursor_ClassDecl", :doc "/** A C++ class. */", :value 4} {:name "CXCursor_EnumDecl", :doc "/** An enumeration. */", :value 5} {:name "CXCursor_FieldDecl", :doc "/**\n   * A field (in C) or non-static data member (in C++) in a\n   * struct, union, or C++ class.\n   */", :value 6} {:name "CXCursor_EnumConstantDecl", :doc "/** An enumerator constant. */", :value 7} {:name "CXCursor_FunctionDecl", :doc "/** A function. */", :value 8} {:name "CXCursor_VarDecl", :doc "/** A variable. */", :value 9} {:name "CXCursor_ParmDecl", :doc "/** A function or method parameter. */", :value 10} {:name "CXCursor_ObjCInterfaceDecl", :doc "/** An Objective-C \\@interface. */", :value 11} {:name "CXCursor_ObjCCategoryDecl", :doc "/** An Objective-C \\@interface for a category. */", :value 12} {:name "CXCursor_ObjCProtocolDecl", :doc "/** An Objective-C \\@protocol declaration. */", :value 13} {:name "CXCursor_ObjCPropertyDecl", :doc "/** An Objective-C \\@property declaration. */", :value 14} {:name "CXCursor_ObjCIvarDecl", :doc "/** An Objective-C instance variable. */", :value 15} {:name "CXCursor_ObjCInstanceMethodDecl", :doc "/** An Objective-C instance method. */", :value 16} {:name "CXCursor_ObjCClassMethodDecl", :doc "/** An Objective-C class method. */", :value 17} {:name "CXCursor_ObjCImplementationDecl", :doc "/** An Objective-C \\@implementation. */", :value 18} {:name "CXCursor_ObjCCategoryImplDecl", :doc "/** An Objective-C \\@implementation for a category. */", :value 19} {:name "CXCursor_TypedefDecl", :doc "/** A typedef. */", :value 20} {:name "CXCursor_CXXMethod", :doc "/** A C++ class method. */", :value 21} {:name "CXCursor_Namespace", :doc "/** A C++ namespace. */", :value 22} {:name "CXCursor_LinkageSpec", :doc "/** A linkage specification, e.g. 'extern \"C\"'. */", :value 23} {:name "CXCursor_Constructor", :doc "/** A C++ constructor. */", :value 24} {:name "CXCursor_Destructor", :doc "/** A C++ destructor. */", :value 25} {:name "CXCursor_ConversionFunction", :doc "/** A C++ conversion function. */", :value 26} {:name "CXCursor_TemplateTypeParameter", :doc "/** A C++ template type parameter. */", :value 27} {:name "CXCursor_NonTypeTemplateParameter", :doc "/** A C++ non-type template parameter. */", :value 28} {:name "CXCursor_TemplateTemplateParameter", :doc "/** A C++ template template parameter. */", :value 29} {:name "CXCursor_FunctionTemplate", :doc "/** A C++ function template. */", :value 30} {:name "CXCursor_ClassTemplate", :doc "/** A C++ class template. */", :value 31} {:name "CXCursor_ClassTemplatePartialSpecialization", :doc "/** A C++ class template partial specialization. */", :value 32} {:name "CXCursor_NamespaceAlias", :doc "/** A C++ namespace alias declaration. */", :value 33} {:name "CXCursor_UsingDirective", :doc "/** A C++ using directive. */", :value 34} {:name "CXCursor_UsingDeclaration", :doc "/** A C++ using declaration. */", :value 35} {:name "CXCursor_TypeAliasDecl", :doc "/** A C++ alias declaration */", :value 36} {:name "CXCursor_ObjCSynthesizeDecl", :doc "/** An Objective-C \\@synthesize definition. */", :value 37} {:name "CXCursor_ObjCDynamicDecl", :doc "/** An Objective-C \\@dynamic definition. */", :value 38} {:name "CXCursor_CXXAccessSpecifier", :doc "/** An access specifier. */", :value 39} {:name "CXCursor_FirstDecl", :doc "/** An access specifier. */", :value 1} {:name "CXCursor_LastDecl", :doc "/** An access specifier. */", :value 39} {:name "CXCursor_FirstRef", :doc "/** An access specifier. */", :value 40} {:name "CXCursor_ObjCSuperClassRef", :doc "/** An access specifier. */", :value 40} {:name "CXCursor_ObjCProtocolRef", :doc "/** An access specifier. */", :value 41} {:name "CXCursor_ObjCClassRef", :doc "/** An access specifier. */", :value 42} {:name "CXCursor_TypeRef", :doc "/**\n   * A reference to a type declaration.\n   *\n   * A type reference occurs anywhere where a type is named but not\n   * declared. For example, given:\n   *\n   * \\code\n   * typedef unsigned size_type;\n   * size_type size;\n   * \\endcode\n   *\n   * The typedef is a declaration of size_type (CXCursor_TypedefDecl),\n   * while the type of the variable \"size\" is referenced. The cursor\n   * referenced by the type of size is the typedef for size_type.\n   */", :value 43} {:name "CXCursor_CXXBaseSpecifier", :doc "/**\n   * A reference to a type declaration.\n   *\n   * A type reference occurs anywhere where a type is named but not\n   * declared. For example, given:\n   *\n   * \\code\n   * typedef unsigned size_type;\n   * size_type size;\n   * \\endcode\n   *\n   * The typedef is a declaration of size_type (CXCursor_TypedefDecl),\n   * while the type of the variable \"size\" is referenced. The cursor\n   * referenced by the type of size is the typedef for size_type.\n   */", :value 44} {:name "CXCursor_TemplateRef", :doc "/**\n   * A reference to a class template, function template, template\n   * template parameter, or class template partial specialization.\n   */", :value 45} {:name "CXCursor_NamespaceRef", :doc "/**\n   * A reference to a namespace or namespace alias.\n   */", :value 46} {:name "CXCursor_MemberRef", :doc "/**\n   * A reference to a member of a struct, union, or class that occurs in\n   * some non-expression context, e.g., a designated initializer.\n   */", :value 47} {:name "CXCursor_LabelRef", :doc "/**\n   * A reference to a labeled statement.\n   *\n   * This cursor kind is used to describe the jump to \"start_over\" in the\n   * goto statement in the following example:\n   *\n   * \\code\n   *   start_over:\n   *     ++counter;\n   *\n   *     goto start_over;\n   * \\endcode\n   *\n   * A label reference cursor refers to a label statement.\n   */", :value 48} {:name "CXCursor_OverloadedDeclRef", :doc "/**\n   * A reference to a set of overloaded functions or function templates\n   * that has not yet been resolved to a specific function or function template.\n   *\n   * An overloaded declaration reference cursor occurs in C++ templates where\n   * a dependent name refers to a function. For example:\n   *\n   * \\code\n   * template<typename T> void swap(T&, T&);\n   *\n   * struct X { ... };\n   * void swap(X&, X&);\n   *\n   * template<typename T>\n   * void reverse(T* first, T* last) {\n   *   while (first < last - 1) {\n   *     swap(*first, *--last);\n   *     ++first;\n   *   }\n   * }\n   *\n   * struct Y { };\n   * void swap(Y&, Y&);\n   * \\endcode\n   *\n   * Here, the identifier \"swap\" is associated with an overloaded declaration\n   * reference. In the template definition, \"swap\" refers to either of the two\n   * \"swap\" functions declared above, so both results will be available. At\n   * instantiation time, \"swap\" may also refer to other functions found via\n   * argument-dependent lookup (e.g., the \"swap\" function at the end of the\n   * example).\n   *\n   * The functions \\c clang_getNumOverloadedDecls() and\n   * \\c clang_getOverloadedDecl() can be used to retrieve the definitions\n   * referenced by this cursor.\n   */", :value 49} {:name "CXCursor_VariableRef", :doc "/**\n   * A reference to a variable that occurs in some non-expression\n   * context, e.g., a C++ lambda capture list.\n   */", :value 50} {:name "CXCursor_LastRef", :doc "/**\n   * A reference to a variable that occurs in some non-expression\n   * context, e.g., a C++ lambda capture list.\n   */", :value 50} {:name "CXCursor_FirstInvalid", :doc "/**\n   * A reference to a variable that occurs in some non-expression\n   * context, e.g., a C++ lambda capture list.\n   */", :value 70} {:name "CXCursor_InvalidFile", :doc "/**\n   * A reference to a variable that occurs in some non-expression\n   * context, e.g., a C++ lambda capture list.\n   */", :value 70} {:name "CXCursor_NoDeclFound", :doc "/**\n   * A reference to a variable that occurs in some non-expression\n   * context, e.g., a C++ lambda capture list.\n   */", :value 71} {:name "CXCursor_NotImplemented", :doc "/**\n   * A reference to a variable that occurs in some non-expression\n   * context, e.g., a C++ lambda capture list.\n   */", :value 72} {:name "CXCursor_InvalidCode", :doc "/**\n   * A reference to a variable that occurs in some non-expression\n   * context, e.g., a C++ lambda capture list.\n   */", :value 73} {:name "CXCursor_LastInvalid", :doc "/**\n   * A reference to a variable that occurs in some non-expression\n   * context, e.g., a C++ lambda capture list.\n   */", :value 73} {:name "CXCursor_FirstExpr", :doc "/**\n   * A reference to a variable that occurs in some non-expression\n   * context, e.g., a C++ lambda capture list.\n   */", :value 100} {:name "CXCursor_UnexposedExpr", :doc "/**\n   * An expression whose specific kind is not exposed via this\n   * interface.\n   *\n   * Unexposed expressions have the same operations as any other kind\n   * of expression; one can extract their location information,\n   * spelling, children, etc. However, the specific kind of the\n   * expression is not reported.\n   */", :value 100} {:name "CXCursor_DeclRefExpr", :doc "/**\n   * An expression that refers to some value declaration, such\n   * as a function, variable, or enumerator.\n   */", :value 101} {:name "CXCursor_MemberRefExpr", :doc "/**\n   * An expression that refers to a member of a struct, union,\n   * class, Objective-C class, etc.\n   */", :value 102} {:name "CXCursor_CallExpr", :doc "/** An expression that calls a function. */", :value 103} {:name "CXCursor_ObjCMessageExpr", :doc "/** An expression that sends a message to an Objective-C\n   object or class. */", :value 104} {:name "CXCursor_BlockExpr", :doc "/** An expression that represents a block literal. */", :value 105} {:name "CXCursor_IntegerLiteral", :doc "/** An integer literal.\n   */", :value 106} {:name "CXCursor_FloatingLiteral", :doc "/** A floating point number literal.\n   */", :value 107} {:name "CXCursor_ImaginaryLiteral", :doc "/** An imaginary number literal.\n   */", :value 108} {:name "CXCursor_StringLiteral", :doc "/** A string literal.\n   */", :value 109} {:name "CXCursor_CharacterLiteral", :doc "/** A character literal.\n   */", :value 110} {:name "CXCursor_ParenExpr", :doc "/** A parenthesized expression, e.g. \"(1)\".\n   *\n   * This AST node is only formed if full location information is requested.\n   */", :value 111} {:name "CXCursor_UnaryOperator", :doc "/** This represents the unary-expression's (except sizeof and\n   * alignof).\n   */", :value 112} {:name "CXCursor_ArraySubscriptExpr", :doc "/** [C99 6.5.2.1] Array Subscripting.\n   */", :value 113} {:name "CXCursor_BinaryOperator", :doc "/** A builtin binary operation expression such as \"x + y\" or\n   * \"x <= y\".\n   */", :value 114} {:name "CXCursor_CompoundAssignOperator", :doc "/** Compound assignment such as \"+=\".\n   */", :value 115} {:name "CXCursor_ConditionalOperator", :doc "/** The ?: ternary operator.\n   */", :value 116} {:name "CXCursor_CStyleCastExpr", :doc "/** An explicit cast in C (C99 6.5.4) or a C-style cast in C++\n   * (C++ [expr.cast]), which uses the syntax (Type)expr.\n   *\n   * For example: (int)f.\n   */", :value 117} {:name "CXCursor_CompoundLiteralExpr", :doc "/** [C99 6.5.2.5]\n   */", :value 118} {:name "CXCursor_InitListExpr", :doc "/** Describes an C or C++ initializer list.\n   */", :value 119} {:name "CXCursor_AddrLabelExpr", :doc "/** The GNU address of label extension, representing &&label.\n   */", :value 120} {:name "CXCursor_StmtExpr", :doc "/** This is the GNU Statement Expression extension: ({int X=4; X;})\n   */", :value 121} {:name "CXCursor_GenericSelectionExpr", :doc "/** Represents a C11 generic selection.\n   */", :value 122} {:name "CXCursor_GNUNullExpr", :doc "/** Implements the GNU __null extension, which is a name for a null\n   * pointer constant that has integral type (e.g., int or long) and is the same\n   * size and alignment as a pointer.\n   *\n   * The __null extension is typically only used by system headers, which define\n   * NULL as __null in C++ rather than using 0 (which is an integer that may not\n   * match the size of a pointer).\n   */", :value 123} {:name "CXCursor_CXXStaticCastExpr", :doc "/** C++'s static_cast<> expression.\n   */", :value 124} {:name "CXCursor_CXXDynamicCastExpr", :doc "/** C++'s dynamic_cast<> expression.\n   */", :value 125} {:name "CXCursor_CXXReinterpretCastExpr", :doc "/** C++'s reinterpret_cast<> expression.\n   */", :value 126} {:name "CXCursor_CXXConstCastExpr", :doc "/** C++'s const_cast<> expression.\n   */", :value 127} {:name "CXCursor_CXXFunctionalCastExpr", :doc "/** Represents an explicit C++ type conversion that uses \"functional\"\n   * notion (C++ [expr.type.conv]).\n   *\n   * Example:\n   * \\code\n   *   x = int(0.5);\n   * \\endcode\n   */", :value 128} {:name "CXCursor_CXXTypeidExpr", :doc "/** A C++ typeid expression (C++ [expr.typeid]).\n   */", :value 129} {:name "CXCursor_CXXBoolLiteralExpr", :doc "/** [C++ 2.13.5] C++ Boolean Literal.\n   */", :value 130} {:name "CXCursor_CXXNullPtrLiteralExpr", :doc "/** [C++0x 2.14.7] C++ Pointer Literal.\n   */", :value 131} {:name "CXCursor_CXXThisExpr", :doc "/** Represents the \"this\" expression in C++\n   */", :value 132} {:name "CXCursor_CXXThrowExpr", :doc "/** [C++ 15] C++ Throw Expression.\n   *\n   * This handles 'throw' and 'throw' assignment-expression. When\n   * assignment-expression isn't present, Op will be null.\n   */", :value 133} {:name "CXCursor_CXXNewExpr", :doc "/** A new expression for memory allocation and constructor calls, e.g:\n   * \"new CXXNewExpr(foo)\".\n   */", :value 134} {:name "CXCursor_CXXDeleteExpr", :doc "/** A delete expression for memory deallocation and destructor calls,\n   * e.g. \"delete[] pArray\".\n   */", :value 135} {:name "CXCursor_UnaryExpr", :doc "/** A unary expression. (noexcept, sizeof, or other traits)\n   */", :value 136} {:name "CXCursor_ObjCStringLiteral", :doc "/** An Objective-C string literal i.e. @\"foo\".\n   */", :value 137} {:name "CXCursor_ObjCEncodeExpr", :doc "/** An Objective-C \\@encode expression.\n   */", :value 138} {:name "CXCursor_ObjCSelectorExpr", :doc "/** An Objective-C \\@selector expression.\n   */", :value 139} {:name "CXCursor_ObjCProtocolExpr", :doc "/** An Objective-C \\@protocol expression.\n   */", :value 140} {:name "CXCursor_ObjCBridgedCastExpr", :doc "/** An Objective-C \"bridged\" cast expression, which casts between\n   * Objective-C pointers and C pointers, transferring ownership in the process.\n   *\n   * \\code\n   *   NSString *str = (__bridge_transfer NSString *)CFCreateString();\n   * \\endcode\n   */", :value 141} {:name "CXCursor_PackExpansionExpr", :doc "/** Represents a C++0x pack expansion that produces a sequence of\n   * expressions.\n   *\n   * A pack expansion expression contains a pattern (which itself is an\n   * expression) followed by an ellipsis. For example:\n   *\n   * \\code\n   * template<typename F, typename ...Types>\n   * void forward(F f, Types &&...args) {\n   *  f(static_cast<Types&&>(args)...);\n   * }\n   * \\endcode\n   */", :value 142} {:name "CXCursor_SizeOfPackExpr", :doc "/** Represents an expression that computes the length of a parameter\n   * pack.\n   *\n   * \\code\n   * template<typename ...Types>\n   * struct count {\n   *   static const unsigned value = sizeof...(Types);\n   * };\n   * \\endcode\n   */", :value 143} {:name "CXCursor_LambdaExpr", :doc nil, :value 144} {:name "CXCursor_ObjCBoolLiteralExpr", :doc "/** Objective-c Boolean Literal.\n   */", :value 145} {:name "CXCursor_ObjCSelfExpr", :doc "/** Represents the \"self\" expression in an Objective-C method.\n   */", :value 146} {:name "CXCursor_OMPArraySectionExpr", :doc "/** OpenMP 5.0 [2.1.5, Array Section].\n   */", :value 147} {:name "CXCursor_ObjCAvailabilityCheckExpr", :doc "/** Represents an @available(...) check.\n   */", :value 148} {:name "CXCursor_FixedPointLiteral", :doc "/**\n   * Fixed point literal\n   */", :value 149} {:name "CXCursor_OMPArrayShapingExpr", :doc "/** OpenMP 5.0 [2.1.4, Array Shaping].\n   */", :value 150} {:name "CXCursor_OMPIteratorExpr", :doc "/**\n   * OpenMP 5.0 [2.1.6 Iterators]\n   */", :value 151} {:name "CXCursor_CXXAddrspaceCastExpr", :doc "/** OpenCL's addrspace_cast<> expression.\n   */", :value 152} {:name "CXCursor_LastExpr", :doc "/** OpenCL's addrspace_cast<> expression.\n   */", :value 152} {:name "CXCursor_FirstStmt", :doc "/** OpenCL's addrspace_cast<> expression.\n   */", :value 200} {:name "CXCursor_UnexposedStmt", :doc "/**\n   * A statement whose specific kind is not exposed via this\n   * interface.\n   *\n   * Unexposed statements have the same operations as any other kind of\n   * statement; one can extract their location information, spelling,\n   * children, etc. However, the specific kind of the statement is not\n   * reported.\n   */", :value 200} {:name "CXCursor_LabelStmt", :doc "/** A labelled statement in a function.\n   *\n   * This cursor kind is used to describe the \"start_over:\" label statement in\n   * the following example:\n   *\n   * \\code\n   *   start_over:\n   *     ++counter;\n   * \\endcode\n   *\n   */", :value 201} {:name "CXCursor_CompoundStmt", :doc "/** A group of statements like { stmt stmt }.\n   *\n   * This cursor kind is used to describe compound statements, e.g. function\n   * bodies.\n   */", :value 202} {:name "CXCursor_CaseStmt", :doc "/** A case statement.\n   */", :value 203} {:name "CXCursor_DefaultStmt", :doc "/** A default statement.\n   */", :value 204} {:name "CXCursor_IfStmt", :doc "/** An if statement\n   */", :value 205} {:name "CXCursor_SwitchStmt", :doc "/** A switch statement.\n   */", :value 206} {:name "CXCursor_WhileStmt", :doc "/** A while statement.\n   */", :value 207} {:name "CXCursor_DoStmt", :doc "/** A do statement.\n   */", :value 208} {:name "CXCursor_ForStmt", :doc "/** A for statement.\n   */", :value 209} {:name "CXCursor_GotoStmt", :doc "/** A goto statement.\n   */", :value 210} {:name "CXCursor_IndirectGotoStmt", :doc "/** An indirect goto statement.\n   */", :value 211} {:name "CXCursor_ContinueStmt", :doc "/** A continue statement.\n   */", :value 212} {:name "CXCursor_BreakStmt", :doc "/** A break statement.\n   */", :value 213} {:name "CXCursor_ReturnStmt", :doc "/** A return statement.\n   */", :value 214} {:name "CXCursor_GCCAsmStmt", :doc "/** A GCC inline assembly statement extension.\n   */", :value 215} {:name "CXCursor_AsmStmt", :doc "/** A GCC inline assembly statement extension.\n   */", :value 215} {:name "CXCursor_ObjCAtTryStmt", :doc "/** Objective-C's overall \\@try-\\@catch-\\@finally statement.\n   */", :value 216} {:name "CXCursor_ObjCAtCatchStmt", :doc "/** Objective-C's \\@catch statement.\n   */", :value 217} {:name "CXCursor_ObjCAtFinallyStmt", :doc "/** Objective-C's \\@finally statement.\n   */", :value 218} {:name "CXCursor_ObjCAtThrowStmt", :doc "/** Objective-C's \\@throw statement.\n   */", :value 219} {:name "CXCursor_ObjCAtSynchronizedStmt", :doc "/** Objective-C's \\@synchronized statement.\n   */", :value 220} {:name "CXCursor_ObjCAutoreleasePoolStmt", :doc "/** Objective-C's autorelease pool statement.\n   */", :value 221} {:name "CXCursor_ObjCForCollectionStmt", :doc "/** Objective-C's collection statement.\n   */", :value 222} {:name "CXCursor_CXXCatchStmt", :doc "/** C++'s catch statement.\n   */", :value 223} {:name "CXCursor_CXXTryStmt", :doc "/** C++'s try statement.\n   */", :value 224} {:name "CXCursor_CXXForRangeStmt", :doc "/** C++'s for (* : *) statement.\n   */", :value 225} {:name "CXCursor_SEHTryStmt", :doc "/** Windows Structured Exception Handling's try statement.\n   */", :value 226} {:name "CXCursor_SEHExceptStmt", :doc "/** Windows Structured Exception Handling's except statement.\n   */", :value 227} {:name "CXCursor_SEHFinallyStmt", :doc "/** Windows Structured Exception Handling's finally statement.\n   */", :value 228} {:name "CXCursor_MSAsmStmt", :doc "/** A MS inline assembly statement extension.\n   */", :value 229} {:name "CXCursor_NullStmt", :doc "/** The null statement \";\": C99 6.8.3p3.\n   *\n   * This cursor kind is used to describe the null statement.\n   */", :value 230} {:name "CXCursor_DeclStmt", :doc "/** Adaptor class for mixing declarations with statements and\n   * expressions.\n   */", :value 231} {:name "CXCursor_OMPParallelDirective", :doc "/** OpenMP parallel directive.\n   */", :value 232} {:name "CXCursor_OMPSimdDirective", :doc "/** OpenMP SIMD directive.\n   */", :value 233} {:name "CXCursor_OMPForDirective", :doc "/** OpenMP for directive.\n   */", :value 234} {:name "CXCursor_OMPSectionsDirective", :doc "/** OpenMP sections directive.\n   */", :value 235} {:name "CXCursor_OMPSectionDirective", :doc "/** OpenMP section directive.\n   */", :value 236} {:name "CXCursor_OMPSingleDirective", :doc "/** OpenMP single directive.\n   */", :value 237} {:name "CXCursor_OMPParallelForDirective", :doc "/** OpenMP parallel for directive.\n   */", :value 238} {:name "CXCursor_OMPParallelSectionsDirective", :doc "/** OpenMP parallel sections directive.\n   */", :value 239} {:name "CXCursor_OMPTaskDirective", :doc "/** OpenMP task directive.\n   */", :value 240} {:name "CXCursor_OMPMasterDirective", :doc "/** OpenMP master directive.\n   */", :value 241} {:name "CXCursor_OMPCriticalDirective", :doc "/** OpenMP critical directive.\n   */", :value 242} {:name "CXCursor_OMPTaskyieldDirective", :doc "/** OpenMP taskyield directive.\n   */", :value 243} {:name "CXCursor_OMPBarrierDirective", :doc "/** OpenMP barrier directive.\n   */", :value 244} {:name "CXCursor_OMPTaskwaitDirective", :doc "/** OpenMP taskwait directive.\n   */", :value 245} {:name "CXCursor_OMPFlushDirective", :doc "/** OpenMP flush directive.\n   */", :value 246} {:name "CXCursor_SEHLeaveStmt", :doc "/** Windows Structured Exception Handling's leave statement.\n   */", :value 247} {:name "CXCursor_OMPOrderedDirective", :doc "/** OpenMP ordered directive.\n   */", :value 248} {:name "CXCursor_OMPAtomicDirective", :doc "/** OpenMP atomic directive.\n   */", :value 249} {:name "CXCursor_OMPForSimdDirective", :doc "/** OpenMP for SIMD directive.\n   */", :value 250} {:name "CXCursor_OMPParallelForSimdDirective", :doc "/** OpenMP parallel for SIMD directive.\n   */", :value 251} {:name "CXCursor_OMPTargetDirective", :doc "/** OpenMP target directive.\n   */", :value 252} {:name "CXCursor_OMPTeamsDirective", :doc "/** OpenMP teams directive.\n   */", :value 253} {:name "CXCursor_OMPTaskgroupDirective", :doc "/** OpenMP taskgroup directive.\n   */", :value 254} {:name "CXCursor_OMPCancellationPointDirective", :doc "/** OpenMP cancellation point directive.\n   */", :value 255} {:name "CXCursor_OMPCancelDirective", :doc "/** OpenMP cancel directive.\n   */", :value 256} {:name "CXCursor_OMPTargetDataDirective", :doc "/** OpenMP target data directive.\n   */", :value 257} {:name "CXCursor_OMPTaskLoopDirective", :doc "/** OpenMP taskloop directive.\n   */", :value 258} {:name "CXCursor_OMPTaskLoopSimdDirective", :doc "/** OpenMP taskloop simd directive.\n   */", :value 259} {:name "CXCursor_OMPDistributeDirective", :doc "/** OpenMP distribute directive.\n   */", :value 260} {:name "CXCursor_OMPTargetEnterDataDirective", :doc "/** OpenMP target enter data directive.\n   */", :value 261} {:name "CXCursor_OMPTargetExitDataDirective", :doc "/** OpenMP target exit data directive.\n   */", :value 262} {:name "CXCursor_OMPTargetParallelDirective", :doc "/** OpenMP target parallel directive.\n   */", :value 263} {:name "CXCursor_OMPTargetParallelForDirective", :doc "/** OpenMP target parallel for directive.\n   */", :value 264} {:name "CXCursor_OMPTargetUpdateDirective", :doc "/** OpenMP target update directive.\n   */", :value 265} {:name "CXCursor_OMPDistributeParallelForDirective", :doc "/** OpenMP distribute parallel for directive.\n   */", :value 266} {:name "CXCursor_OMPDistributeParallelForSimdDirective", :doc "/** OpenMP distribute parallel for simd directive.\n   */", :value 267} {:name "CXCursor_OMPDistributeSimdDirective", :doc "/** OpenMP distribute simd directive.\n   */", :value 268} {:name "CXCursor_OMPTargetParallelForSimdDirective", :doc "/** OpenMP target parallel for simd directive.\n   */", :value 269} {:name "CXCursor_OMPTargetSimdDirective", :doc "/** OpenMP target simd directive.\n   */", :value 270} {:name "CXCursor_OMPTeamsDistributeDirective", :doc "/** OpenMP teams distribute directive.\n   */", :value 271} {:name "CXCursor_OMPTeamsDistributeSimdDirective", :doc "/** OpenMP teams distribute simd directive.\n   */", :value 272} {:name "CXCursor_OMPTeamsDistributeParallelForSimdDirective", :doc "/** OpenMP teams distribute parallel for simd directive.\n   */", :value 273} {:name "CXCursor_OMPTeamsDistributeParallelForDirective", :doc "/** OpenMP teams distribute parallel for directive.\n   */", :value 274} {:name "CXCursor_OMPTargetTeamsDirective", :doc "/** OpenMP target teams directive.\n   */", :value 275} {:name "CXCursor_OMPTargetTeamsDistributeDirective", :doc "/** OpenMP target teams distribute directive.\n   */", :value 276} {:name "CXCursor_OMPTargetTeamsDistributeParallelForDirective", :doc "/** OpenMP target teams distribute parallel for directive.\n   */", :value 277} {:name "CXCursor_OMPTargetTeamsDistributeParallelForSimdDirective", :doc "/** OpenMP target teams distribute parallel for simd directive.\n   */", :value 278} {:name "CXCursor_OMPTargetTeamsDistributeSimdDirective", :doc "/** OpenMP target teams distribute simd directive.\n   */", :value 279} {:name "CXCursor_BuiltinBitCastExpr", :doc "/** C++2a std::bit_cast expression.\n   */", :value 280} {:name "CXCursor_OMPMasterTaskLoopDirective", :doc "/** OpenMP master taskloop directive.\n   */", :value 281} {:name "CXCursor_OMPParallelMasterTaskLoopDirective", :doc "/** OpenMP parallel master taskloop directive.\n   */", :value 282} {:name "CXCursor_OMPMasterTaskLoopSimdDirective", :doc "/** OpenMP master taskloop simd directive.\n   */", :value 283} {:name "CXCursor_OMPParallelMasterTaskLoopSimdDirective", :doc "/** OpenMP parallel master taskloop simd directive.\n   */", :value 284} {:name "CXCursor_OMPParallelMasterDirective", :doc "/** OpenMP parallel master directive.\n   */", :value 285} {:name "CXCursor_OMPDepobjDirective", :doc "/** OpenMP depobj directive.\n   */", :value 286} {:name "CXCursor_OMPScanDirective", :doc "/** OpenMP scan directive.\n   */", :value 287} {:name "CXCursor_OMPTileDirective", :doc "/** OpenMP tile directive.\n   */", :value 288} {:name "CXCursor_OMPCanonicalLoop", :doc "/** OpenMP canonical loop.\n   */", :value 289} {:name "CXCursor_OMPInteropDirective", :doc "/** OpenMP interop directive.\n   */", :value 290} {:name "CXCursor_OMPDispatchDirective", :doc "/** OpenMP dispatch directive.\n   */", :value 291} {:name "CXCursor_OMPMaskedDirective", :doc "/** OpenMP masked directive.\n   */", :value 292} {:name "CXCursor_OMPUnrollDirective", :doc "/** OpenMP unroll directive.\n   */", :value 293} {:name "CXCursor_LastStmt", :doc "/** OpenMP unroll directive.\n   */", :value 293} {:name "CXCursor_TranslationUnit", :doc "/**\n   * Cursor that represents the translation unit itself.\n   *\n   * The translation unit cursor exists primarily to act as the root\n   * cursor for traversing the contents of a translation unit.\n   */", :value 300} {:name "CXCursor_FirstAttr", :doc "/**\n   * Cursor that represents the translation unit itself.\n   *\n   * The translation unit cursor exists primarily to act as the root\n   * cursor for traversing the contents of a translation unit.\n   */", :value 400} {:name "CXCursor_UnexposedAttr", :doc "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */", :value 400} {:name "CXCursor_IBActionAttr", :doc "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */", :value 401} {:name "CXCursor_IBOutletAttr", :doc "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */", :value 402} {:name "CXCursor_IBOutletCollectionAttr", :doc "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */", :value 403} {:name "CXCursor_CXXFinalAttr", :doc "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */", :value 404} {:name "CXCursor_CXXOverrideAttr", :doc "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */", :value 405} {:name "CXCursor_AnnotateAttr", :doc "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */", :value 406} {:name "CXCursor_AsmLabelAttr", :doc "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */", :value 407} {:name "CXCursor_PackedAttr", :doc "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */", :value 408} {:name "CXCursor_PureAttr", :doc "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */", :value 409} {:name "CXCursor_ConstAttr", :doc "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */", :value 410} {:name "CXCursor_NoDuplicateAttr", :doc "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */", :value 411} {:name "CXCursor_CUDAConstantAttr", :doc "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */", :value 412} {:name "CXCursor_CUDADeviceAttr", :doc "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */", :value 413} {:name "CXCursor_CUDAGlobalAttr", :doc "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */", :value 414} {:name "CXCursor_CUDAHostAttr", :doc "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */", :value 415} {:name "CXCursor_CUDASharedAttr", :doc "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */", :value 416} {:name "CXCursor_VisibilityAttr", :doc "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */", :value 417} {:name "CXCursor_DLLExport", :doc "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */", :value 418} {:name "CXCursor_DLLImport", :doc "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */", :value 419} {:name "CXCursor_NSReturnsRetained", :doc "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */", :value 420} {:name "CXCursor_NSReturnsNotRetained", :doc "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */", :value 421} {:name "CXCursor_NSReturnsAutoreleased", :doc "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */", :value 422} {:name "CXCursor_NSConsumesSelf", :doc "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */", :value 423} {:name "CXCursor_NSConsumed", :doc "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */", :value 424} {:name "CXCursor_ObjCException", :doc "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */", :value 425} {:name "CXCursor_ObjCNSObject", :doc "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */", :value 426} {:name "CXCursor_ObjCIndependentClass", :doc "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */", :value 427} {:name "CXCursor_ObjCPreciseLifetime", :doc "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */", :value 428} {:name "CXCursor_ObjCReturnsInnerPointer", :doc "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */", :value 429} {:name "CXCursor_ObjCRequiresSuper", :doc "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */", :value 430} {:name "CXCursor_ObjCRootClass", :doc "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */", :value 431} {:name "CXCursor_ObjCSubclassingRestricted", :doc "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */", :value 432} {:name "CXCursor_ObjCExplicitProtocolImpl", :doc "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */", :value 433} {:name "CXCursor_ObjCDesignatedInitializer", :doc "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */", :value 434} {:name "CXCursor_ObjCRuntimeVisible", :doc "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */", :value 435} {:name "CXCursor_ObjCBoxable", :doc "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */", :value 436} {:name "CXCursor_FlagEnum", :doc "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */", :value 437} {:name "CXCursor_ConvergentAttr", :doc "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */", :value 438} {:name "CXCursor_WarnUnusedAttr", :doc "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */", :value 439} {:name "CXCursor_WarnUnusedResultAttr", :doc "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */", :value 440} {:name "CXCursor_AlignedAttr", :doc "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */", :value 441} {:name "CXCursor_LastAttr", :doc "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */", :value 441} {:name "CXCursor_PreprocessingDirective", :doc "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */", :value 500} {:name "CXCursor_MacroDefinition", :doc "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */", :value 501} {:name "CXCursor_MacroExpansion", :doc "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */", :value 502} {:name "CXCursor_MacroInstantiation", :doc "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */", :value 502} {:name "CXCursor_InclusionDirective", :doc "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */", :value 503} {:name "CXCursor_FirstPreprocessing", :doc "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */", :value 500} {:name "CXCursor_LastPreprocessing", :doc "/**\n   * An attribute whose specific kind is not exposed via this\n   * interface.\n   */", :value 503} {:name "CXCursor_ModuleImportDecl", :doc "/**\n   * A module import declaration.\n   */", :value 600} {:name "CXCursor_TypeAliasTemplateDecl", :doc "/**\n   * A module import declaration.\n   */", :value 601} {:name "CXCursor_StaticAssert", :doc "/**\n   * A static_assert or _Static_assert node\n   */", :value 602} {:name "CXCursor_FriendDecl", :doc "/**\n   * a friend declaration.\n   */", :value 603} {:name "CXCursor_FirstExtraDecl", :doc "/**\n   * a friend declaration.\n   */", :value 600} {:name "CXCursor_LastExtraDecl", :doc "/**\n   * a friend declaration.\n   */", :value 603} {:name "CXCursor_OverloadCandidate", :doc "/**\n   * A code completion overload candidate.\n   */", :value 700} {:name "CXLinkage_Invalid", :doc "/** This value indicates that no linkage information is available\n   * for a provided CXCursor. */", :value 0} {:name "CXLinkage_NoLinkage", :doc "/**\n   * This is the linkage for variables, parameters, and so on that\n   *  have automatic storage.  This covers normal (non-extern) local variables.\n   */", :value 1} {:name "CXLinkage_Internal", :doc "/** This is the linkage for static variables and static functions. */", :value 2} {:name "CXLinkage_UniqueExternal", :doc "/** This is the linkage for entities with external linkage that live\n   * in C++ anonymous namespaces.*/", :value 3} {:name "CXLinkage_External", :doc "/** This is the linkage for entities with true, external linkage. */", :value 4} {:name "CXVisibility_Invalid", :doc "/** This value indicates that no visibility information is available\n   * for a provided CXCursor. */", :value 0} {:name "CXVisibility_Hidden", :doc "/** Symbol not seen by the linker. */", :value 1} {:name "CXVisibility_Protected", :doc "/** Symbol seen by the linker but resolves to a symbol inside this object. */", :value 2} {:name "CXVisibility_Default", :doc "/** Symbol seen by the linker and acts like a normal symbol. */", :value 3} {:name "CXLanguage_Invalid", :doc nil, :value 0} {:name "CXLanguage_C", :doc nil, :value 1} {:name "CXLanguage_ObjC", :doc nil, :value 2} {:name "CXLanguage_CPlusPlus", :doc nil, :value 3} {:name "CXTLS_None", :doc nil, :value 0} {:name "CXTLS_Dynamic", :doc nil, :value 1} {:name "CXTLS_Static", :doc nil, :value 2} {:name "CXType_Invalid", :doc "/**\n   * Represents an invalid type (e.g., where no type is available).\n   */", :value 0} {:name "CXType_Unexposed", :doc "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */", :value 1} {:name "CXType_Void", :doc "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */", :value 2} {:name "CXType_Bool", :doc "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */", :value 3} {:name "CXType_Char_U", :doc "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */", :value 4} {:name "CXType_UChar", :doc "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */", :value 5} {:name "CXType_Char16", :doc "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */", :value 6} {:name "CXType_Char32", :doc "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */", :value 7} {:name "CXType_UShort", :doc "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */", :value 8} {:name "CXType_UInt", :doc "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */", :value 9} {:name "CXType_ULong", :doc "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */", :value 10} {:name "CXType_ULongLong", :doc "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */", :value 11} {:name "CXType_UInt128", :doc "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */", :value 12} {:name "CXType_Char_S", :doc "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */", :value 13} {:name "CXType_SChar", :doc "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */", :value 14} {:name "CXType_WChar", :doc "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */", :value 15} {:name "CXType_Short", :doc "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */", :value 16} {:name "CXType_Int", :doc "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */", :value 17} {:name "CXType_Long", :doc "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */", :value 18} {:name "CXType_LongLong", :doc "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */", :value 19} {:name "CXType_Int128", :doc "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */", :value 20} {:name "CXType_Float", :doc "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */", :value 21} {:name "CXType_Double", :doc "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */", :value 22} {:name "CXType_LongDouble", :doc "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */", :value 23} {:name "CXType_NullPtr", :doc "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */", :value 24} {:name "CXType_Overload", :doc "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */", :value 25} {:name "CXType_Dependent", :doc "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */", :value 26} {:name "CXType_ObjCId", :doc "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */", :value 27} {:name "CXType_ObjCClass", :doc "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */", :value 28} {:name "CXType_ObjCSel", :doc "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */", :value 29} {:name "CXType_Float128", :doc "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */", :value 30} {:name "CXType_Half", :doc "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */", :value 31} {:name "CXType_Float16", :doc "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */", :value 32} {:name "CXType_ShortAccum", :doc "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */", :value 33} {:name "CXType_Accum", :doc "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */", :value 34} {:name "CXType_LongAccum", :doc "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */", :value 35} {:name "CXType_UShortAccum", :doc "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */", :value 36} {:name "CXType_UAccum", :doc "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */", :value 37} {:name "CXType_ULongAccum", :doc "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */", :value 38} {:name "CXType_BFloat16", :doc "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */", :value 39} {:name "CXType_FirstBuiltin", :doc "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */", :value 2} {:name "CXType_LastBuiltin", :doc "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */", :value 39} {:name "CXType_Complex", :doc "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */", :value 100} {:name "CXType_Pointer", :doc "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */", :value 101} {:name "CXType_BlockPointer", :doc "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */", :value 102} {:name "CXType_LValueReference", :doc "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */", :value 103} {:name "CXType_RValueReference", :doc "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */", :value 104} {:name "CXType_Record", :doc "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */", :value 105} {:name "CXType_Enum", :doc "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */", :value 106} {:name "CXType_Typedef", :doc "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */", :value 107} {:name "CXType_ObjCInterface", :doc "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */", :value 108} {:name "CXType_ObjCObjectPointer", :doc "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */", :value 109} {:name "CXType_FunctionNoProto", :doc "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */", :value 110} {:name "CXType_FunctionProto", :doc "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */", :value 111} {:name "CXType_ConstantArray", :doc "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */", :value 112} {:name "CXType_Vector", :doc "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */", :value 113} {:name "CXType_IncompleteArray", :doc "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */", :value 114} {:name "CXType_VariableArray", :doc "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */", :value 115} {:name "CXType_DependentSizedArray", :doc "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */", :value 116} {:name "CXType_MemberPointer", :doc "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */", :value 117} {:name "CXType_Auto", :doc "/**\n   * A type whose specific kind is not exposed via this\n   * interface.\n   */", :value 118} {:name "CXType_Elaborated", :doc "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */", :value 119} {:name "CXType_Pipe", :doc "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */", :value 120} {:name "CXType_OCLImage1dRO", :doc "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */", :value 121} {:name "CXType_OCLImage1dArrayRO", :doc "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */", :value 122} {:name "CXType_OCLImage1dBufferRO", :doc "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */", :value 123} {:name "CXType_OCLImage2dRO", :doc "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */", :value 124} {:name "CXType_OCLImage2dArrayRO", :doc "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */", :value 125} {:name "CXType_OCLImage2dDepthRO", :doc "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */", :value 126} {:name "CXType_OCLImage2dArrayDepthRO", :doc "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */", :value 127} {:name "CXType_OCLImage2dMSAARO", :doc "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */", :value 128} {:name "CXType_OCLImage2dArrayMSAARO", :doc "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */", :value 129} {:name "CXType_OCLImage2dMSAADepthRO", :doc "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */", :value 130} {:name "CXType_OCLImage2dArrayMSAADepthRO", :doc "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */", :value 131} {:name "CXType_OCLImage3dRO", :doc "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */", :value 132} {:name "CXType_OCLImage1dWO", :doc "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */", :value 133} {:name "CXType_OCLImage1dArrayWO", :doc "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */", :value 134} {:name "CXType_OCLImage1dBufferWO", :doc "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */", :value 135} {:name "CXType_OCLImage2dWO", :doc "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */", :value 136} {:name "CXType_OCLImage2dArrayWO", :doc "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */", :value 137} {:name "CXType_OCLImage2dDepthWO", :doc "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */", :value 138} {:name "CXType_OCLImage2dArrayDepthWO", :doc "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */", :value 139} {:name "CXType_OCLImage2dMSAAWO", :doc "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */", :value 140} {:name "CXType_OCLImage2dArrayMSAAWO", :doc "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */", :value 141} {:name "CXType_OCLImage2dMSAADepthWO", :doc "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */", :value 142} {:name "CXType_OCLImage2dArrayMSAADepthWO", :doc "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */", :value 143} {:name "CXType_OCLImage3dWO", :doc "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */", :value 144} {:name "CXType_OCLImage1dRW", :doc "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */", :value 145} {:name "CXType_OCLImage1dArrayRW", :doc "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */", :value 146} {:name "CXType_OCLImage1dBufferRW", :doc "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */", :value 147} {:name "CXType_OCLImage2dRW", :doc "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */", :value 148} {:name "CXType_OCLImage2dArrayRW", :doc "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */", :value 149} {:name "CXType_OCLImage2dDepthRW", :doc "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */", :value 150} {:name "CXType_OCLImage2dArrayDepthRW", :doc "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */", :value 151} {:name "CXType_OCLImage2dMSAARW", :doc "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */", :value 152} {:name "CXType_OCLImage2dArrayMSAARW", :doc "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */", :value 153} {:name "CXType_OCLImage2dMSAADepthRW", :doc "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */", :value 154} {:name "CXType_OCLImage2dArrayMSAADepthRW", :doc "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */", :value 155} {:name "CXType_OCLImage3dRW", :doc "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */", :value 156} {:name "CXType_OCLSampler", :doc "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */", :value 157} {:name "CXType_OCLEvent", :doc "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */", :value 158} {:name "CXType_OCLQueue", :doc "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */", :value 159} {:name "CXType_OCLReserveID", :doc "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */", :value 160} {:name "CXType_ObjCObject", :doc "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */", :value 161} {:name "CXType_ObjCTypeParam", :doc "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */", :value 162} {:name "CXType_Attributed", :doc "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */", :value 163} {:name "CXType_OCLIntelSubgroupAVCMcePayload", :doc "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */", :value 164} {:name "CXType_OCLIntelSubgroupAVCImePayload", :doc "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */", :value 165} {:name "CXType_OCLIntelSubgroupAVCRefPayload", :doc "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */", :value 166} {:name "CXType_OCLIntelSubgroupAVCSicPayload", :doc "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */", :value 167} {:name "CXType_OCLIntelSubgroupAVCMceResult", :doc "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */", :value 168} {:name "CXType_OCLIntelSubgroupAVCImeResult", :doc "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */", :value 169} {:name "CXType_OCLIntelSubgroupAVCRefResult", :doc "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */", :value 170} {:name "CXType_OCLIntelSubgroupAVCSicResult", :doc "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */", :value 171} {:name "CXType_OCLIntelSubgroupAVCImeResultSingleRefStreamout", :doc "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */", :value 172} {:name "CXType_OCLIntelSubgroupAVCImeResultDualRefStreamout", :doc "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */", :value 173} {:name "CXType_OCLIntelSubgroupAVCImeSingleRefStreamin", :doc "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */", :value 174} {:name "CXType_OCLIntelSubgroupAVCImeDualRefStreamin", :doc "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */", :value 175} {:name "CXType_ExtVector", :doc "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */", :value 176} {:name "CXType_Atomic", :doc "/**\n   * Represents a type that was referred to using an elaborated type keyword.\n   *\n   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.\n   */", :value 177} {:name "CXCallingConv_Default", :doc nil, :value 0} {:name "CXCallingConv_C", :doc nil, :value 1} {:name "CXCallingConv_X86StdCall", :doc nil, :value 2} {:name "CXCallingConv_X86FastCall", :doc nil, :value 3} {:name "CXCallingConv_X86ThisCall", :doc nil, :value 4} {:name "CXCallingConv_X86Pascal", :doc nil, :value 5} {:name "CXCallingConv_AAPCS", :doc nil, :value 6} {:name "CXCallingConv_AAPCS_VFP", :doc nil, :value 7} {:name "CXCallingConv_X86RegCall", :doc nil, :value 8} {:name "CXCallingConv_IntelOclBicc", :doc nil, :value 9} {:name "CXCallingConv_Win64", :doc nil, :value 10} {:name "CXCallingConv_X86_64Win64", :doc nil, :value 10} {:name "CXCallingConv_X86_64SysV", :doc nil, :value 11} {:name "CXCallingConv_X86VectorCall", :doc nil, :value 12} {:name "CXCallingConv_Swift", :doc nil, :value 13} {:name "CXCallingConv_PreserveMost", :doc nil, :value 14} {:name "CXCallingConv_PreserveAll", :doc nil, :value 15} {:name "CXCallingConv_AArch64VectorCall", :doc nil, :value 16} {:name "CXCallingConv_SwiftAsync", :doc nil, :value 17} {:name "CXCallingConv_Invalid", :doc nil, :value 100} {:name "CXCallingConv_Unexposed", :doc nil, :value 200} {:name "CXTemplateArgumentKind_Null", :doc nil, :value 0} {:name "CXTemplateArgumentKind_Type", :doc nil, :value 1} {:name "CXTemplateArgumentKind_Declaration", :doc nil, :value 2} {:name "CXTemplateArgumentKind_NullPtr", :doc nil, :value 3} {:name "CXTemplateArgumentKind_Integral", :doc nil, :value 4} {:name "CXTemplateArgumentKind_Template", :doc nil, :value 5} {:name "CXTemplateArgumentKind_TemplateExpansion", :doc nil, :value 6} {:name "CXTemplateArgumentKind_Expression", :doc nil, :value 7} {:name "CXTemplateArgumentKind_Pack", :doc nil, :value 8} {:name "CXTemplateArgumentKind_Invalid", :doc nil, :value 9} {:name "CXTypeNullability_NonNull", :doc "/**\n   * Values of this type can never be null.\n   */", :value 0} {:name "CXTypeNullability_Nullable", :doc "/**\n   * Values of this type can be null.\n   */", :value 1} {:name "CXTypeNullability_Unspecified", :doc "/**\n   * Whether values of this type can be null is (explicitly)\n   * unspecified. This captures a (fairly rare) case where we\n   * can't conclude anything about the nullability of the type even\n   * though it has been considered.\n   */", :value 2} {:name "CXTypeNullability_Invalid", :doc "/**\n   * Nullability is not applicable to this type.\n   */", :value 3} {:name "CXTypeNullability_NullableResult", :doc "/**\n   * Generally behaves like Nullable, except when used in a block parameter that\n   * was imported into a swift async method. There, swift will assume that the\n   * parameter can get null even if no error occured. _Nullable parameters are\n   * assumed to only get null on error.\n   */", :value 4} {:name "CXTypeLayoutError_Invalid", :doc "/**\n   * Type is of kind CXType_Invalid.\n   */", :value -1} {:name "CXTypeLayoutError_Incomplete", :doc "/**\n   * The type is an incomplete Type.\n   */", :value -2} {:name "CXTypeLayoutError_Dependent", :doc "/**\n   * The type is a dependent Type.\n   */", :value -3} {:name "CXTypeLayoutError_NotConstantSize", :doc "/**\n   * The type is not a constant size type.\n   */", :value -4} {:name "CXTypeLayoutError_InvalidFieldName", :doc "/**\n   * The Field name is not valid for this record.\n   */", :value -5} {:name "CXTypeLayoutError_Undeduced", :doc "/**\n   * The type is undeduced.\n   */", :value -6} {:name "CXRefQualifier_None", :doc "/** No ref-qualifier was provided. */", :value 0} {:name "CXRefQualifier_LValue", :doc "/** An lvalue ref-qualifier was provided (\\c &). */", :value 1} {:name "CXRefQualifier_RValue", :doc "/** An rvalue ref-qualifier was provided (\\c &&). */", :value 2} {:name "CX_CXXInvalidAccessSpecifier", :doc nil, :value 0} {:name "CX_CXXPublic", :doc nil, :value 1} {:name "CX_CXXProtected", :doc nil, :value 2} {:name "CX_CXXPrivate", :doc nil, :value 3} {:name "CX_SC_Invalid", :doc nil, :value 0} {:name "CX_SC_None", :doc nil, :value 1} {:name "CX_SC_Extern", :doc nil, :value 2} {:name "CX_SC_Static", :doc nil, :value 3} {:name "CX_SC_PrivateExtern", :doc nil, :value 4} {:name "CX_SC_OpenCLWorkGroupLocal", :doc nil, :value 5} {:name "CX_SC_Auto", :doc nil, :value 6} {:name "CX_SC_Register", :doc nil, :value 7} {:name "CXChildVisit_Break", :doc "/**\n   * Terminates the cursor traversal.\n   */", :value 0} {:name "CXChildVisit_Continue", :doc "/**\n   * Continues the cursor traversal with the next sibling of\n   * the cursor just visited, without visiting its children.\n   */", :value 1} {:name "CXChildVisit_Recurse", :doc "/**\n   * Recursively traverse the children of this cursor, using\n   * the same visitor and client data.\n   */", :value 2} {:name "CXPrintingPolicy_Indentation", :doc nil, :value 0} {:name "CXPrintingPolicy_SuppressSpecifiers", :doc nil, :value 1} {:name "CXPrintingPolicy_SuppressTagKeyword", :doc nil, :value 2} {:name "CXPrintingPolicy_IncludeTagDefinition", :doc nil, :value 3} {:name "CXPrintingPolicy_SuppressScope", :doc nil, :value 4} {:name "CXPrintingPolicy_SuppressUnwrittenScope", :doc nil, :value 5} {:name "CXPrintingPolicy_SuppressInitializers", :doc nil, :value 6} {:name "CXPrintingPolicy_ConstantArraySizeAsWritten", :doc nil, :value 7} {:name "CXPrintingPolicy_AnonymousTagLocations", :doc nil, :value 8} {:name "CXPrintingPolicy_SuppressStrongLifetime", :doc nil, :value 9} {:name "CXPrintingPolicy_SuppressLifetimeQualifiers", :doc nil, :value 10} {:name "CXPrintingPolicy_SuppressTemplateArgsInCXXConstructors", :doc nil, :value 11} {:name "CXPrintingPolicy_Bool", :doc nil, :value 12} {:name "CXPrintingPolicy_Restrict", :doc nil, :value 13} {:name "CXPrintingPolicy_Alignof", :doc nil, :value 14} {:name "CXPrintingPolicy_UnderscoreAlignof", :doc nil, :value 15} {:name "CXPrintingPolicy_UseVoidForZeroParams", :doc nil, :value 16} {:name "CXPrintingPolicy_TerseOutput", :doc nil, :value 17} {:name "CXPrintingPolicy_PolishForDeclaration", :doc nil, :value 18} {:name "CXPrintingPolicy_Half", :doc nil, :value 19} {:name "CXPrintingPolicy_MSWChar", :doc nil, :value 20} {:name "CXPrintingPolicy_IncludeNewlines", :doc nil, :value 21} {:name "CXPrintingPolicy_MSVCFormatting", :doc nil, :value 22} {:name "CXPrintingPolicy_ConstantsAsWritten", :doc nil, :value 23} {:name "CXPrintingPolicy_SuppressImplicitBase", :doc nil, :value 24} {:name "CXPrintingPolicy_FullyQualifiedName", :doc nil, :value 25} {:name "CXPrintingPolicy_LastProperty", :doc nil, :value 25} {:name "CXObjCPropertyAttr_noattr", :doc nil, :value 0} {:name "CXObjCPropertyAttr_readonly", :doc nil, :value 1} {:name "CXObjCPropertyAttr_getter", :doc nil, :value 2} {:name "CXObjCPropertyAttr_assign", :doc nil, :value 4} {:name "CXObjCPropertyAttr_readwrite", :doc nil, :value 8} {:name "CXObjCPropertyAttr_retain", :doc nil, :value 16} {:name "CXObjCPropertyAttr_copy", :doc nil, :value 32} {:name "CXObjCPropertyAttr_nonatomic", :doc nil, :value 64} {:name "CXObjCPropertyAttr_setter", :doc nil, :value 128} {:name "CXObjCPropertyAttr_atomic", :doc nil, :value 256} {:name "CXObjCPropertyAttr_weak", :doc nil, :value 512} {:name "CXObjCPropertyAttr_strong", :doc nil, :value 1024} {:name "CXObjCPropertyAttr_unsafe_unretained", :doc nil, :value 2048} {:name "CXObjCPropertyAttr_class", :doc nil, :value 4096} {:name "CXObjCPropertyAttr_noattr", :doc nil, :value 0} {:name "CXObjCPropertyAttr_readonly", :doc nil, :value 1} {:name "CXObjCPropertyAttr_getter", :doc nil, :value 2} {:name "CXObjCPropertyAttr_assign", :doc nil, :value 4} {:name "CXObjCPropertyAttr_readwrite", :doc nil, :value 8} {:name "CXObjCPropertyAttr_retain", :doc nil, :value 16} {:name "CXObjCPropertyAttr_copy", :doc nil, :value 32} {:name "CXObjCPropertyAttr_nonatomic", :doc nil, :value 64} {:name "CXObjCPropertyAttr_setter", :doc nil, :value 128} {:name "CXObjCPropertyAttr_atomic", :doc nil, :value 256} {:name "CXObjCPropertyAttr_weak", :doc nil, :value 512} {:name "CXObjCPropertyAttr_strong", :doc nil, :value 1024} {:name "CXObjCPropertyAttr_unsafe_unretained", :doc nil, :value 2048} {:name "CXObjCPropertyAttr_class", :doc nil, :value 4096} {:name "CXObjCDeclQualifier_None", :doc nil, :value 0} {:name "CXObjCDeclQualifier_In", :doc nil, :value 1} {:name "CXObjCDeclQualifier_Inout", :doc nil, :value 2} {:name "CXObjCDeclQualifier_Out", :doc nil, :value 4} {:name "CXObjCDeclQualifier_Bycopy", :doc nil, :value 8} {:name "CXObjCDeclQualifier_Byref", :doc nil, :value 16} {:name "CXObjCDeclQualifier_Oneway", :doc nil, :value 32} {:name "CXObjCDeclQualifier_None", :doc nil, :value 0} {:name "CXObjCDeclQualifier_In", :doc nil, :value 1} {:name "CXObjCDeclQualifier_Inout", :doc nil, :value 2} {:name "CXObjCDeclQualifier_Out", :doc nil, :value 4} {:name "CXObjCDeclQualifier_Bycopy", :doc nil, :value 8} {:name "CXObjCDeclQualifier_Byref", :doc nil, :value 16} {:name "CXObjCDeclQualifier_Oneway", :doc nil, :value 32} {:name "CXNameRange_WantQualifier", :doc "/**\n   * Include the nested-name-specifier, e.g. Foo:: in x.Foo::y, in the\n   * range.\n   */", :value 1} {:name "CXNameRange_WantTemplateArgs", :doc "/**\n   * Include the explicit template arguments, e.g. \\<int> in x.f<int>,\n   * in the range.\n   */", :value 2} {:name "CXNameRange_WantSinglePiece", :doc "/**\n   * If the name is non-contiguous, return the full spanning range.\n   *\n   * Non-contiguous names occur in Objective-C when a selector with two or more\n   * parameters is used, or in C++ when using an operator:\n   * \\code\n   * [object doSomething:here withValue:there]; // Objective-C\n   * return some_vector[1]; // C++\n   * \\endcode\n   */", :value 4} {:name "CXToken_Punctuation", :doc "/**\n   * A token that contains some kind of punctuation.\n   */", :value 0} {:name "CXToken_Keyword", :doc "/**\n   * A language keyword.\n   */", :value 1} {:name "CXToken_Identifier", :doc "/**\n   * An identifier (that is not a keyword).\n   */", :value 2} {:name "CXToken_Literal", :doc "/**\n   * A numeric, string, or character literal.\n   */", :value 3} {:name "CXToken_Comment", :doc "/**\n   * A comment.\n   */", :value 4} {:name "CXToken_Punctuation", :doc "/**\n   * A token that contains some kind of punctuation.\n   */", :value 0} {:name "CXToken_Keyword", :doc "/**\n   * A language keyword.\n   */", :value 1} {:name "CXToken_Identifier", :doc "/**\n   * An identifier (that is not a keyword).\n   */", :value 2} {:name "CXToken_Literal", :doc "/**\n   * A numeric, string, or character literal.\n   */", :value 3} {:name "CXToken_Comment", :doc "/**\n   * A comment.\n   */", :value 4} {:name "CXCompletionChunk_Optional", :doc "/**\n   * A code-completion string that describes \"optional\" text that\n   * could be a part of the template (but is not required).\n   *\n   * The Optional chunk is the only kind of chunk that has a code-completion\n   * string for its representation, which is accessible via\n   * \\c clang_getCompletionChunkCompletionString(). The code-completion string\n   * describes an additional part of the template that is completely optional.\n   * For example, optional chunks can be used to describe the placeholders for\n   * arguments that match up with defaulted function parameters, e.g. given:\n   *\n   * \\code\n   * void f(int x, float y = 3.14, double z = 2.71828);\n   * \\endcode\n   *\n   * The code-completion string for this function would contain:\n   *   - a TypedText chunk for \"f\".\n   *   - a LeftParen chunk for \"(\".\n   *   - a Placeholder chunk for \"int x\"\n   *   - an Optional chunk containing the remaining defaulted arguments, e.g.,\n   *       - a Comma chunk for \",\"\n   *       - a Placeholder chunk for \"float y\"\n   *       - an Optional chunk containing the last defaulted argument:\n   *           - a Comma chunk for \",\"\n   *           - a Placeholder chunk for \"double z\"\n   *   - a RightParen chunk for \")\"\n   *\n   * There are many ways to handle Optional chunks. Two simple approaches are:\n   *   - Completely ignore optional chunks, in which case the template for the\n   *     function \"f\" would only include the first parameter (\"int x\").\n   *   - Fully expand all optional chunks, in which case the template for the\n   *     function \"f\" would have all of the parameters.\n   */", :value 0} {:name "CXCompletionChunk_TypedText", :doc "/**\n   * Text that a user would be expected to type to get this\n   * code-completion result.\n   *\n   * There will be exactly one \"typed text\" chunk in a semantic string, which\n   * will typically provide the spelling of a keyword or the name of a\n   * declaration that could be used at the current code point. Clients are\n   * expected to filter the code-completion results based on the text in this\n   * chunk.\n   */", :value 1} {:name "CXCompletionChunk_Text", :doc "/**\n   * Text that should be inserted as part of a code-completion result.\n   *\n   * A \"text\" chunk represents text that is part of the template to be\n   * inserted into user code should this particular code-completion result\n   * be selected.\n   */", :value 2} {:name "CXCompletionChunk_Placeholder", :doc "/**\n   * Placeholder text that should be replaced by the user.\n   *\n   * A \"placeholder\" chunk marks a place where the user should insert text\n   * into the code-completion template. For example, placeholders might mark\n   * the function parameters for a function declaration, to indicate that the\n   * user should provide arguments for each of those parameters. The actual\n   * text in a placeholder is a suggestion for the text to display before\n   * the user replaces the placeholder with real code.\n   */", :value 3} {:name "CXCompletionChunk_Informative", :doc "/**\n   * Informative text that should be displayed but never inserted as\n   * part of the template.\n   *\n   * An \"informative\" chunk contains annotations that can be displayed to\n   * help the user decide whether a particular code-completion result is the\n   * right option, but which is not part of the actual template to be inserted\n   * by code completion.\n   */", :value 4} {:name "CXCompletionChunk_CurrentParameter", :doc "/**\n   * Text that describes the current parameter when code-completion is\n   * referring to function call, message send, or template specialization.\n   *\n   * A \"current parameter\" chunk occurs when code-completion is providing\n   * information about a parameter corresponding to the argument at the\n   * code-completion point. For example, given a function\n   *\n   * \\code\n   * int add(int x, int y);\n   * \\endcode\n   *\n   * and the source code \\c add(, where the code-completion point is after the\n   * \"(\", the code-completion string will contain a \"current parameter\" chunk\n   * for \"int x\", indicating that the current argument will initialize that\n   * parameter. After typing further, to \\c add(17, (where the code-completion\n   * point is after the \",\"), the code-completion string will contain a\n   * \"current parameter\" chunk to \"int y\".\n   */", :value 5} {:name "CXCompletionChunk_LeftParen", :doc "/**\n   * A left parenthesis ('('), used to initiate a function call or\n   * signal the beginning of a function parameter list.\n   */", :value 6} {:name "CXCompletionChunk_RightParen", :doc "/**\n   * A right parenthesis (')'), used to finish a function call or\n   * signal the end of a function parameter list.\n   */", :value 7} {:name "CXCompletionChunk_LeftBracket", :doc "/**\n   * A left bracket ('[').\n   */", :value 8} {:name "CXCompletionChunk_RightBracket", :doc "/**\n   * A right bracket (']').\n   */", :value 9} {:name "CXCompletionChunk_LeftBrace", :doc "/**\n   * A left brace ('{').\n   */", :value 10} {:name "CXCompletionChunk_RightBrace", :doc "/**\n   * A right brace ('}').\n   */", :value 11} {:name "CXCompletionChunk_LeftAngle", :doc "/**\n   * A left angle bracket ('<').\n   */", :value 12} {:name "CXCompletionChunk_RightAngle", :doc "/**\n   * A right angle bracket ('>').\n   */", :value 13} {:name "CXCompletionChunk_Comma", :doc "/**\n   * A comma separator (',').\n   */", :value 14} {:name "CXCompletionChunk_ResultType", :doc "/**\n   * Text that specifies the result type of a given result.\n   *\n   * This special kind of informative chunk is not meant to be inserted into\n   * the text buffer. Rather, it is meant to illustrate the type that an\n   * expression using the given completion string would have.\n   */", :value 15} {:name "CXCompletionChunk_Colon", :doc "/**\n   * A colon (':').\n   */", :value 16} {:name "CXCompletionChunk_SemiColon", :doc "/**\n   * A semicolon (';').\n   */", :value 17} {:name "CXCompletionChunk_Equal", :doc "/**\n   * An '=' sign.\n   */", :value 18} {:name "CXCompletionChunk_HorizontalSpace", :doc "/**\n   * Horizontal space (' ').\n   */", :value 19} {:name "CXCompletionChunk_VerticalSpace", :doc "/**\n   * Vertical space ('\\\\n'), after which it is generally a good idea to\n   * perform indentation.\n   */", :value 20} {:name "CXCodeComplete_IncludeMacros", :doc "/**\n   * Whether to include macros within the set of code\n   * completions returned.\n   */", :value 1} {:name "CXCodeComplete_IncludeCodePatterns", :doc "/**\n   * Whether to include code patterns for language constructs\n   * within the set of code completions, e.g., for loops.\n   */", :value 2} {:name "CXCodeComplete_IncludeBriefComments", :doc "/**\n   * Whether to include brief documentation within the set of code\n   * completions returned.\n   */", :value 4} {:name "CXCodeComplete_SkipPreamble", :doc "/**\n   * Whether to speed up completion by omitting top- or namespace-level entities\n   * defined in the preamble. There's no guarantee any particular entity is\n   * omitted. This may be useful if the headers are indexed externally.\n   */", :value 8} {:name "CXCodeComplete_IncludeCompletionsWithFixIts", :doc "/**\n   * Whether to include completions with small\n   * fix-its, e.g. change '.' to '->' on member access, etc.\n   */", :value 16} {:name "CXCompletionContext_Unexposed", :doc "/**\n   * The context for completions is unexposed, as only Clang results\n   * should be included. (This is equivalent to having no context bits set.)\n   */", :value 0} {:name "CXCompletionContext_AnyType", :doc "/**\n   * Completions for any possible type should be included in the results.\n   */", :value 1} {:name "CXCompletionContext_AnyValue", :doc "/**\n   * Completions for any possible value (variables, function calls, etc.)\n   * should be included in the results.\n   */", :value 2} {:name "CXCompletionContext_ObjCObjectValue", :doc "/**\n   * Completions for values that resolve to an Objective-C object should\n   * be included in the results.\n   */", :value 4} {:name "CXCompletionContext_ObjCSelectorValue", :doc "/**\n   * Completions for values that resolve to an Objective-C selector\n   * should be included in the results.\n   */", :value 8} {:name "CXCompletionContext_CXXClassTypeValue", :doc "/**\n   * Completions for values that resolve to a C++ class type should be\n   * included in the results.\n   */", :value 16} {:name "CXCompletionContext_DotMemberAccess", :doc "/**\n   * Completions for fields of the member being accessed using the dot\n   * operator should be included in the results.\n   */", :value 32} {:name "CXCompletionContext_ArrowMemberAccess", :doc "/**\n   * Completions for fields of the member being accessed using the arrow\n   * operator should be included in the results.\n   */", :value 64} {:name "CXCompletionContext_ObjCPropertyAccess", :doc "/**\n   * Completions for properties of the Objective-C object being accessed\n   * using the dot operator should be included in the results.\n   */", :value 128} {:name "CXCompletionContext_EnumTag", :doc "/**\n   * Completions for enum tags should be included in the results.\n   */", :value 256} {:name "CXCompletionContext_UnionTag", :doc "/**\n   * Completions for union tags should be included in the results.\n   */", :value 512} {:name "CXCompletionContext_StructTag", :doc "/**\n   * Completions for struct tags should be included in the results.\n   */", :value 1024} {:name "CXCompletionContext_ClassTag", :doc "/**\n   * Completions for C++ class names should be included in the results.\n   */", :value 2048} {:name "CXCompletionContext_Namespace", :doc "/**\n   * Completions for C++ namespaces and namespace aliases should be\n   * included in the results.\n   */", :value 4096} {:name "CXCompletionContext_NestedNameSpecifier", :doc "/**\n   * Completions for C++ nested name specifiers should be included in\n   * the results.\n   */", :value 8192} {:name "CXCompletionContext_ObjCInterface", :doc "/**\n   * Completions for Objective-C interfaces (classes) should be included\n   * in the results.\n   */", :value 16384} {:name "CXCompletionContext_ObjCProtocol", :doc "/**\n   * Completions for Objective-C protocols should be included in\n   * the results.\n   */", :value 32768} {:name "CXCompletionContext_ObjCCategory", :doc "/**\n   * Completions for Objective-C categories should be included in\n   * the results.\n   */", :value 65536} {:name "CXCompletionContext_ObjCInstanceMessage", :doc "/**\n   * Completions for Objective-C instance messages should be included\n   * in the results.\n   */", :value 131072} {:name "CXCompletionContext_ObjCClassMessage", :doc "/**\n   * Completions for Objective-C class messages should be included in\n   * the results.\n   */", :value 262144} {:name "CXCompletionContext_ObjCSelectorName", :doc "/**\n   * Completions for Objective-C selector names should be included in\n   * the results.\n   */", :value 524288} {:name "CXCompletionContext_MacroName", :doc "/**\n   * Completions for preprocessor macro names should be included in\n   * the results.\n   */", :value 1048576} {:name "CXCompletionContext_NaturalLanguage", :doc "/**\n   * Natural language completions should be included in the results.\n   */", :value 2097152} {:name "CXCompletionContext_IncludedFile", :doc "/**\n   * #include file completions should be included in the results.\n   */", :value 4194304} {:name "CXCompletionContext_Unknown", :doc "/**\n   * The current context is unknown, so set all contexts.\n   */", :value 8388607} {:name "CXEval_Int", :doc nil, :value 1} {:name "CXEval_Float", :doc nil, :value 2} {:name "CXEval_ObjCStrLiteral", :doc nil, :value 3} {:name "CXEval_StrLiteral", :doc nil, :value 4} {:name "CXEval_CFStr", :doc nil, :value 5} {:name "CXEval_Other", :doc nil, :value 6} {:name "CXEval_UnExposed", :doc nil, :value 0} {:name "CXEval_Int", :doc nil, :value 1} {:name "CXEval_Float", :doc nil, :value 2} {:name "CXEval_ObjCStrLiteral", :doc nil, :value 3} {:name "CXEval_StrLiteral", :doc nil, :value 4} {:name "CXEval_CFStr", :doc nil, :value 5} {:name "CXEval_Other", :doc nil, :value 6} {:name "CXEval_UnExposed", :doc nil, :value 0} {:name "CXVisit_Break", :doc nil, :value 0} {:name "CXVisit_Continue", :doc nil, :value 1} {:name "CXResult_Success", :doc "/**\n   * Function returned successfully.\n   */", :value 0} {:name "CXResult_Invalid", :doc "/**\n   * One of the parameters was invalid for the function.\n   */", :value 1} {:name "CXResult_VisitBreak", :doc "/**\n   * The function was terminated by a callback (e.g. it returned\n   * CXVisit_Break)\n   */", :value 2} {:name "CXResult_Success", :doc "/**\n   * Function returned successfully.\n   */", :value 0} {:name "CXResult_Invalid", :doc "/**\n   * One of the parameters was invalid for the function.\n   */", :value 1} {:name "CXResult_VisitBreak", :doc "/**\n   * The function was terminated by a callback (e.g. it returned\n   * CXVisit_Break)\n   */", :value 2} {:name "CXIdxEntity_Unexposed", :doc nil, :value 0} {:name "CXIdxEntity_Typedef", :doc nil, :value 1} {:name "CXIdxEntity_Function", :doc nil, :value 2} {:name "CXIdxEntity_Variable", :doc nil, :value 3} {:name "CXIdxEntity_Field", :doc nil, :value 4} {:name "CXIdxEntity_EnumConstant", :doc nil, :value 5} {:name "CXIdxEntity_ObjCClass", :doc nil, :value 6} {:name "CXIdxEntity_ObjCProtocol", :doc nil, :value 7} {:name "CXIdxEntity_ObjCCategory", :doc nil, :value 8} {:name "CXIdxEntity_ObjCInstanceMethod", :doc nil, :value 9} {:name "CXIdxEntity_ObjCClassMethod", :doc nil, :value 10} {:name "CXIdxEntity_ObjCProperty", :doc nil, :value 11} {:name "CXIdxEntity_ObjCIvar", :doc nil, :value 12} {:name "CXIdxEntity_Enum", :doc nil, :value 13} {:name "CXIdxEntity_Struct", :doc nil, :value 14} {:name "CXIdxEntity_Union", :doc nil, :value 15} {:name "CXIdxEntity_CXXClass", :doc nil, :value 16} {:name "CXIdxEntity_CXXNamespace", :doc nil, :value 17} {:name "CXIdxEntity_CXXNamespaceAlias", :doc nil, :value 18} {:name "CXIdxEntity_CXXStaticVariable", :doc nil, :value 19} {:name "CXIdxEntity_CXXStaticMethod", :doc nil, :value 20} {:name "CXIdxEntity_CXXInstanceMethod", :doc nil, :value 21} {:name "CXIdxEntity_CXXConstructor", :doc nil, :value 22} {:name "CXIdxEntity_CXXDestructor", :doc nil, :value 23} {:name "CXIdxEntity_CXXConversionFunction", :doc nil, :value 24} {:name "CXIdxEntity_CXXTypeAlias", :doc nil, :value 25} {:name "CXIdxEntity_CXXInterface", :doc nil, :value 26} {:name "CXIdxEntity_Unexposed", :doc nil, :value 0} {:name "CXIdxEntity_Typedef", :doc nil, :value 1} {:name "CXIdxEntity_Function", :doc nil, :value 2} {:name "CXIdxEntity_Variable", :doc nil, :value 3} {:name "CXIdxEntity_Field", :doc nil, :value 4} {:name "CXIdxEntity_EnumConstant", :doc nil, :value 5} {:name "CXIdxEntity_ObjCClass", :doc nil, :value 6} {:name "CXIdxEntity_ObjCProtocol", :doc nil, :value 7} {:name "CXIdxEntity_ObjCCategory", :doc nil, :value 8} {:name "CXIdxEntity_ObjCInstanceMethod", :doc nil, :value 9} {:name "CXIdxEntity_ObjCClassMethod", :doc nil, :value 10} {:name "CXIdxEntity_ObjCProperty", :doc nil, :value 11} {:name "CXIdxEntity_ObjCIvar", :doc nil, :value 12} {:name "CXIdxEntity_Enum", :doc nil, :value 13} {:name "CXIdxEntity_Struct", :doc nil, :value 14} {:name "CXIdxEntity_Union", :doc nil, :value 15} {:name "CXIdxEntity_CXXClass", :doc nil, :value 16} {:name "CXIdxEntity_CXXNamespace", :doc nil, :value 17} {:name "CXIdxEntity_CXXNamespaceAlias", :doc nil, :value 18} {:name "CXIdxEntity_CXXStaticVariable", :doc nil, :value 19} {:name "CXIdxEntity_CXXStaticMethod", :doc nil, :value 20} {:name "CXIdxEntity_CXXInstanceMethod", :doc nil, :value 21} {:name "CXIdxEntity_CXXConstructor", :doc nil, :value 22} {:name "CXIdxEntity_CXXDestructor", :doc nil, :value 23} {:name "CXIdxEntity_CXXConversionFunction", :doc nil, :value 24} {:name "CXIdxEntity_CXXTypeAlias", :doc nil, :value 25} {:name "CXIdxEntity_CXXInterface", :doc nil, :value 26} {:name "CXIdxEntityLang_None", :doc nil, :value 0} {:name "CXIdxEntityLang_C", :doc nil, :value 1} {:name "CXIdxEntityLang_ObjC", :doc nil, :value 2} {:name "CXIdxEntityLang_CXX", :doc nil, :value 3} {:name "CXIdxEntityLang_Swift", :doc nil, :value 4} {:name "CXIdxEntityLang_None", :doc nil, :value 0} {:name "CXIdxEntityLang_C", :doc nil, :value 1} {:name "CXIdxEntityLang_ObjC", :doc nil, :value 2} {:name "CXIdxEntityLang_CXX", :doc nil, :value 3} {:name "CXIdxEntityLang_Swift", :doc nil, :value 4} {:name "CXIdxEntity_NonTemplate", :doc nil, :value 0} {:name "CXIdxEntity_Template", :doc nil, :value 1} {:name "CXIdxEntity_TemplatePartialSpecialization", :doc nil, :value 2} {:name "CXIdxEntity_TemplateSpecialization", :doc nil, :value 3} {:name "CXIdxEntity_NonTemplate", :doc nil, :value 0} {:name "CXIdxEntity_Template", :doc nil, :value 1} {:name "CXIdxEntity_TemplatePartialSpecialization", :doc nil, :value 2} {:name "CXIdxEntity_TemplateSpecialization", :doc nil, :value 3} {:name "CXIdxAttr_Unexposed", :doc nil, :value 0} {:name "CXIdxAttr_IBAction", :doc nil, :value 1} {:name "CXIdxAttr_IBOutlet", :doc nil, :value 2} {:name "CXIdxAttr_IBOutletCollection", :doc nil, :value 3} {:name "CXIdxAttr_Unexposed", :doc nil, :value 0} {:name "CXIdxAttr_IBAction", :doc nil, :value 1} {:name "CXIdxAttr_IBOutlet", :doc nil, :value 2} {:name "CXIdxAttr_IBOutletCollection", :doc nil, :value 3} {:name "CXIdxDeclFlag_Skipped", :doc nil, :value 1} {:name "CXIdxDeclFlag_Skipped", :doc nil, :value 1} {:name "CXIdxObjCContainer_ForwardRef", :doc nil, :value 0} {:name "CXIdxObjCContainer_Interface", :doc nil, :value 1} {:name "CXIdxObjCContainer_Implementation", :doc nil, :value 2} {:name "CXIdxObjCContainer_ForwardRef", :doc nil, :value 0} {:name "CXIdxObjCContainer_Interface", :doc nil, :value 1} {:name "CXIdxObjCContainer_Implementation", :doc nil, :value 2} {:name "CXIdxEntityRef_Direct", :doc "/**\n   * The entity is referenced directly in user's code.\n   */", :value 1} {:name "CXIdxEntityRef_Implicit", :doc "/**\n   * An implicit reference, e.g. a reference of an Objective-C method\n   * via the dot syntax.\n   */", :value 2} {:name "CXIdxEntityRef_Direct", :doc "/**\n   * The entity is referenced directly in user's code.\n   */", :value 1} {:name "CXIdxEntityRef_Implicit", :doc "/**\n   * An implicit reference, e.g. a reference of an Objective-C method\n   * via the dot syntax.\n   */", :value 2} {:name "CXSymbolRole_None", :doc nil, :value 0} {:name "CXSymbolRole_Declaration", :doc nil, :value 1} {:name "CXSymbolRole_Definition", :doc nil, :value 2} {:name "CXSymbolRole_Reference", :doc nil, :value 4} {:name "CXSymbolRole_Read", :doc nil, :value 8} {:name "CXSymbolRole_Write", :doc nil, :value 16} {:name "CXSymbolRole_Call", :doc nil, :value 32} {:name "CXSymbolRole_Dynamic", :doc nil, :value 64} {:name "CXSymbolRole_AddressOf", :doc nil, :value 128} {:name "CXSymbolRole_Implicit", :doc nil, :value 256} {:name "CXSymbolRole_None", :doc nil, :value 0} {:name "CXSymbolRole_Declaration", :doc nil, :value 1} {:name "CXSymbolRole_Definition", :doc nil, :value 2} {:name "CXSymbolRole_Reference", :doc nil, :value 4} {:name "CXSymbolRole_Read", :doc nil, :value 8} {:name "CXSymbolRole_Write", :doc nil, :value 16} {:name "CXSymbolRole_Call", :doc nil, :value 32} {:name "CXSymbolRole_Dynamic", :doc nil, :value 64} {:name "CXSymbolRole_AddressOf", :doc nil, :value 128} {:name "CXSymbolRole_Implicit", :doc nil, :value 256} {:name "CXIndexOpt_None", :doc "/**\n   * Used to indicate that no special indexing options are needed.\n   */", :value 0} {:name "CXIndexOpt_SuppressRedundantRefs", :doc "/**\n   * Used to indicate that IndexerCallbacks#indexEntityReference should\n   * be invoked for only one reference of an entity per source file that does\n   * not also include a declaration/definition of the entity.\n   */", :value 1} {:name "CXIndexOpt_IndexFunctionLocalSymbols", :doc "/**\n   * Function-local symbols should be indexed. If this is not set\n   * function-local symbols will be ignored.\n   */", :value 2} {:name "CXIndexOpt_IndexImplicitTemplateInstantiations", :doc "/**\n   * Implicit function/class template instantiations should be indexed.\n   * If this is not set, implicit instantiations will be ignored.\n   */", :value 4} {:name "CXIndexOpt_SuppressWarnings", :doc "/**\n   * Suppress all compiler warnings when parsing for indexing.\n   */", :value 8} {:name "CXIndexOpt_SkipParsedBodiesInSession", :doc "/**\n   * Skip a function/method body that was already parsed during an\n   * indexing session associated with a \\c CXIndexAction object.\n   * Bodies in system headers are always skipped.\n   */", :value 16} {:name "CXIndexOpt_None", :doc "/**\n   * Used to indicate that no special indexing options are needed.\n   */", :value 0} {:name "CXIndexOpt_SuppressRedundantRefs", :doc "/**\n   * Used to indicate that IndexerCallbacks#indexEntityReference should\n   * be invoked for only one reference of an entity per source file that does\n   * not also include a declaration/definition of the entity.\n   */", :value 1} {:name "CXIndexOpt_IndexFunctionLocalSymbols", :doc "/**\n   * Function-local symbols should be indexed. If this is not set\n   * function-local symbols will be ignored.\n   */", :value 2} {:name "CXIndexOpt_IndexImplicitTemplateInstantiations", :doc "/**\n   * Implicit function/class template instantiations should be indexed.\n   * If this is not set, implicit instantiations will be ignored.\n   */", :value 4} {:name "CXIndexOpt_SuppressWarnings", :doc "/**\n   * Suppress all compiler warnings when parsing for indexing.\n   */", :value 8} {:name "CXIndexOpt_SkipParsedBodiesInSession", :doc "/**\n   * Skip a function/method body that was already parsed during an\n   * indexing session associated with a \\c CXIndexAction object.\n   * Bodies in system headers are always skipped.\n   */", :value 16})}